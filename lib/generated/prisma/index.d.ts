
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model EFMigrationsHistory
 * 
 */
export type EFMigrationsHistory = $Result.DefaultSelection<Prisma.$EFMigrationsHistoryPayload>
/**
 * Model AccessLog
 * 
 */
export type AccessLog = $Result.DefaultSelection<Prisma.$AccessLogPayload>
/**
 * Model AppSurvey
 * 
 */
export type AppSurvey = $Result.DefaultSelection<Prisma.$AppSurveyPayload>
/**
 * Model AspNetRoleClaims
 * 
 */
export type AspNetRoleClaims = $Result.DefaultSelection<Prisma.$AspNetRoleClaimsPayload>
/**
 * Model AspNetRoles
 * 
 */
export type AspNetRoles = $Result.DefaultSelection<Prisma.$AspNetRolesPayload>
/**
 * Model AspNetUserClaims
 * 
 */
export type AspNetUserClaims = $Result.DefaultSelection<Prisma.$AspNetUserClaimsPayload>
/**
 * Model AspNetUserLogins
 * 
 */
export type AspNetUserLogins = $Result.DefaultSelection<Prisma.$AspNetUserLoginsPayload>
/**
 * Model AspNetUserRoles
 * 
 */
export type AspNetUserRoles = $Result.DefaultSelection<Prisma.$AspNetUserRolesPayload>
/**
 * Model AspNetUsers
 * 
 */
export type AspNetUsers = $Result.DefaultSelection<Prisma.$AspNetUsersPayload>
/**
 * Model AspNetUserTokens
 * 
 */
export type AspNetUserTokens = $Result.DefaultSelection<Prisma.$AspNetUserTokensPayload>
/**
 * Model CardReplacementRequests
 * 
 */
export type CardReplacementRequests = $Result.DefaultSelection<Prisma.$CardReplacementRequestsPayload>
/**
 * Model DetractorsFeedback
 * 
 */
export type DetractorsFeedback = $Result.DefaultSelection<Prisma.$DetractorsFeedbackPayload>
/**
 * Model DeviceAccessLog
 * 
 */
export type DeviceAccessLog = $Result.DefaultSelection<Prisma.$DeviceAccessLogPayload>
/**
 * Model DeviceCodes
 * 
 */
export type DeviceCodes = $Result.DefaultSelection<Prisma.$DeviceCodesPayload>
/**
 * Model EwPayActivatedCards
 * 
 */
export type EwPayActivatedCards = $Result.DefaultSelection<Prisma.$EwPayActivatedCardsPayload>
/**
 * Model EwPayIneligibleCards
 * 
 */
export type EwPayIneligibleCards = $Result.DefaultSelection<Prisma.$EwPayIneligibleCardsPayload>
/**
 * Model InvalidDeviceAccess
 * 
 */
export type InvalidDeviceAccess = $Result.DefaultSelection<Prisma.$InvalidDeviceAccessPayload>
/**
 * Model MastercardProvisionedTokens
 * 
 */
export type MastercardProvisionedTokens = $Result.DefaultSelection<Prisma.$MastercardProvisionedTokensPayload>
/**
 * Model PersistedGrants
 * 
 */
export type PersistedGrants = $Result.DefaultSelection<Prisma.$PersistedGrantsPayload>
/**
 * Model ProvisionedTokenIds
 * 
 */
export type ProvisionedTokenIds = $Result.DefaultSelection<Prisma.$ProvisionedTokenIdsPayload>
/**
 * Model RegisterLogEntry
 * 
 */
export type RegisterLogEntry = $Result.DefaultSelection<Prisma.$RegisterLogEntryPayload>
/**
 * Model sysdiagrams
 * 
 */
export type sysdiagrams = $Result.DefaultSelection<Prisma.$sysdiagramsPayload>
/**
 * Model TapToPayTransactionLog
 * 
 */
export type TapToPayTransactionLog = $Result.DefaultSelection<Prisma.$TapToPayTransactionLogPayload>
/**
 * Model TokenStatuses
 * 
 */
export type TokenStatuses = $Result.DefaultSelection<Prisma.$TokenStatusesPayload>
/**
 * Model VisaProvisionedTokens
 * 
 */
export type VisaProvisionedTokens = $Result.DefaultSelection<Prisma.$VisaProvisionedTokensPayload>
/**
 * Model VisaRequests
 * 
 */
export type VisaRequests = $Result.DefaultSelection<Prisma.$VisaRequestsPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more EFMigrationsHistories
 * const eFMigrationsHistories = await prisma.eFMigrationsHistory.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more EFMigrationsHistories
   * const eFMigrationsHistories = await prisma.eFMigrationsHistory.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.eFMigrationsHistory`: Exposes CRUD operations for the **EFMigrationsHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EFMigrationsHistories
    * const eFMigrationsHistories = await prisma.eFMigrationsHistory.findMany()
    * ```
    */
  get eFMigrationsHistory(): Prisma.EFMigrationsHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.accessLog`: Exposes CRUD operations for the **AccessLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AccessLogs
    * const accessLogs = await prisma.accessLog.findMany()
    * ```
    */
  get accessLog(): Prisma.AccessLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.appSurvey`: Exposes CRUD operations for the **AppSurvey** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AppSurveys
    * const appSurveys = await prisma.appSurvey.findMany()
    * ```
    */
  get appSurvey(): Prisma.AppSurveyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aspNetRoleClaims`: Exposes CRUD operations for the **AspNetRoleClaims** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AspNetRoleClaims
    * const aspNetRoleClaims = await prisma.aspNetRoleClaims.findMany()
    * ```
    */
  get aspNetRoleClaims(): Prisma.AspNetRoleClaimsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aspNetRoles`: Exposes CRUD operations for the **AspNetRoles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AspNetRoles
    * const aspNetRoles = await prisma.aspNetRoles.findMany()
    * ```
    */
  get aspNetRoles(): Prisma.AspNetRolesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aspNetUserClaims`: Exposes CRUD operations for the **AspNetUserClaims** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AspNetUserClaims
    * const aspNetUserClaims = await prisma.aspNetUserClaims.findMany()
    * ```
    */
  get aspNetUserClaims(): Prisma.AspNetUserClaimsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aspNetUserLogins`: Exposes CRUD operations for the **AspNetUserLogins** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AspNetUserLogins
    * const aspNetUserLogins = await prisma.aspNetUserLogins.findMany()
    * ```
    */
  get aspNetUserLogins(): Prisma.AspNetUserLoginsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aspNetUserRoles`: Exposes CRUD operations for the **AspNetUserRoles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AspNetUserRoles
    * const aspNetUserRoles = await prisma.aspNetUserRoles.findMany()
    * ```
    */
  get aspNetUserRoles(): Prisma.AspNetUserRolesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aspNetUsers`: Exposes CRUD operations for the **AspNetUsers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AspNetUsers
    * const aspNetUsers = await prisma.aspNetUsers.findMany()
    * ```
    */
  get aspNetUsers(): Prisma.AspNetUsersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.aspNetUserTokens`: Exposes CRUD operations for the **AspNetUserTokens** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AspNetUserTokens
    * const aspNetUserTokens = await prisma.aspNetUserTokens.findMany()
    * ```
    */
  get aspNetUserTokens(): Prisma.AspNetUserTokensDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cardReplacementRequests`: Exposes CRUD operations for the **CardReplacementRequests** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CardReplacementRequests
    * const cardReplacementRequests = await prisma.cardReplacementRequests.findMany()
    * ```
    */
  get cardReplacementRequests(): Prisma.CardReplacementRequestsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.detractorsFeedback`: Exposes CRUD operations for the **DetractorsFeedback** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DetractorsFeedbacks
    * const detractorsFeedbacks = await prisma.detractorsFeedback.findMany()
    * ```
    */
  get detractorsFeedback(): Prisma.DetractorsFeedbackDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deviceAccessLog`: Exposes CRUD operations for the **DeviceAccessLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeviceAccessLogs
    * const deviceAccessLogs = await prisma.deviceAccessLog.findMany()
    * ```
    */
  get deviceAccessLog(): Prisma.DeviceAccessLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deviceCodes`: Exposes CRUD operations for the **DeviceCodes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeviceCodes
    * const deviceCodes = await prisma.deviceCodes.findMany()
    * ```
    */
  get deviceCodes(): Prisma.DeviceCodesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ewPayActivatedCards`: Exposes CRUD operations for the **EwPayActivatedCards** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EwPayActivatedCards
    * const ewPayActivatedCards = await prisma.ewPayActivatedCards.findMany()
    * ```
    */
  get ewPayActivatedCards(): Prisma.EwPayActivatedCardsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ewPayIneligibleCards`: Exposes CRUD operations for the **EwPayIneligibleCards** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EwPayIneligibleCards
    * const ewPayIneligibleCards = await prisma.ewPayIneligibleCards.findMany()
    * ```
    */
  get ewPayIneligibleCards(): Prisma.EwPayIneligibleCardsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invalidDeviceAccess`: Exposes CRUD operations for the **InvalidDeviceAccess** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvalidDeviceAccesses
    * const invalidDeviceAccesses = await prisma.invalidDeviceAccess.findMany()
    * ```
    */
  get invalidDeviceAccess(): Prisma.InvalidDeviceAccessDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mastercardProvisionedTokens`: Exposes CRUD operations for the **MastercardProvisionedTokens** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MastercardProvisionedTokens
    * const mastercardProvisionedTokens = await prisma.mastercardProvisionedTokens.findMany()
    * ```
    */
  get mastercardProvisionedTokens(): Prisma.MastercardProvisionedTokensDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.persistedGrants`: Exposes CRUD operations for the **PersistedGrants** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PersistedGrants
    * const persistedGrants = await prisma.persistedGrants.findMany()
    * ```
    */
  get persistedGrants(): Prisma.PersistedGrantsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.provisionedTokenIds`: Exposes CRUD operations for the **ProvisionedTokenIds** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProvisionedTokenIds
    * const provisionedTokenIds = await prisma.provisionedTokenIds.findMany()
    * ```
    */
  get provisionedTokenIds(): Prisma.ProvisionedTokenIdsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.registerLogEntry`: Exposes CRUD operations for the **RegisterLogEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RegisterLogEntries
    * const registerLogEntries = await prisma.registerLogEntry.findMany()
    * ```
    */
  get registerLogEntry(): Prisma.RegisterLogEntryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sysdiagrams`: Exposes CRUD operations for the **sysdiagrams** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sysdiagrams
    * const sysdiagrams = await prisma.sysdiagrams.findMany()
    * ```
    */
  get sysdiagrams(): Prisma.sysdiagramsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tapToPayTransactionLog`: Exposes CRUD operations for the **TapToPayTransactionLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TapToPayTransactionLogs
    * const tapToPayTransactionLogs = await prisma.tapToPayTransactionLog.findMany()
    * ```
    */
  get tapToPayTransactionLog(): Prisma.TapToPayTransactionLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tokenStatuses`: Exposes CRUD operations for the **TokenStatuses** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TokenStatuses
    * const tokenStatuses = await prisma.tokenStatuses.findMany()
    * ```
    */
  get tokenStatuses(): Prisma.TokenStatusesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.visaProvisionedTokens`: Exposes CRUD operations for the **VisaProvisionedTokens** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VisaProvisionedTokens
    * const visaProvisionedTokens = await prisma.visaProvisionedTokens.findMany()
    * ```
    */
  get visaProvisionedTokens(): Prisma.VisaProvisionedTokensDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.visaRequests`: Exposes CRUD operations for the **VisaRequests** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VisaRequests
    * const visaRequests = await prisma.visaRequests.findMany()
    * ```
    */
  get visaRequests(): Prisma.VisaRequestsDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.7.0
   * Query Engine version: 3cff47a7f5d65c3ea74883f1d736e41d68ce91ed
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    EFMigrationsHistory: 'EFMigrationsHistory',
    AccessLog: 'AccessLog',
    AppSurvey: 'AppSurvey',
    AspNetRoleClaims: 'AspNetRoleClaims',
    AspNetRoles: 'AspNetRoles',
    AspNetUserClaims: 'AspNetUserClaims',
    AspNetUserLogins: 'AspNetUserLogins',
    AspNetUserRoles: 'AspNetUserRoles',
    AspNetUsers: 'AspNetUsers',
    AspNetUserTokens: 'AspNetUserTokens',
    CardReplacementRequests: 'CardReplacementRequests',
    DetractorsFeedback: 'DetractorsFeedback',
    DeviceAccessLog: 'DeviceAccessLog',
    DeviceCodes: 'DeviceCodes',
    EwPayActivatedCards: 'EwPayActivatedCards',
    EwPayIneligibleCards: 'EwPayIneligibleCards',
    InvalidDeviceAccess: 'InvalidDeviceAccess',
    MastercardProvisionedTokens: 'MastercardProvisionedTokens',
    PersistedGrants: 'PersistedGrants',
    ProvisionedTokenIds: 'ProvisionedTokenIds',
    RegisterLogEntry: 'RegisterLogEntry',
    sysdiagrams: 'sysdiagrams',
    TapToPayTransactionLog: 'TapToPayTransactionLog',
    TokenStatuses: 'TokenStatuses',
    VisaProvisionedTokens: 'VisaProvisionedTokens',
    VisaRequests: 'VisaRequests'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "eFMigrationsHistory" | "accessLog" | "appSurvey" | "aspNetRoleClaims" | "aspNetRoles" | "aspNetUserClaims" | "aspNetUserLogins" | "aspNetUserRoles" | "aspNetUsers" | "aspNetUserTokens" | "cardReplacementRequests" | "detractorsFeedback" | "deviceAccessLog" | "deviceCodes" | "ewPayActivatedCards" | "ewPayIneligibleCards" | "invalidDeviceAccess" | "mastercardProvisionedTokens" | "persistedGrants" | "provisionedTokenIds" | "registerLogEntry" | "sysdiagrams" | "tapToPayTransactionLog" | "tokenStatuses" | "visaProvisionedTokens" | "visaRequests"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      EFMigrationsHistory: {
        payload: Prisma.$EFMigrationsHistoryPayload<ExtArgs>
        fields: Prisma.EFMigrationsHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EFMigrationsHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EFMigrationsHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EFMigrationsHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EFMigrationsHistoryPayload>
          }
          findFirst: {
            args: Prisma.EFMigrationsHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EFMigrationsHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EFMigrationsHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EFMigrationsHistoryPayload>
          }
          findMany: {
            args: Prisma.EFMigrationsHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EFMigrationsHistoryPayload>[]
          }
          create: {
            args: Prisma.EFMigrationsHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EFMigrationsHistoryPayload>
          }
          createMany: {
            args: Prisma.EFMigrationsHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EFMigrationsHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EFMigrationsHistoryPayload>
          }
          update: {
            args: Prisma.EFMigrationsHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EFMigrationsHistoryPayload>
          }
          deleteMany: {
            args: Prisma.EFMigrationsHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EFMigrationsHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EFMigrationsHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EFMigrationsHistoryPayload>
          }
          aggregate: {
            args: Prisma.EFMigrationsHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEFMigrationsHistory>
          }
          groupBy: {
            args: Prisma.EFMigrationsHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<EFMigrationsHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.EFMigrationsHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<EFMigrationsHistoryCountAggregateOutputType> | number
          }
        }
      }
      AccessLog: {
        payload: Prisma.$AccessLogPayload<ExtArgs>
        fields: Prisma.AccessLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccessLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccessLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessLogPayload>
          }
          findFirst: {
            args: Prisma.AccessLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccessLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessLogPayload>
          }
          findMany: {
            args: Prisma.AccessLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessLogPayload>[]
          }
          create: {
            args: Prisma.AccessLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessLogPayload>
          }
          createMany: {
            args: Prisma.AccessLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AccessLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessLogPayload>
          }
          update: {
            args: Prisma.AccessLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessLogPayload>
          }
          deleteMany: {
            args: Prisma.AccessLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccessLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AccessLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessLogPayload>
          }
          aggregate: {
            args: Prisma.AccessLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccessLog>
          }
          groupBy: {
            args: Prisma.AccessLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccessLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccessLogCountArgs<ExtArgs>
            result: $Utils.Optional<AccessLogCountAggregateOutputType> | number
          }
        }
      }
      AppSurvey: {
        payload: Prisma.$AppSurveyPayload<ExtArgs>
        fields: Prisma.AppSurveyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AppSurveyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppSurveyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AppSurveyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppSurveyPayload>
          }
          findFirst: {
            args: Prisma.AppSurveyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppSurveyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AppSurveyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppSurveyPayload>
          }
          findMany: {
            args: Prisma.AppSurveyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppSurveyPayload>[]
          }
          create: {
            args: Prisma.AppSurveyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppSurveyPayload>
          }
          createMany: {
            args: Prisma.AppSurveyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AppSurveyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppSurveyPayload>
          }
          update: {
            args: Prisma.AppSurveyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppSurveyPayload>
          }
          deleteMany: {
            args: Prisma.AppSurveyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AppSurveyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AppSurveyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppSurveyPayload>
          }
          aggregate: {
            args: Prisma.AppSurveyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAppSurvey>
          }
          groupBy: {
            args: Prisma.AppSurveyGroupByArgs<ExtArgs>
            result: $Utils.Optional<AppSurveyGroupByOutputType>[]
          }
          count: {
            args: Prisma.AppSurveyCountArgs<ExtArgs>
            result: $Utils.Optional<AppSurveyCountAggregateOutputType> | number
          }
        }
      }
      AspNetRoleClaims: {
        payload: Prisma.$AspNetRoleClaimsPayload<ExtArgs>
        fields: Prisma.AspNetRoleClaimsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AspNetRoleClaimsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetRoleClaimsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AspNetRoleClaimsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetRoleClaimsPayload>
          }
          findFirst: {
            args: Prisma.AspNetRoleClaimsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetRoleClaimsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AspNetRoleClaimsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetRoleClaimsPayload>
          }
          findMany: {
            args: Prisma.AspNetRoleClaimsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetRoleClaimsPayload>[]
          }
          create: {
            args: Prisma.AspNetRoleClaimsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetRoleClaimsPayload>
          }
          createMany: {
            args: Prisma.AspNetRoleClaimsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AspNetRoleClaimsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetRoleClaimsPayload>
          }
          update: {
            args: Prisma.AspNetRoleClaimsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetRoleClaimsPayload>
          }
          deleteMany: {
            args: Prisma.AspNetRoleClaimsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AspNetRoleClaimsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AspNetRoleClaimsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetRoleClaimsPayload>
          }
          aggregate: {
            args: Prisma.AspNetRoleClaimsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAspNetRoleClaims>
          }
          groupBy: {
            args: Prisma.AspNetRoleClaimsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AspNetRoleClaimsGroupByOutputType>[]
          }
          count: {
            args: Prisma.AspNetRoleClaimsCountArgs<ExtArgs>
            result: $Utils.Optional<AspNetRoleClaimsCountAggregateOutputType> | number
          }
        }
      }
      AspNetRoles: {
        payload: Prisma.$AspNetRolesPayload<ExtArgs>
        fields: Prisma.AspNetRolesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AspNetRolesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetRolesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AspNetRolesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetRolesPayload>
          }
          findFirst: {
            args: Prisma.AspNetRolesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetRolesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AspNetRolesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetRolesPayload>
          }
          findMany: {
            args: Prisma.AspNetRolesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetRolesPayload>[]
          }
          create: {
            args: Prisma.AspNetRolesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetRolesPayload>
          }
          createMany: {
            args: Prisma.AspNetRolesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AspNetRolesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetRolesPayload>
          }
          update: {
            args: Prisma.AspNetRolesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetRolesPayload>
          }
          deleteMany: {
            args: Prisma.AspNetRolesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AspNetRolesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AspNetRolesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetRolesPayload>
          }
          aggregate: {
            args: Prisma.AspNetRolesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAspNetRoles>
          }
          groupBy: {
            args: Prisma.AspNetRolesGroupByArgs<ExtArgs>
            result: $Utils.Optional<AspNetRolesGroupByOutputType>[]
          }
          count: {
            args: Prisma.AspNetRolesCountArgs<ExtArgs>
            result: $Utils.Optional<AspNetRolesCountAggregateOutputType> | number
          }
        }
      }
      AspNetUserClaims: {
        payload: Prisma.$AspNetUserClaimsPayload<ExtArgs>
        fields: Prisma.AspNetUserClaimsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AspNetUserClaimsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUserClaimsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AspNetUserClaimsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUserClaimsPayload>
          }
          findFirst: {
            args: Prisma.AspNetUserClaimsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUserClaimsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AspNetUserClaimsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUserClaimsPayload>
          }
          findMany: {
            args: Prisma.AspNetUserClaimsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUserClaimsPayload>[]
          }
          create: {
            args: Prisma.AspNetUserClaimsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUserClaimsPayload>
          }
          createMany: {
            args: Prisma.AspNetUserClaimsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AspNetUserClaimsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUserClaimsPayload>
          }
          update: {
            args: Prisma.AspNetUserClaimsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUserClaimsPayload>
          }
          deleteMany: {
            args: Prisma.AspNetUserClaimsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AspNetUserClaimsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AspNetUserClaimsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUserClaimsPayload>
          }
          aggregate: {
            args: Prisma.AspNetUserClaimsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAspNetUserClaims>
          }
          groupBy: {
            args: Prisma.AspNetUserClaimsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AspNetUserClaimsGroupByOutputType>[]
          }
          count: {
            args: Prisma.AspNetUserClaimsCountArgs<ExtArgs>
            result: $Utils.Optional<AspNetUserClaimsCountAggregateOutputType> | number
          }
        }
      }
      AspNetUserLogins: {
        payload: Prisma.$AspNetUserLoginsPayload<ExtArgs>
        fields: Prisma.AspNetUserLoginsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AspNetUserLoginsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUserLoginsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AspNetUserLoginsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUserLoginsPayload>
          }
          findFirst: {
            args: Prisma.AspNetUserLoginsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUserLoginsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AspNetUserLoginsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUserLoginsPayload>
          }
          findMany: {
            args: Prisma.AspNetUserLoginsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUserLoginsPayload>[]
          }
          create: {
            args: Prisma.AspNetUserLoginsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUserLoginsPayload>
          }
          createMany: {
            args: Prisma.AspNetUserLoginsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AspNetUserLoginsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUserLoginsPayload>
          }
          update: {
            args: Prisma.AspNetUserLoginsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUserLoginsPayload>
          }
          deleteMany: {
            args: Prisma.AspNetUserLoginsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AspNetUserLoginsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AspNetUserLoginsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUserLoginsPayload>
          }
          aggregate: {
            args: Prisma.AspNetUserLoginsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAspNetUserLogins>
          }
          groupBy: {
            args: Prisma.AspNetUserLoginsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AspNetUserLoginsGroupByOutputType>[]
          }
          count: {
            args: Prisma.AspNetUserLoginsCountArgs<ExtArgs>
            result: $Utils.Optional<AspNetUserLoginsCountAggregateOutputType> | number
          }
        }
      }
      AspNetUserRoles: {
        payload: Prisma.$AspNetUserRolesPayload<ExtArgs>
        fields: Prisma.AspNetUserRolesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AspNetUserRolesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUserRolesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AspNetUserRolesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUserRolesPayload>
          }
          findFirst: {
            args: Prisma.AspNetUserRolesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUserRolesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AspNetUserRolesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUserRolesPayload>
          }
          findMany: {
            args: Prisma.AspNetUserRolesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUserRolesPayload>[]
          }
          create: {
            args: Prisma.AspNetUserRolesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUserRolesPayload>
          }
          createMany: {
            args: Prisma.AspNetUserRolesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AspNetUserRolesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUserRolesPayload>
          }
          update: {
            args: Prisma.AspNetUserRolesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUserRolesPayload>
          }
          deleteMany: {
            args: Prisma.AspNetUserRolesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AspNetUserRolesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AspNetUserRolesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUserRolesPayload>
          }
          aggregate: {
            args: Prisma.AspNetUserRolesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAspNetUserRoles>
          }
          groupBy: {
            args: Prisma.AspNetUserRolesGroupByArgs<ExtArgs>
            result: $Utils.Optional<AspNetUserRolesGroupByOutputType>[]
          }
          count: {
            args: Prisma.AspNetUserRolesCountArgs<ExtArgs>
            result: $Utils.Optional<AspNetUserRolesCountAggregateOutputType> | number
          }
        }
      }
      AspNetUsers: {
        payload: Prisma.$AspNetUsersPayload<ExtArgs>
        fields: Prisma.AspNetUsersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AspNetUsersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUsersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AspNetUsersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUsersPayload>
          }
          findFirst: {
            args: Prisma.AspNetUsersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUsersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AspNetUsersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUsersPayload>
          }
          findMany: {
            args: Prisma.AspNetUsersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUsersPayload>[]
          }
          create: {
            args: Prisma.AspNetUsersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUsersPayload>
          }
          createMany: {
            args: Prisma.AspNetUsersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AspNetUsersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUsersPayload>
          }
          update: {
            args: Prisma.AspNetUsersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUsersPayload>
          }
          deleteMany: {
            args: Prisma.AspNetUsersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AspNetUsersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AspNetUsersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUsersPayload>
          }
          aggregate: {
            args: Prisma.AspNetUsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAspNetUsers>
          }
          groupBy: {
            args: Prisma.AspNetUsersGroupByArgs<ExtArgs>
            result: $Utils.Optional<AspNetUsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.AspNetUsersCountArgs<ExtArgs>
            result: $Utils.Optional<AspNetUsersCountAggregateOutputType> | number
          }
        }
      }
      AspNetUserTokens: {
        payload: Prisma.$AspNetUserTokensPayload<ExtArgs>
        fields: Prisma.AspNetUserTokensFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AspNetUserTokensFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUserTokensPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AspNetUserTokensFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUserTokensPayload>
          }
          findFirst: {
            args: Prisma.AspNetUserTokensFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUserTokensPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AspNetUserTokensFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUserTokensPayload>
          }
          findMany: {
            args: Prisma.AspNetUserTokensFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUserTokensPayload>[]
          }
          create: {
            args: Prisma.AspNetUserTokensCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUserTokensPayload>
          }
          createMany: {
            args: Prisma.AspNetUserTokensCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AspNetUserTokensDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUserTokensPayload>
          }
          update: {
            args: Prisma.AspNetUserTokensUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUserTokensPayload>
          }
          deleteMany: {
            args: Prisma.AspNetUserTokensDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AspNetUserTokensUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AspNetUserTokensUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AspNetUserTokensPayload>
          }
          aggregate: {
            args: Prisma.AspNetUserTokensAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAspNetUserTokens>
          }
          groupBy: {
            args: Prisma.AspNetUserTokensGroupByArgs<ExtArgs>
            result: $Utils.Optional<AspNetUserTokensGroupByOutputType>[]
          }
          count: {
            args: Prisma.AspNetUserTokensCountArgs<ExtArgs>
            result: $Utils.Optional<AspNetUserTokensCountAggregateOutputType> | number
          }
        }
      }
      CardReplacementRequests: {
        payload: Prisma.$CardReplacementRequestsPayload<ExtArgs>
        fields: Prisma.CardReplacementRequestsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CardReplacementRequestsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardReplacementRequestsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CardReplacementRequestsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardReplacementRequestsPayload>
          }
          findFirst: {
            args: Prisma.CardReplacementRequestsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardReplacementRequestsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CardReplacementRequestsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardReplacementRequestsPayload>
          }
          findMany: {
            args: Prisma.CardReplacementRequestsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardReplacementRequestsPayload>[]
          }
          create: {
            args: Prisma.CardReplacementRequestsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardReplacementRequestsPayload>
          }
          createMany: {
            args: Prisma.CardReplacementRequestsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CardReplacementRequestsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardReplacementRequestsPayload>
          }
          update: {
            args: Prisma.CardReplacementRequestsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardReplacementRequestsPayload>
          }
          deleteMany: {
            args: Prisma.CardReplacementRequestsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CardReplacementRequestsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CardReplacementRequestsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CardReplacementRequestsPayload>
          }
          aggregate: {
            args: Prisma.CardReplacementRequestsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCardReplacementRequests>
          }
          groupBy: {
            args: Prisma.CardReplacementRequestsGroupByArgs<ExtArgs>
            result: $Utils.Optional<CardReplacementRequestsGroupByOutputType>[]
          }
          count: {
            args: Prisma.CardReplacementRequestsCountArgs<ExtArgs>
            result: $Utils.Optional<CardReplacementRequestsCountAggregateOutputType> | number
          }
        }
      }
      DetractorsFeedback: {
        payload: Prisma.$DetractorsFeedbackPayload<ExtArgs>
        fields: Prisma.DetractorsFeedbackFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DetractorsFeedbackFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetractorsFeedbackPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DetractorsFeedbackFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetractorsFeedbackPayload>
          }
          findFirst: {
            args: Prisma.DetractorsFeedbackFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetractorsFeedbackPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DetractorsFeedbackFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetractorsFeedbackPayload>
          }
          findMany: {
            args: Prisma.DetractorsFeedbackFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetractorsFeedbackPayload>[]
          }
          create: {
            args: Prisma.DetractorsFeedbackCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetractorsFeedbackPayload>
          }
          createMany: {
            args: Prisma.DetractorsFeedbackCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DetractorsFeedbackDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetractorsFeedbackPayload>
          }
          update: {
            args: Prisma.DetractorsFeedbackUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetractorsFeedbackPayload>
          }
          deleteMany: {
            args: Prisma.DetractorsFeedbackDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DetractorsFeedbackUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DetractorsFeedbackUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DetractorsFeedbackPayload>
          }
          aggregate: {
            args: Prisma.DetractorsFeedbackAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDetractorsFeedback>
          }
          groupBy: {
            args: Prisma.DetractorsFeedbackGroupByArgs<ExtArgs>
            result: $Utils.Optional<DetractorsFeedbackGroupByOutputType>[]
          }
          count: {
            args: Prisma.DetractorsFeedbackCountArgs<ExtArgs>
            result: $Utils.Optional<DetractorsFeedbackCountAggregateOutputType> | number
          }
        }
      }
      DeviceAccessLog: {
        payload: Prisma.$DeviceAccessLogPayload<ExtArgs>
        fields: Prisma.DeviceAccessLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeviceAccessLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceAccessLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeviceAccessLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceAccessLogPayload>
          }
          findFirst: {
            args: Prisma.DeviceAccessLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceAccessLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeviceAccessLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceAccessLogPayload>
          }
          findMany: {
            args: Prisma.DeviceAccessLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceAccessLogPayload>[]
          }
          create: {
            args: Prisma.DeviceAccessLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceAccessLogPayload>
          }
          createMany: {
            args: Prisma.DeviceAccessLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DeviceAccessLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceAccessLogPayload>
          }
          update: {
            args: Prisma.DeviceAccessLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceAccessLogPayload>
          }
          deleteMany: {
            args: Prisma.DeviceAccessLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeviceAccessLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DeviceAccessLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceAccessLogPayload>
          }
          aggregate: {
            args: Prisma.DeviceAccessLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeviceAccessLog>
          }
          groupBy: {
            args: Prisma.DeviceAccessLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeviceAccessLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeviceAccessLogCountArgs<ExtArgs>
            result: $Utils.Optional<DeviceAccessLogCountAggregateOutputType> | number
          }
        }
      }
      DeviceCodes: {
        payload: Prisma.$DeviceCodesPayload<ExtArgs>
        fields: Prisma.DeviceCodesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeviceCodesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceCodesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeviceCodesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceCodesPayload>
          }
          findFirst: {
            args: Prisma.DeviceCodesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceCodesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeviceCodesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceCodesPayload>
          }
          findMany: {
            args: Prisma.DeviceCodesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceCodesPayload>[]
          }
          create: {
            args: Prisma.DeviceCodesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceCodesPayload>
          }
          createMany: {
            args: Prisma.DeviceCodesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DeviceCodesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceCodesPayload>
          }
          update: {
            args: Prisma.DeviceCodesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceCodesPayload>
          }
          deleteMany: {
            args: Prisma.DeviceCodesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeviceCodesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DeviceCodesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceCodesPayload>
          }
          aggregate: {
            args: Prisma.DeviceCodesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeviceCodes>
          }
          groupBy: {
            args: Prisma.DeviceCodesGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeviceCodesGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeviceCodesCountArgs<ExtArgs>
            result: $Utils.Optional<DeviceCodesCountAggregateOutputType> | number
          }
        }
      }
      EwPayActivatedCards: {
        payload: Prisma.$EwPayActivatedCardsPayload<ExtArgs>
        fields: Prisma.EwPayActivatedCardsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EwPayActivatedCardsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwPayActivatedCardsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EwPayActivatedCardsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwPayActivatedCardsPayload>
          }
          findFirst: {
            args: Prisma.EwPayActivatedCardsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwPayActivatedCardsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EwPayActivatedCardsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwPayActivatedCardsPayload>
          }
          findMany: {
            args: Prisma.EwPayActivatedCardsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwPayActivatedCardsPayload>[]
          }
          create: {
            args: Prisma.EwPayActivatedCardsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwPayActivatedCardsPayload>
          }
          createMany: {
            args: Prisma.EwPayActivatedCardsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EwPayActivatedCardsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwPayActivatedCardsPayload>
          }
          update: {
            args: Prisma.EwPayActivatedCardsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwPayActivatedCardsPayload>
          }
          deleteMany: {
            args: Prisma.EwPayActivatedCardsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EwPayActivatedCardsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EwPayActivatedCardsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwPayActivatedCardsPayload>
          }
          aggregate: {
            args: Prisma.EwPayActivatedCardsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEwPayActivatedCards>
          }
          groupBy: {
            args: Prisma.EwPayActivatedCardsGroupByArgs<ExtArgs>
            result: $Utils.Optional<EwPayActivatedCardsGroupByOutputType>[]
          }
          count: {
            args: Prisma.EwPayActivatedCardsCountArgs<ExtArgs>
            result: $Utils.Optional<EwPayActivatedCardsCountAggregateOutputType> | number
          }
        }
      }
      EwPayIneligibleCards: {
        payload: Prisma.$EwPayIneligibleCardsPayload<ExtArgs>
        fields: Prisma.EwPayIneligibleCardsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EwPayIneligibleCardsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwPayIneligibleCardsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EwPayIneligibleCardsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwPayIneligibleCardsPayload>
          }
          findFirst: {
            args: Prisma.EwPayIneligibleCardsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwPayIneligibleCardsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EwPayIneligibleCardsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwPayIneligibleCardsPayload>
          }
          findMany: {
            args: Prisma.EwPayIneligibleCardsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwPayIneligibleCardsPayload>[]
          }
          create: {
            args: Prisma.EwPayIneligibleCardsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwPayIneligibleCardsPayload>
          }
          createMany: {
            args: Prisma.EwPayIneligibleCardsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EwPayIneligibleCardsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwPayIneligibleCardsPayload>
          }
          update: {
            args: Prisma.EwPayIneligibleCardsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwPayIneligibleCardsPayload>
          }
          deleteMany: {
            args: Prisma.EwPayIneligibleCardsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EwPayIneligibleCardsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EwPayIneligibleCardsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EwPayIneligibleCardsPayload>
          }
          aggregate: {
            args: Prisma.EwPayIneligibleCardsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEwPayIneligibleCards>
          }
          groupBy: {
            args: Prisma.EwPayIneligibleCardsGroupByArgs<ExtArgs>
            result: $Utils.Optional<EwPayIneligibleCardsGroupByOutputType>[]
          }
          count: {
            args: Prisma.EwPayIneligibleCardsCountArgs<ExtArgs>
            result: $Utils.Optional<EwPayIneligibleCardsCountAggregateOutputType> | number
          }
        }
      }
      InvalidDeviceAccess: {
        payload: Prisma.$InvalidDeviceAccessPayload<ExtArgs>
        fields: Prisma.InvalidDeviceAccessFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvalidDeviceAccessFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvalidDeviceAccessPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvalidDeviceAccessFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvalidDeviceAccessPayload>
          }
          findFirst: {
            args: Prisma.InvalidDeviceAccessFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvalidDeviceAccessPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvalidDeviceAccessFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvalidDeviceAccessPayload>
          }
          findMany: {
            args: Prisma.InvalidDeviceAccessFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvalidDeviceAccessPayload>[]
          }
          create: {
            args: Prisma.InvalidDeviceAccessCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvalidDeviceAccessPayload>
          }
          createMany: {
            args: Prisma.InvalidDeviceAccessCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.InvalidDeviceAccessDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvalidDeviceAccessPayload>
          }
          update: {
            args: Prisma.InvalidDeviceAccessUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvalidDeviceAccessPayload>
          }
          deleteMany: {
            args: Prisma.InvalidDeviceAccessDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvalidDeviceAccessUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InvalidDeviceAccessUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvalidDeviceAccessPayload>
          }
          aggregate: {
            args: Prisma.InvalidDeviceAccessAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvalidDeviceAccess>
          }
          groupBy: {
            args: Prisma.InvalidDeviceAccessGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvalidDeviceAccessGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvalidDeviceAccessCountArgs<ExtArgs>
            result: $Utils.Optional<InvalidDeviceAccessCountAggregateOutputType> | number
          }
        }
      }
      MastercardProvisionedTokens: {
        payload: Prisma.$MastercardProvisionedTokensPayload<ExtArgs>
        fields: Prisma.MastercardProvisionedTokensFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MastercardProvisionedTokensFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MastercardProvisionedTokensPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MastercardProvisionedTokensFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MastercardProvisionedTokensPayload>
          }
          findFirst: {
            args: Prisma.MastercardProvisionedTokensFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MastercardProvisionedTokensPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MastercardProvisionedTokensFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MastercardProvisionedTokensPayload>
          }
          findMany: {
            args: Prisma.MastercardProvisionedTokensFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MastercardProvisionedTokensPayload>[]
          }
          create: {
            args: Prisma.MastercardProvisionedTokensCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MastercardProvisionedTokensPayload>
          }
          createMany: {
            args: Prisma.MastercardProvisionedTokensCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MastercardProvisionedTokensDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MastercardProvisionedTokensPayload>
          }
          update: {
            args: Prisma.MastercardProvisionedTokensUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MastercardProvisionedTokensPayload>
          }
          deleteMany: {
            args: Prisma.MastercardProvisionedTokensDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MastercardProvisionedTokensUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MastercardProvisionedTokensUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MastercardProvisionedTokensPayload>
          }
          aggregate: {
            args: Prisma.MastercardProvisionedTokensAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMastercardProvisionedTokens>
          }
          groupBy: {
            args: Prisma.MastercardProvisionedTokensGroupByArgs<ExtArgs>
            result: $Utils.Optional<MastercardProvisionedTokensGroupByOutputType>[]
          }
          count: {
            args: Prisma.MastercardProvisionedTokensCountArgs<ExtArgs>
            result: $Utils.Optional<MastercardProvisionedTokensCountAggregateOutputType> | number
          }
        }
      }
      PersistedGrants: {
        payload: Prisma.$PersistedGrantsPayload<ExtArgs>
        fields: Prisma.PersistedGrantsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PersistedGrantsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersistedGrantsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PersistedGrantsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersistedGrantsPayload>
          }
          findFirst: {
            args: Prisma.PersistedGrantsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersistedGrantsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PersistedGrantsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersistedGrantsPayload>
          }
          findMany: {
            args: Prisma.PersistedGrantsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersistedGrantsPayload>[]
          }
          create: {
            args: Prisma.PersistedGrantsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersistedGrantsPayload>
          }
          createMany: {
            args: Prisma.PersistedGrantsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PersistedGrantsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersistedGrantsPayload>
          }
          update: {
            args: Prisma.PersistedGrantsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersistedGrantsPayload>
          }
          deleteMany: {
            args: Prisma.PersistedGrantsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PersistedGrantsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PersistedGrantsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersistedGrantsPayload>
          }
          aggregate: {
            args: Prisma.PersistedGrantsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePersistedGrants>
          }
          groupBy: {
            args: Prisma.PersistedGrantsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PersistedGrantsGroupByOutputType>[]
          }
          count: {
            args: Prisma.PersistedGrantsCountArgs<ExtArgs>
            result: $Utils.Optional<PersistedGrantsCountAggregateOutputType> | number
          }
        }
      }
      ProvisionedTokenIds: {
        payload: Prisma.$ProvisionedTokenIdsPayload<ExtArgs>
        fields: Prisma.ProvisionedTokenIdsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProvisionedTokenIdsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvisionedTokenIdsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProvisionedTokenIdsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvisionedTokenIdsPayload>
          }
          findFirst: {
            args: Prisma.ProvisionedTokenIdsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvisionedTokenIdsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProvisionedTokenIdsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvisionedTokenIdsPayload>
          }
          findMany: {
            args: Prisma.ProvisionedTokenIdsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvisionedTokenIdsPayload>[]
          }
          create: {
            args: Prisma.ProvisionedTokenIdsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvisionedTokenIdsPayload>
          }
          createMany: {
            args: Prisma.ProvisionedTokenIdsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProvisionedTokenIdsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvisionedTokenIdsPayload>
          }
          update: {
            args: Prisma.ProvisionedTokenIdsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvisionedTokenIdsPayload>
          }
          deleteMany: {
            args: Prisma.ProvisionedTokenIdsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProvisionedTokenIdsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProvisionedTokenIdsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProvisionedTokenIdsPayload>
          }
          aggregate: {
            args: Prisma.ProvisionedTokenIdsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProvisionedTokenIds>
          }
          groupBy: {
            args: Prisma.ProvisionedTokenIdsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProvisionedTokenIdsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProvisionedTokenIdsCountArgs<ExtArgs>
            result: $Utils.Optional<ProvisionedTokenIdsCountAggregateOutputType> | number
          }
        }
      }
      RegisterLogEntry: {
        payload: Prisma.$RegisterLogEntryPayload<ExtArgs>
        fields: Prisma.RegisterLogEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RegisterLogEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegisterLogEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RegisterLogEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegisterLogEntryPayload>
          }
          findFirst: {
            args: Prisma.RegisterLogEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegisterLogEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RegisterLogEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegisterLogEntryPayload>
          }
          findMany: {
            args: Prisma.RegisterLogEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegisterLogEntryPayload>[]
          }
          create: {
            args: Prisma.RegisterLogEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegisterLogEntryPayload>
          }
          createMany: {
            args: Prisma.RegisterLogEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RegisterLogEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegisterLogEntryPayload>
          }
          update: {
            args: Prisma.RegisterLogEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegisterLogEntryPayload>
          }
          deleteMany: {
            args: Prisma.RegisterLogEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RegisterLogEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RegisterLogEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegisterLogEntryPayload>
          }
          aggregate: {
            args: Prisma.RegisterLogEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRegisterLogEntry>
          }
          groupBy: {
            args: Prisma.RegisterLogEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<RegisterLogEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.RegisterLogEntryCountArgs<ExtArgs>
            result: $Utils.Optional<RegisterLogEntryCountAggregateOutputType> | number
          }
        }
      }
      sysdiagrams: {
        payload: Prisma.$sysdiagramsPayload<ExtArgs>
        fields: Prisma.sysdiagramsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.sysdiagramsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sysdiagramsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.sysdiagramsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sysdiagramsPayload>
          }
          findFirst: {
            args: Prisma.sysdiagramsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sysdiagramsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.sysdiagramsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sysdiagramsPayload>
          }
          findMany: {
            args: Prisma.sysdiagramsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sysdiagramsPayload>[]
          }
          create: {
            args: Prisma.sysdiagramsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sysdiagramsPayload>
          }
          createMany: {
            args: Prisma.sysdiagramsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.sysdiagramsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sysdiagramsPayload>
          }
          update: {
            args: Prisma.sysdiagramsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sysdiagramsPayload>
          }
          deleteMany: {
            args: Prisma.sysdiagramsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.sysdiagramsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.sysdiagramsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sysdiagramsPayload>
          }
          aggregate: {
            args: Prisma.SysdiagramsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSysdiagrams>
          }
          groupBy: {
            args: Prisma.sysdiagramsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SysdiagramsGroupByOutputType>[]
          }
          count: {
            args: Prisma.sysdiagramsCountArgs<ExtArgs>
            result: $Utils.Optional<SysdiagramsCountAggregateOutputType> | number
          }
        }
      }
      TapToPayTransactionLog: {
        payload: Prisma.$TapToPayTransactionLogPayload<ExtArgs>
        fields: Prisma.TapToPayTransactionLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TapToPayTransactionLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TapToPayTransactionLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TapToPayTransactionLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TapToPayTransactionLogPayload>
          }
          findFirst: {
            args: Prisma.TapToPayTransactionLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TapToPayTransactionLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TapToPayTransactionLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TapToPayTransactionLogPayload>
          }
          findMany: {
            args: Prisma.TapToPayTransactionLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TapToPayTransactionLogPayload>[]
          }
          create: {
            args: Prisma.TapToPayTransactionLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TapToPayTransactionLogPayload>
          }
          createMany: {
            args: Prisma.TapToPayTransactionLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TapToPayTransactionLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TapToPayTransactionLogPayload>
          }
          update: {
            args: Prisma.TapToPayTransactionLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TapToPayTransactionLogPayload>
          }
          deleteMany: {
            args: Prisma.TapToPayTransactionLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TapToPayTransactionLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TapToPayTransactionLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TapToPayTransactionLogPayload>
          }
          aggregate: {
            args: Prisma.TapToPayTransactionLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTapToPayTransactionLog>
          }
          groupBy: {
            args: Prisma.TapToPayTransactionLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<TapToPayTransactionLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.TapToPayTransactionLogCountArgs<ExtArgs>
            result: $Utils.Optional<TapToPayTransactionLogCountAggregateOutputType> | number
          }
        }
      }
      TokenStatuses: {
        payload: Prisma.$TokenStatusesPayload<ExtArgs>
        fields: Prisma.TokenStatusesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TokenStatusesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenStatusesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TokenStatusesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenStatusesPayload>
          }
          findFirst: {
            args: Prisma.TokenStatusesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenStatusesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TokenStatusesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenStatusesPayload>
          }
          findMany: {
            args: Prisma.TokenStatusesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenStatusesPayload>[]
          }
          create: {
            args: Prisma.TokenStatusesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenStatusesPayload>
          }
          createMany: {
            args: Prisma.TokenStatusesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TokenStatusesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenStatusesPayload>
          }
          update: {
            args: Prisma.TokenStatusesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenStatusesPayload>
          }
          deleteMany: {
            args: Prisma.TokenStatusesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TokenStatusesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TokenStatusesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenStatusesPayload>
          }
          aggregate: {
            args: Prisma.TokenStatusesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTokenStatuses>
          }
          groupBy: {
            args: Prisma.TokenStatusesGroupByArgs<ExtArgs>
            result: $Utils.Optional<TokenStatusesGroupByOutputType>[]
          }
          count: {
            args: Prisma.TokenStatusesCountArgs<ExtArgs>
            result: $Utils.Optional<TokenStatusesCountAggregateOutputType> | number
          }
        }
      }
      VisaProvisionedTokens: {
        payload: Prisma.$VisaProvisionedTokensPayload<ExtArgs>
        fields: Prisma.VisaProvisionedTokensFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VisaProvisionedTokensFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisaProvisionedTokensPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VisaProvisionedTokensFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisaProvisionedTokensPayload>
          }
          findFirst: {
            args: Prisma.VisaProvisionedTokensFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisaProvisionedTokensPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VisaProvisionedTokensFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisaProvisionedTokensPayload>
          }
          findMany: {
            args: Prisma.VisaProvisionedTokensFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisaProvisionedTokensPayload>[]
          }
          create: {
            args: Prisma.VisaProvisionedTokensCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisaProvisionedTokensPayload>
          }
          createMany: {
            args: Prisma.VisaProvisionedTokensCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.VisaProvisionedTokensDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisaProvisionedTokensPayload>
          }
          update: {
            args: Prisma.VisaProvisionedTokensUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisaProvisionedTokensPayload>
          }
          deleteMany: {
            args: Prisma.VisaProvisionedTokensDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VisaProvisionedTokensUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VisaProvisionedTokensUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisaProvisionedTokensPayload>
          }
          aggregate: {
            args: Prisma.VisaProvisionedTokensAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVisaProvisionedTokens>
          }
          groupBy: {
            args: Prisma.VisaProvisionedTokensGroupByArgs<ExtArgs>
            result: $Utils.Optional<VisaProvisionedTokensGroupByOutputType>[]
          }
          count: {
            args: Prisma.VisaProvisionedTokensCountArgs<ExtArgs>
            result: $Utils.Optional<VisaProvisionedTokensCountAggregateOutputType> | number
          }
        }
      }
      VisaRequests: {
        payload: Prisma.$VisaRequestsPayload<ExtArgs>
        fields: Prisma.VisaRequestsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VisaRequestsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisaRequestsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VisaRequestsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisaRequestsPayload>
          }
          findFirst: {
            args: Prisma.VisaRequestsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisaRequestsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VisaRequestsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisaRequestsPayload>
          }
          findMany: {
            args: Prisma.VisaRequestsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisaRequestsPayload>[]
          }
          create: {
            args: Prisma.VisaRequestsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisaRequestsPayload>
          }
          createMany: {
            args: Prisma.VisaRequestsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.VisaRequestsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisaRequestsPayload>
          }
          update: {
            args: Prisma.VisaRequestsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisaRequestsPayload>
          }
          deleteMany: {
            args: Prisma.VisaRequestsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VisaRequestsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VisaRequestsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisaRequestsPayload>
          }
          aggregate: {
            args: Prisma.VisaRequestsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVisaRequests>
          }
          groupBy: {
            args: Prisma.VisaRequestsGroupByArgs<ExtArgs>
            result: $Utils.Optional<VisaRequestsGroupByOutputType>[]
          }
          count: {
            args: Prisma.VisaRequestsCountArgs<ExtArgs>
            result: $Utils.Optional<VisaRequestsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    eFMigrationsHistory?: EFMigrationsHistoryOmit
    accessLog?: AccessLogOmit
    appSurvey?: AppSurveyOmit
    aspNetRoleClaims?: AspNetRoleClaimsOmit
    aspNetRoles?: AspNetRolesOmit
    aspNetUserClaims?: AspNetUserClaimsOmit
    aspNetUserLogins?: AspNetUserLoginsOmit
    aspNetUserRoles?: AspNetUserRolesOmit
    aspNetUsers?: AspNetUsersOmit
    aspNetUserTokens?: AspNetUserTokensOmit
    cardReplacementRequests?: CardReplacementRequestsOmit
    detractorsFeedback?: DetractorsFeedbackOmit
    deviceAccessLog?: DeviceAccessLogOmit
    deviceCodes?: DeviceCodesOmit
    ewPayActivatedCards?: EwPayActivatedCardsOmit
    ewPayIneligibleCards?: EwPayIneligibleCardsOmit
    invalidDeviceAccess?: InvalidDeviceAccessOmit
    mastercardProvisionedTokens?: MastercardProvisionedTokensOmit
    persistedGrants?: PersistedGrantsOmit
    provisionedTokenIds?: ProvisionedTokenIdsOmit
    registerLogEntry?: RegisterLogEntryOmit
    sysdiagrams?: sysdiagramsOmit
    tapToPayTransactionLog?: TapToPayTransactionLogOmit
    tokenStatuses?: TokenStatusesOmit
    visaProvisionedTokens?: VisaProvisionedTokensOmit
    visaRequests?: VisaRequestsOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AspNetRolesCountOutputType
   */

  export type AspNetRolesCountOutputType = {
    AspNetRoleClaims: number
    AspNetUserRoles: number
  }

  export type AspNetRolesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AspNetRoleClaims?: boolean | AspNetRolesCountOutputTypeCountAspNetRoleClaimsArgs
    AspNetUserRoles?: boolean | AspNetRolesCountOutputTypeCountAspNetUserRolesArgs
  }

  // Custom InputTypes
  /**
   * AspNetRolesCountOutputType without action
   */
  export type AspNetRolesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetRolesCountOutputType
     */
    select?: AspNetRolesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AspNetRolesCountOutputType without action
   */
  export type AspNetRolesCountOutputTypeCountAspNetRoleClaimsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AspNetRoleClaimsWhereInput
  }

  /**
   * AspNetRolesCountOutputType without action
   */
  export type AspNetRolesCountOutputTypeCountAspNetUserRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AspNetUserRolesWhereInput
  }


  /**
   * Count Type AspNetUsersCountOutputType
   */

  export type AspNetUsersCountOutputType = {
    AspNetUserClaims: number
    AspNetUserLogins: number
    AspNetUserRoles: number
    AspNetUserTokens: number
  }

  export type AspNetUsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AspNetUserClaims?: boolean | AspNetUsersCountOutputTypeCountAspNetUserClaimsArgs
    AspNetUserLogins?: boolean | AspNetUsersCountOutputTypeCountAspNetUserLoginsArgs
    AspNetUserRoles?: boolean | AspNetUsersCountOutputTypeCountAspNetUserRolesArgs
    AspNetUserTokens?: boolean | AspNetUsersCountOutputTypeCountAspNetUserTokensArgs
  }

  // Custom InputTypes
  /**
   * AspNetUsersCountOutputType without action
   */
  export type AspNetUsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUsersCountOutputType
     */
    select?: AspNetUsersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AspNetUsersCountOutputType without action
   */
  export type AspNetUsersCountOutputTypeCountAspNetUserClaimsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AspNetUserClaimsWhereInput
  }

  /**
   * AspNetUsersCountOutputType without action
   */
  export type AspNetUsersCountOutputTypeCountAspNetUserLoginsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AspNetUserLoginsWhereInput
  }

  /**
   * AspNetUsersCountOutputType without action
   */
  export type AspNetUsersCountOutputTypeCountAspNetUserRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AspNetUserRolesWhereInput
  }

  /**
   * AspNetUsersCountOutputType without action
   */
  export type AspNetUsersCountOutputTypeCountAspNetUserTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AspNetUserTokensWhereInput
  }


  /**
   * Count Type TokenStatusesCountOutputType
   */

  export type TokenStatusesCountOutputType = {
    VisaProvisionedTokens: number
  }

  export type TokenStatusesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    VisaProvisionedTokens?: boolean | TokenStatusesCountOutputTypeCountVisaProvisionedTokensArgs
  }

  // Custom InputTypes
  /**
   * TokenStatusesCountOutputType without action
   */
  export type TokenStatusesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenStatusesCountOutputType
     */
    select?: TokenStatusesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TokenStatusesCountOutputType without action
   */
  export type TokenStatusesCountOutputTypeCountVisaProvisionedTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisaProvisionedTokensWhereInput
  }


  /**
   * Models
   */

  /**
   * Model EFMigrationsHistory
   */

  export type AggregateEFMigrationsHistory = {
    _count: EFMigrationsHistoryCountAggregateOutputType | null
    _min: EFMigrationsHistoryMinAggregateOutputType | null
    _max: EFMigrationsHistoryMaxAggregateOutputType | null
  }

  export type EFMigrationsHistoryMinAggregateOutputType = {
    MigrationId: string | null
    ProductVersion: string | null
  }

  export type EFMigrationsHistoryMaxAggregateOutputType = {
    MigrationId: string | null
    ProductVersion: string | null
  }

  export type EFMigrationsHistoryCountAggregateOutputType = {
    MigrationId: number
    ProductVersion: number
    _all: number
  }


  export type EFMigrationsHistoryMinAggregateInputType = {
    MigrationId?: true
    ProductVersion?: true
  }

  export type EFMigrationsHistoryMaxAggregateInputType = {
    MigrationId?: true
    ProductVersion?: true
  }

  export type EFMigrationsHistoryCountAggregateInputType = {
    MigrationId?: true
    ProductVersion?: true
    _all?: true
  }

  export type EFMigrationsHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EFMigrationsHistory to aggregate.
     */
    where?: EFMigrationsHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EFMigrationsHistories to fetch.
     */
    orderBy?: EFMigrationsHistoryOrderByWithRelationInput | EFMigrationsHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EFMigrationsHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EFMigrationsHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EFMigrationsHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EFMigrationsHistories
    **/
    _count?: true | EFMigrationsHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EFMigrationsHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EFMigrationsHistoryMaxAggregateInputType
  }

  export type GetEFMigrationsHistoryAggregateType<T extends EFMigrationsHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateEFMigrationsHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEFMigrationsHistory[P]>
      : GetScalarType<T[P], AggregateEFMigrationsHistory[P]>
  }




  export type EFMigrationsHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EFMigrationsHistoryWhereInput
    orderBy?: EFMigrationsHistoryOrderByWithAggregationInput | EFMigrationsHistoryOrderByWithAggregationInput[]
    by: EFMigrationsHistoryScalarFieldEnum[] | EFMigrationsHistoryScalarFieldEnum
    having?: EFMigrationsHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EFMigrationsHistoryCountAggregateInputType | true
    _min?: EFMigrationsHistoryMinAggregateInputType
    _max?: EFMigrationsHistoryMaxAggregateInputType
  }

  export type EFMigrationsHistoryGroupByOutputType = {
    MigrationId: string
    ProductVersion: string
    _count: EFMigrationsHistoryCountAggregateOutputType | null
    _min: EFMigrationsHistoryMinAggregateOutputType | null
    _max: EFMigrationsHistoryMaxAggregateOutputType | null
  }

  type GetEFMigrationsHistoryGroupByPayload<T extends EFMigrationsHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EFMigrationsHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EFMigrationsHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EFMigrationsHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], EFMigrationsHistoryGroupByOutputType[P]>
        }
      >
    >


  export type EFMigrationsHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    MigrationId?: boolean
    ProductVersion?: boolean
  }, ExtArgs["result"]["eFMigrationsHistory"]>



  export type EFMigrationsHistorySelectScalar = {
    MigrationId?: boolean
    ProductVersion?: boolean
  }

  export type EFMigrationsHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"MigrationId" | "ProductVersion", ExtArgs["result"]["eFMigrationsHistory"]>

  export type $EFMigrationsHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EFMigrationsHistory"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      MigrationId: string
      ProductVersion: string
    }, ExtArgs["result"]["eFMigrationsHistory"]>
    composites: {}
  }

  type EFMigrationsHistoryGetPayload<S extends boolean | null | undefined | EFMigrationsHistoryDefaultArgs> = $Result.GetResult<Prisma.$EFMigrationsHistoryPayload, S>

  type EFMigrationsHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EFMigrationsHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EFMigrationsHistoryCountAggregateInputType | true
    }

  export interface EFMigrationsHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EFMigrationsHistory'], meta: { name: 'EFMigrationsHistory' } }
    /**
     * Find zero or one EFMigrationsHistory that matches the filter.
     * @param {EFMigrationsHistoryFindUniqueArgs} args - Arguments to find a EFMigrationsHistory
     * @example
     * // Get one EFMigrationsHistory
     * const eFMigrationsHistory = await prisma.eFMigrationsHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EFMigrationsHistoryFindUniqueArgs>(args: SelectSubset<T, EFMigrationsHistoryFindUniqueArgs<ExtArgs>>): Prisma__EFMigrationsHistoryClient<$Result.GetResult<Prisma.$EFMigrationsHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EFMigrationsHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EFMigrationsHistoryFindUniqueOrThrowArgs} args - Arguments to find a EFMigrationsHistory
     * @example
     * // Get one EFMigrationsHistory
     * const eFMigrationsHistory = await prisma.eFMigrationsHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EFMigrationsHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, EFMigrationsHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EFMigrationsHistoryClient<$Result.GetResult<Prisma.$EFMigrationsHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EFMigrationsHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EFMigrationsHistoryFindFirstArgs} args - Arguments to find a EFMigrationsHistory
     * @example
     * // Get one EFMigrationsHistory
     * const eFMigrationsHistory = await prisma.eFMigrationsHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EFMigrationsHistoryFindFirstArgs>(args?: SelectSubset<T, EFMigrationsHistoryFindFirstArgs<ExtArgs>>): Prisma__EFMigrationsHistoryClient<$Result.GetResult<Prisma.$EFMigrationsHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EFMigrationsHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EFMigrationsHistoryFindFirstOrThrowArgs} args - Arguments to find a EFMigrationsHistory
     * @example
     * // Get one EFMigrationsHistory
     * const eFMigrationsHistory = await prisma.eFMigrationsHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EFMigrationsHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, EFMigrationsHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__EFMigrationsHistoryClient<$Result.GetResult<Prisma.$EFMigrationsHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EFMigrationsHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EFMigrationsHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EFMigrationsHistories
     * const eFMigrationsHistories = await prisma.eFMigrationsHistory.findMany()
     * 
     * // Get first 10 EFMigrationsHistories
     * const eFMigrationsHistories = await prisma.eFMigrationsHistory.findMany({ take: 10 })
     * 
     * // Only select the `MigrationId`
     * const eFMigrationsHistoryWithMigrationIdOnly = await prisma.eFMigrationsHistory.findMany({ select: { MigrationId: true } })
     * 
     */
    findMany<T extends EFMigrationsHistoryFindManyArgs>(args?: SelectSubset<T, EFMigrationsHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EFMigrationsHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EFMigrationsHistory.
     * @param {EFMigrationsHistoryCreateArgs} args - Arguments to create a EFMigrationsHistory.
     * @example
     * // Create one EFMigrationsHistory
     * const EFMigrationsHistory = await prisma.eFMigrationsHistory.create({
     *   data: {
     *     // ... data to create a EFMigrationsHistory
     *   }
     * })
     * 
     */
    create<T extends EFMigrationsHistoryCreateArgs>(args: SelectSubset<T, EFMigrationsHistoryCreateArgs<ExtArgs>>): Prisma__EFMigrationsHistoryClient<$Result.GetResult<Prisma.$EFMigrationsHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EFMigrationsHistories.
     * @param {EFMigrationsHistoryCreateManyArgs} args - Arguments to create many EFMigrationsHistories.
     * @example
     * // Create many EFMigrationsHistories
     * const eFMigrationsHistory = await prisma.eFMigrationsHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EFMigrationsHistoryCreateManyArgs>(args?: SelectSubset<T, EFMigrationsHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EFMigrationsHistory.
     * @param {EFMigrationsHistoryDeleteArgs} args - Arguments to delete one EFMigrationsHistory.
     * @example
     * // Delete one EFMigrationsHistory
     * const EFMigrationsHistory = await prisma.eFMigrationsHistory.delete({
     *   where: {
     *     // ... filter to delete one EFMigrationsHistory
     *   }
     * })
     * 
     */
    delete<T extends EFMigrationsHistoryDeleteArgs>(args: SelectSubset<T, EFMigrationsHistoryDeleteArgs<ExtArgs>>): Prisma__EFMigrationsHistoryClient<$Result.GetResult<Prisma.$EFMigrationsHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EFMigrationsHistory.
     * @param {EFMigrationsHistoryUpdateArgs} args - Arguments to update one EFMigrationsHistory.
     * @example
     * // Update one EFMigrationsHistory
     * const eFMigrationsHistory = await prisma.eFMigrationsHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EFMigrationsHistoryUpdateArgs>(args: SelectSubset<T, EFMigrationsHistoryUpdateArgs<ExtArgs>>): Prisma__EFMigrationsHistoryClient<$Result.GetResult<Prisma.$EFMigrationsHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EFMigrationsHistories.
     * @param {EFMigrationsHistoryDeleteManyArgs} args - Arguments to filter EFMigrationsHistories to delete.
     * @example
     * // Delete a few EFMigrationsHistories
     * const { count } = await prisma.eFMigrationsHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EFMigrationsHistoryDeleteManyArgs>(args?: SelectSubset<T, EFMigrationsHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EFMigrationsHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EFMigrationsHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EFMigrationsHistories
     * const eFMigrationsHistory = await prisma.eFMigrationsHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EFMigrationsHistoryUpdateManyArgs>(args: SelectSubset<T, EFMigrationsHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EFMigrationsHistory.
     * @param {EFMigrationsHistoryUpsertArgs} args - Arguments to update or create a EFMigrationsHistory.
     * @example
     * // Update or create a EFMigrationsHistory
     * const eFMigrationsHistory = await prisma.eFMigrationsHistory.upsert({
     *   create: {
     *     // ... data to create a EFMigrationsHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EFMigrationsHistory we want to update
     *   }
     * })
     */
    upsert<T extends EFMigrationsHistoryUpsertArgs>(args: SelectSubset<T, EFMigrationsHistoryUpsertArgs<ExtArgs>>): Prisma__EFMigrationsHistoryClient<$Result.GetResult<Prisma.$EFMigrationsHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EFMigrationsHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EFMigrationsHistoryCountArgs} args - Arguments to filter EFMigrationsHistories to count.
     * @example
     * // Count the number of EFMigrationsHistories
     * const count = await prisma.eFMigrationsHistory.count({
     *   where: {
     *     // ... the filter for the EFMigrationsHistories we want to count
     *   }
     * })
    **/
    count<T extends EFMigrationsHistoryCountArgs>(
      args?: Subset<T, EFMigrationsHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EFMigrationsHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EFMigrationsHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EFMigrationsHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EFMigrationsHistoryAggregateArgs>(args: Subset<T, EFMigrationsHistoryAggregateArgs>): Prisma.PrismaPromise<GetEFMigrationsHistoryAggregateType<T>>

    /**
     * Group by EFMigrationsHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EFMigrationsHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EFMigrationsHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EFMigrationsHistoryGroupByArgs['orderBy'] }
        : { orderBy?: EFMigrationsHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EFMigrationsHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEFMigrationsHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EFMigrationsHistory model
   */
  readonly fields: EFMigrationsHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EFMigrationsHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EFMigrationsHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EFMigrationsHistory model
   */
  interface EFMigrationsHistoryFieldRefs {
    readonly MigrationId: FieldRef<"EFMigrationsHistory", 'String'>
    readonly ProductVersion: FieldRef<"EFMigrationsHistory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EFMigrationsHistory findUnique
   */
  export type EFMigrationsHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EFMigrationsHistory
     */
    select?: EFMigrationsHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EFMigrationsHistory
     */
    omit?: EFMigrationsHistoryOmit<ExtArgs> | null
    /**
     * Filter, which EFMigrationsHistory to fetch.
     */
    where: EFMigrationsHistoryWhereUniqueInput
  }

  /**
   * EFMigrationsHistory findUniqueOrThrow
   */
  export type EFMigrationsHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EFMigrationsHistory
     */
    select?: EFMigrationsHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EFMigrationsHistory
     */
    omit?: EFMigrationsHistoryOmit<ExtArgs> | null
    /**
     * Filter, which EFMigrationsHistory to fetch.
     */
    where: EFMigrationsHistoryWhereUniqueInput
  }

  /**
   * EFMigrationsHistory findFirst
   */
  export type EFMigrationsHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EFMigrationsHistory
     */
    select?: EFMigrationsHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EFMigrationsHistory
     */
    omit?: EFMigrationsHistoryOmit<ExtArgs> | null
    /**
     * Filter, which EFMigrationsHistory to fetch.
     */
    where?: EFMigrationsHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EFMigrationsHistories to fetch.
     */
    orderBy?: EFMigrationsHistoryOrderByWithRelationInput | EFMigrationsHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EFMigrationsHistories.
     */
    cursor?: EFMigrationsHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EFMigrationsHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EFMigrationsHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EFMigrationsHistories.
     */
    distinct?: EFMigrationsHistoryScalarFieldEnum | EFMigrationsHistoryScalarFieldEnum[]
  }

  /**
   * EFMigrationsHistory findFirstOrThrow
   */
  export type EFMigrationsHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EFMigrationsHistory
     */
    select?: EFMigrationsHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EFMigrationsHistory
     */
    omit?: EFMigrationsHistoryOmit<ExtArgs> | null
    /**
     * Filter, which EFMigrationsHistory to fetch.
     */
    where?: EFMigrationsHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EFMigrationsHistories to fetch.
     */
    orderBy?: EFMigrationsHistoryOrderByWithRelationInput | EFMigrationsHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EFMigrationsHistories.
     */
    cursor?: EFMigrationsHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EFMigrationsHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EFMigrationsHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EFMigrationsHistories.
     */
    distinct?: EFMigrationsHistoryScalarFieldEnum | EFMigrationsHistoryScalarFieldEnum[]
  }

  /**
   * EFMigrationsHistory findMany
   */
  export type EFMigrationsHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EFMigrationsHistory
     */
    select?: EFMigrationsHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EFMigrationsHistory
     */
    omit?: EFMigrationsHistoryOmit<ExtArgs> | null
    /**
     * Filter, which EFMigrationsHistories to fetch.
     */
    where?: EFMigrationsHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EFMigrationsHistories to fetch.
     */
    orderBy?: EFMigrationsHistoryOrderByWithRelationInput | EFMigrationsHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EFMigrationsHistories.
     */
    cursor?: EFMigrationsHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EFMigrationsHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EFMigrationsHistories.
     */
    skip?: number
    distinct?: EFMigrationsHistoryScalarFieldEnum | EFMigrationsHistoryScalarFieldEnum[]
  }

  /**
   * EFMigrationsHistory create
   */
  export type EFMigrationsHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EFMigrationsHistory
     */
    select?: EFMigrationsHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EFMigrationsHistory
     */
    omit?: EFMigrationsHistoryOmit<ExtArgs> | null
    /**
     * The data needed to create a EFMigrationsHistory.
     */
    data: XOR<EFMigrationsHistoryCreateInput, EFMigrationsHistoryUncheckedCreateInput>
  }

  /**
   * EFMigrationsHistory createMany
   */
  export type EFMigrationsHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EFMigrationsHistories.
     */
    data: EFMigrationsHistoryCreateManyInput | EFMigrationsHistoryCreateManyInput[]
  }

  /**
   * EFMigrationsHistory update
   */
  export type EFMigrationsHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EFMigrationsHistory
     */
    select?: EFMigrationsHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EFMigrationsHistory
     */
    omit?: EFMigrationsHistoryOmit<ExtArgs> | null
    /**
     * The data needed to update a EFMigrationsHistory.
     */
    data: XOR<EFMigrationsHistoryUpdateInput, EFMigrationsHistoryUncheckedUpdateInput>
    /**
     * Choose, which EFMigrationsHistory to update.
     */
    where: EFMigrationsHistoryWhereUniqueInput
  }

  /**
   * EFMigrationsHistory updateMany
   */
  export type EFMigrationsHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EFMigrationsHistories.
     */
    data: XOR<EFMigrationsHistoryUpdateManyMutationInput, EFMigrationsHistoryUncheckedUpdateManyInput>
    /**
     * Filter which EFMigrationsHistories to update
     */
    where?: EFMigrationsHistoryWhereInput
    /**
     * Limit how many EFMigrationsHistories to update.
     */
    limit?: number
  }

  /**
   * EFMigrationsHistory upsert
   */
  export type EFMigrationsHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EFMigrationsHistory
     */
    select?: EFMigrationsHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EFMigrationsHistory
     */
    omit?: EFMigrationsHistoryOmit<ExtArgs> | null
    /**
     * The filter to search for the EFMigrationsHistory to update in case it exists.
     */
    where: EFMigrationsHistoryWhereUniqueInput
    /**
     * In case the EFMigrationsHistory found by the `where` argument doesn't exist, create a new EFMigrationsHistory with this data.
     */
    create: XOR<EFMigrationsHistoryCreateInput, EFMigrationsHistoryUncheckedCreateInput>
    /**
     * In case the EFMigrationsHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EFMigrationsHistoryUpdateInput, EFMigrationsHistoryUncheckedUpdateInput>
  }

  /**
   * EFMigrationsHistory delete
   */
  export type EFMigrationsHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EFMigrationsHistory
     */
    select?: EFMigrationsHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EFMigrationsHistory
     */
    omit?: EFMigrationsHistoryOmit<ExtArgs> | null
    /**
     * Filter which EFMigrationsHistory to delete.
     */
    where: EFMigrationsHistoryWhereUniqueInput
  }

  /**
   * EFMigrationsHistory deleteMany
   */
  export type EFMigrationsHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EFMigrationsHistories to delete
     */
    where?: EFMigrationsHistoryWhereInput
    /**
     * Limit how many EFMigrationsHistories to delete.
     */
    limit?: number
  }

  /**
   * EFMigrationsHistory without action
   */
  export type EFMigrationsHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EFMigrationsHistory
     */
    select?: EFMigrationsHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EFMigrationsHistory
     */
    omit?: EFMigrationsHistoryOmit<ExtArgs> | null
  }


  /**
   * Model AccessLog
   */

  export type AggregateAccessLog = {
    _count: AccessLogCountAggregateOutputType | null
    _avg: AccessLogAvgAggregateOutputType | null
    _sum: AccessLogSumAggregateOutputType | null
    _min: AccessLogMinAggregateOutputType | null
    _max: AccessLogMaxAggregateOutputType | null
  }

  export type AccessLogAvgAggregateOutputType = {
    Id: number | null
  }

  export type AccessLogSumAggregateOutputType = {
    Id: number | null
  }

  export type AccessLogMinAggregateOutputType = {
    Id: number | null
    CreatedDate: Date | null
    UpdatedDate: Date | null
    RequestUrl: string | null
    RequestMethod: string | null
    RequestHeaders: string | null
    RequestBody: string | null
    ResponseHeaders: string | null
    ResponseBody: string | null
    ResponseCode: string | null
    RequestIp: string | null
    RequestQuery: string | null
  }

  export type AccessLogMaxAggregateOutputType = {
    Id: number | null
    CreatedDate: Date | null
    UpdatedDate: Date | null
    RequestUrl: string | null
    RequestMethod: string | null
    RequestHeaders: string | null
    RequestBody: string | null
    ResponseHeaders: string | null
    ResponseBody: string | null
    ResponseCode: string | null
    RequestIp: string | null
    RequestQuery: string | null
  }

  export type AccessLogCountAggregateOutputType = {
    Id: number
    CreatedDate: number
    UpdatedDate: number
    RequestUrl: number
    RequestMethod: number
    RequestHeaders: number
    RequestBody: number
    ResponseHeaders: number
    ResponseBody: number
    ResponseCode: number
    RequestIp: number
    RequestQuery: number
    _all: number
  }


  export type AccessLogAvgAggregateInputType = {
    Id?: true
  }

  export type AccessLogSumAggregateInputType = {
    Id?: true
  }

  export type AccessLogMinAggregateInputType = {
    Id?: true
    CreatedDate?: true
    UpdatedDate?: true
    RequestUrl?: true
    RequestMethod?: true
    RequestHeaders?: true
    RequestBody?: true
    ResponseHeaders?: true
    ResponseBody?: true
    ResponseCode?: true
    RequestIp?: true
    RequestQuery?: true
  }

  export type AccessLogMaxAggregateInputType = {
    Id?: true
    CreatedDate?: true
    UpdatedDate?: true
    RequestUrl?: true
    RequestMethod?: true
    RequestHeaders?: true
    RequestBody?: true
    ResponseHeaders?: true
    ResponseBody?: true
    ResponseCode?: true
    RequestIp?: true
    RequestQuery?: true
  }

  export type AccessLogCountAggregateInputType = {
    Id?: true
    CreatedDate?: true
    UpdatedDate?: true
    RequestUrl?: true
    RequestMethod?: true
    RequestHeaders?: true
    RequestBody?: true
    ResponseHeaders?: true
    ResponseBody?: true
    ResponseCode?: true
    RequestIp?: true
    RequestQuery?: true
    _all?: true
  }

  export type AccessLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccessLog to aggregate.
     */
    where?: AccessLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccessLogs to fetch.
     */
    orderBy?: AccessLogOrderByWithRelationInput | AccessLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccessLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccessLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccessLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AccessLogs
    **/
    _count?: true | AccessLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccessLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccessLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccessLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccessLogMaxAggregateInputType
  }

  export type GetAccessLogAggregateType<T extends AccessLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAccessLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccessLog[P]>
      : GetScalarType<T[P], AggregateAccessLog[P]>
  }




  export type AccessLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccessLogWhereInput
    orderBy?: AccessLogOrderByWithAggregationInput | AccessLogOrderByWithAggregationInput[]
    by: AccessLogScalarFieldEnum[] | AccessLogScalarFieldEnum
    having?: AccessLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccessLogCountAggregateInputType | true
    _avg?: AccessLogAvgAggregateInputType
    _sum?: AccessLogSumAggregateInputType
    _min?: AccessLogMinAggregateInputType
    _max?: AccessLogMaxAggregateInputType
  }

  export type AccessLogGroupByOutputType = {
    Id: number
    CreatedDate: Date
    UpdatedDate: Date
    RequestUrl: string | null
    RequestMethod: string | null
    RequestHeaders: string | null
    RequestBody: string | null
    ResponseHeaders: string | null
    ResponseBody: string | null
    ResponseCode: string | null
    RequestIp: string | null
    RequestQuery: string | null
    _count: AccessLogCountAggregateOutputType | null
    _avg: AccessLogAvgAggregateOutputType | null
    _sum: AccessLogSumAggregateOutputType | null
    _min: AccessLogMinAggregateOutputType | null
    _max: AccessLogMaxAggregateOutputType | null
  }

  type GetAccessLogGroupByPayload<T extends AccessLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccessLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccessLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccessLogGroupByOutputType[P]>
            : GetScalarType<T[P], AccessLogGroupByOutputType[P]>
        }
      >
    >


  export type AccessLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    CreatedDate?: boolean
    UpdatedDate?: boolean
    RequestUrl?: boolean
    RequestMethod?: boolean
    RequestHeaders?: boolean
    RequestBody?: boolean
    ResponseHeaders?: boolean
    ResponseBody?: boolean
    ResponseCode?: boolean
    RequestIp?: boolean
    RequestQuery?: boolean
  }, ExtArgs["result"]["accessLog"]>



  export type AccessLogSelectScalar = {
    Id?: boolean
    CreatedDate?: boolean
    UpdatedDate?: boolean
    RequestUrl?: boolean
    RequestMethod?: boolean
    RequestHeaders?: boolean
    RequestBody?: boolean
    ResponseHeaders?: boolean
    ResponseBody?: boolean
    ResponseCode?: boolean
    RequestIp?: boolean
    RequestQuery?: boolean
  }

  export type AccessLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Id" | "CreatedDate" | "UpdatedDate" | "RequestUrl" | "RequestMethod" | "RequestHeaders" | "RequestBody" | "ResponseHeaders" | "ResponseBody" | "ResponseCode" | "RequestIp" | "RequestQuery", ExtArgs["result"]["accessLog"]>

  export type $AccessLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AccessLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      Id: number
      CreatedDate: Date
      UpdatedDate: Date
      RequestUrl: string | null
      RequestMethod: string | null
      RequestHeaders: string | null
      RequestBody: string | null
      ResponseHeaders: string | null
      ResponseBody: string | null
      ResponseCode: string | null
      RequestIp: string | null
      RequestQuery: string | null
    }, ExtArgs["result"]["accessLog"]>
    composites: {}
  }

  type AccessLogGetPayload<S extends boolean | null | undefined | AccessLogDefaultArgs> = $Result.GetResult<Prisma.$AccessLogPayload, S>

  type AccessLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccessLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccessLogCountAggregateInputType | true
    }

  export interface AccessLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AccessLog'], meta: { name: 'AccessLog' } }
    /**
     * Find zero or one AccessLog that matches the filter.
     * @param {AccessLogFindUniqueArgs} args - Arguments to find a AccessLog
     * @example
     * // Get one AccessLog
     * const accessLog = await prisma.accessLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccessLogFindUniqueArgs>(args: SelectSubset<T, AccessLogFindUniqueArgs<ExtArgs>>): Prisma__AccessLogClient<$Result.GetResult<Prisma.$AccessLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AccessLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccessLogFindUniqueOrThrowArgs} args - Arguments to find a AccessLog
     * @example
     * // Get one AccessLog
     * const accessLog = await prisma.accessLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccessLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AccessLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccessLogClient<$Result.GetResult<Prisma.$AccessLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AccessLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessLogFindFirstArgs} args - Arguments to find a AccessLog
     * @example
     * // Get one AccessLog
     * const accessLog = await prisma.accessLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccessLogFindFirstArgs>(args?: SelectSubset<T, AccessLogFindFirstArgs<ExtArgs>>): Prisma__AccessLogClient<$Result.GetResult<Prisma.$AccessLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AccessLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessLogFindFirstOrThrowArgs} args - Arguments to find a AccessLog
     * @example
     * // Get one AccessLog
     * const accessLog = await prisma.accessLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccessLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AccessLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccessLogClient<$Result.GetResult<Prisma.$AccessLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AccessLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AccessLogs
     * const accessLogs = await prisma.accessLog.findMany()
     * 
     * // Get first 10 AccessLogs
     * const accessLogs = await prisma.accessLog.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const accessLogWithIdOnly = await prisma.accessLog.findMany({ select: { Id: true } })
     * 
     */
    findMany<T extends AccessLogFindManyArgs>(args?: SelectSubset<T, AccessLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccessLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AccessLog.
     * @param {AccessLogCreateArgs} args - Arguments to create a AccessLog.
     * @example
     * // Create one AccessLog
     * const AccessLog = await prisma.accessLog.create({
     *   data: {
     *     // ... data to create a AccessLog
     *   }
     * })
     * 
     */
    create<T extends AccessLogCreateArgs>(args: SelectSubset<T, AccessLogCreateArgs<ExtArgs>>): Prisma__AccessLogClient<$Result.GetResult<Prisma.$AccessLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AccessLogs.
     * @param {AccessLogCreateManyArgs} args - Arguments to create many AccessLogs.
     * @example
     * // Create many AccessLogs
     * const accessLog = await prisma.accessLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccessLogCreateManyArgs>(args?: SelectSubset<T, AccessLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AccessLog.
     * @param {AccessLogDeleteArgs} args - Arguments to delete one AccessLog.
     * @example
     * // Delete one AccessLog
     * const AccessLog = await prisma.accessLog.delete({
     *   where: {
     *     // ... filter to delete one AccessLog
     *   }
     * })
     * 
     */
    delete<T extends AccessLogDeleteArgs>(args: SelectSubset<T, AccessLogDeleteArgs<ExtArgs>>): Prisma__AccessLogClient<$Result.GetResult<Prisma.$AccessLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AccessLog.
     * @param {AccessLogUpdateArgs} args - Arguments to update one AccessLog.
     * @example
     * // Update one AccessLog
     * const accessLog = await prisma.accessLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccessLogUpdateArgs>(args: SelectSubset<T, AccessLogUpdateArgs<ExtArgs>>): Prisma__AccessLogClient<$Result.GetResult<Prisma.$AccessLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AccessLogs.
     * @param {AccessLogDeleteManyArgs} args - Arguments to filter AccessLogs to delete.
     * @example
     * // Delete a few AccessLogs
     * const { count } = await prisma.accessLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccessLogDeleteManyArgs>(args?: SelectSubset<T, AccessLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AccessLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AccessLogs
     * const accessLog = await prisma.accessLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccessLogUpdateManyArgs>(args: SelectSubset<T, AccessLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AccessLog.
     * @param {AccessLogUpsertArgs} args - Arguments to update or create a AccessLog.
     * @example
     * // Update or create a AccessLog
     * const accessLog = await prisma.accessLog.upsert({
     *   create: {
     *     // ... data to create a AccessLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AccessLog we want to update
     *   }
     * })
     */
    upsert<T extends AccessLogUpsertArgs>(args: SelectSubset<T, AccessLogUpsertArgs<ExtArgs>>): Prisma__AccessLogClient<$Result.GetResult<Prisma.$AccessLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AccessLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessLogCountArgs} args - Arguments to filter AccessLogs to count.
     * @example
     * // Count the number of AccessLogs
     * const count = await prisma.accessLog.count({
     *   where: {
     *     // ... the filter for the AccessLogs we want to count
     *   }
     * })
    **/
    count<T extends AccessLogCountArgs>(
      args?: Subset<T, AccessLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccessLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AccessLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccessLogAggregateArgs>(args: Subset<T, AccessLogAggregateArgs>): Prisma.PrismaPromise<GetAccessLogAggregateType<T>>

    /**
     * Group by AccessLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccessLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccessLogGroupByArgs['orderBy'] }
        : { orderBy?: AccessLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccessLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccessLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AccessLog model
   */
  readonly fields: AccessLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AccessLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccessLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AccessLog model
   */
  interface AccessLogFieldRefs {
    readonly Id: FieldRef<"AccessLog", 'Int'>
    readonly CreatedDate: FieldRef<"AccessLog", 'DateTime'>
    readonly UpdatedDate: FieldRef<"AccessLog", 'DateTime'>
    readonly RequestUrl: FieldRef<"AccessLog", 'String'>
    readonly RequestMethod: FieldRef<"AccessLog", 'String'>
    readonly RequestHeaders: FieldRef<"AccessLog", 'String'>
    readonly RequestBody: FieldRef<"AccessLog", 'String'>
    readonly ResponseHeaders: FieldRef<"AccessLog", 'String'>
    readonly ResponseBody: FieldRef<"AccessLog", 'String'>
    readonly ResponseCode: FieldRef<"AccessLog", 'String'>
    readonly RequestIp: FieldRef<"AccessLog", 'String'>
    readonly RequestQuery: FieldRef<"AccessLog", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AccessLog findUnique
   */
  export type AccessLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessLog
     */
    select?: AccessLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessLog
     */
    omit?: AccessLogOmit<ExtArgs> | null
    /**
     * Filter, which AccessLog to fetch.
     */
    where: AccessLogWhereUniqueInput
  }

  /**
   * AccessLog findUniqueOrThrow
   */
  export type AccessLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessLog
     */
    select?: AccessLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessLog
     */
    omit?: AccessLogOmit<ExtArgs> | null
    /**
     * Filter, which AccessLog to fetch.
     */
    where: AccessLogWhereUniqueInput
  }

  /**
   * AccessLog findFirst
   */
  export type AccessLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessLog
     */
    select?: AccessLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessLog
     */
    omit?: AccessLogOmit<ExtArgs> | null
    /**
     * Filter, which AccessLog to fetch.
     */
    where?: AccessLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccessLogs to fetch.
     */
    orderBy?: AccessLogOrderByWithRelationInput | AccessLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccessLogs.
     */
    cursor?: AccessLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccessLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccessLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccessLogs.
     */
    distinct?: AccessLogScalarFieldEnum | AccessLogScalarFieldEnum[]
  }

  /**
   * AccessLog findFirstOrThrow
   */
  export type AccessLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessLog
     */
    select?: AccessLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessLog
     */
    omit?: AccessLogOmit<ExtArgs> | null
    /**
     * Filter, which AccessLog to fetch.
     */
    where?: AccessLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccessLogs to fetch.
     */
    orderBy?: AccessLogOrderByWithRelationInput | AccessLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccessLogs.
     */
    cursor?: AccessLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccessLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccessLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccessLogs.
     */
    distinct?: AccessLogScalarFieldEnum | AccessLogScalarFieldEnum[]
  }

  /**
   * AccessLog findMany
   */
  export type AccessLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessLog
     */
    select?: AccessLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessLog
     */
    omit?: AccessLogOmit<ExtArgs> | null
    /**
     * Filter, which AccessLogs to fetch.
     */
    where?: AccessLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccessLogs to fetch.
     */
    orderBy?: AccessLogOrderByWithRelationInput | AccessLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AccessLogs.
     */
    cursor?: AccessLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccessLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccessLogs.
     */
    skip?: number
    distinct?: AccessLogScalarFieldEnum | AccessLogScalarFieldEnum[]
  }

  /**
   * AccessLog create
   */
  export type AccessLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessLog
     */
    select?: AccessLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessLog
     */
    omit?: AccessLogOmit<ExtArgs> | null
    /**
     * The data needed to create a AccessLog.
     */
    data: XOR<AccessLogCreateInput, AccessLogUncheckedCreateInput>
  }

  /**
   * AccessLog createMany
   */
  export type AccessLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AccessLogs.
     */
    data: AccessLogCreateManyInput | AccessLogCreateManyInput[]
  }

  /**
   * AccessLog update
   */
  export type AccessLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessLog
     */
    select?: AccessLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessLog
     */
    omit?: AccessLogOmit<ExtArgs> | null
    /**
     * The data needed to update a AccessLog.
     */
    data: XOR<AccessLogUpdateInput, AccessLogUncheckedUpdateInput>
    /**
     * Choose, which AccessLog to update.
     */
    where: AccessLogWhereUniqueInput
  }

  /**
   * AccessLog updateMany
   */
  export type AccessLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AccessLogs.
     */
    data: XOR<AccessLogUpdateManyMutationInput, AccessLogUncheckedUpdateManyInput>
    /**
     * Filter which AccessLogs to update
     */
    where?: AccessLogWhereInput
    /**
     * Limit how many AccessLogs to update.
     */
    limit?: number
  }

  /**
   * AccessLog upsert
   */
  export type AccessLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessLog
     */
    select?: AccessLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessLog
     */
    omit?: AccessLogOmit<ExtArgs> | null
    /**
     * The filter to search for the AccessLog to update in case it exists.
     */
    where: AccessLogWhereUniqueInput
    /**
     * In case the AccessLog found by the `where` argument doesn't exist, create a new AccessLog with this data.
     */
    create: XOR<AccessLogCreateInput, AccessLogUncheckedCreateInput>
    /**
     * In case the AccessLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccessLogUpdateInput, AccessLogUncheckedUpdateInput>
  }

  /**
   * AccessLog delete
   */
  export type AccessLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessLog
     */
    select?: AccessLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessLog
     */
    omit?: AccessLogOmit<ExtArgs> | null
    /**
     * Filter which AccessLog to delete.
     */
    where: AccessLogWhereUniqueInput
  }

  /**
   * AccessLog deleteMany
   */
  export type AccessLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccessLogs to delete
     */
    where?: AccessLogWhereInput
    /**
     * Limit how many AccessLogs to delete.
     */
    limit?: number
  }

  /**
   * AccessLog without action
   */
  export type AccessLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessLog
     */
    select?: AccessLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessLog
     */
    omit?: AccessLogOmit<ExtArgs> | null
  }


  /**
   * Model AppSurvey
   */

  export type AggregateAppSurvey = {
    _count: AppSurveyCountAggregateOutputType | null
    _avg: AppSurveyAvgAggregateOutputType | null
    _sum: AppSurveySumAggregateOutputType | null
    _min: AppSurveyMinAggregateOutputType | null
    _max: AppSurveyMaxAggregateOutputType | null
  }

  export type AppSurveyAvgAggregateOutputType = {
    Id: number | null
    Rating: number | null
  }

  export type AppSurveySumAggregateOutputType = {
    Id: number | null
    Rating: number | null
  }

  export type AppSurveyMinAggregateOutputType = {
    Id: number | null
    Rating: number | null
    PhoneNumber: string | null
    AccomplishedDate: Date | null
  }

  export type AppSurveyMaxAggregateOutputType = {
    Id: number | null
    Rating: number | null
    PhoneNumber: string | null
    AccomplishedDate: Date | null
  }

  export type AppSurveyCountAggregateOutputType = {
    Id: number
    Rating: number
    PhoneNumber: number
    AccomplishedDate: number
    _all: number
  }


  export type AppSurveyAvgAggregateInputType = {
    Id?: true
    Rating?: true
  }

  export type AppSurveySumAggregateInputType = {
    Id?: true
    Rating?: true
  }

  export type AppSurveyMinAggregateInputType = {
    Id?: true
    Rating?: true
    PhoneNumber?: true
    AccomplishedDate?: true
  }

  export type AppSurveyMaxAggregateInputType = {
    Id?: true
    Rating?: true
    PhoneNumber?: true
    AccomplishedDate?: true
  }

  export type AppSurveyCountAggregateInputType = {
    Id?: true
    Rating?: true
    PhoneNumber?: true
    AccomplishedDate?: true
    _all?: true
  }

  export type AppSurveyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AppSurvey to aggregate.
     */
    where?: AppSurveyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppSurveys to fetch.
     */
    orderBy?: AppSurveyOrderByWithRelationInput | AppSurveyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AppSurveyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppSurveys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppSurveys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AppSurveys
    **/
    _count?: true | AppSurveyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AppSurveyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AppSurveySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AppSurveyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AppSurveyMaxAggregateInputType
  }

  export type GetAppSurveyAggregateType<T extends AppSurveyAggregateArgs> = {
        [P in keyof T & keyof AggregateAppSurvey]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAppSurvey[P]>
      : GetScalarType<T[P], AggregateAppSurvey[P]>
  }




  export type AppSurveyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppSurveyWhereInput
    orderBy?: AppSurveyOrderByWithAggregationInput | AppSurveyOrderByWithAggregationInput[]
    by: AppSurveyScalarFieldEnum[] | AppSurveyScalarFieldEnum
    having?: AppSurveyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AppSurveyCountAggregateInputType | true
    _avg?: AppSurveyAvgAggregateInputType
    _sum?: AppSurveySumAggregateInputType
    _min?: AppSurveyMinAggregateInputType
    _max?: AppSurveyMaxAggregateInputType
  }

  export type AppSurveyGroupByOutputType = {
    Id: number
    Rating: number
    PhoneNumber: string | null
    AccomplishedDate: Date
    _count: AppSurveyCountAggregateOutputType | null
    _avg: AppSurveyAvgAggregateOutputType | null
    _sum: AppSurveySumAggregateOutputType | null
    _min: AppSurveyMinAggregateOutputType | null
    _max: AppSurveyMaxAggregateOutputType | null
  }

  type GetAppSurveyGroupByPayload<T extends AppSurveyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AppSurveyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AppSurveyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AppSurveyGroupByOutputType[P]>
            : GetScalarType<T[P], AppSurveyGroupByOutputType[P]>
        }
      >
    >


  export type AppSurveySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    Rating?: boolean
    PhoneNumber?: boolean
    AccomplishedDate?: boolean
  }, ExtArgs["result"]["appSurvey"]>



  export type AppSurveySelectScalar = {
    Id?: boolean
    Rating?: boolean
    PhoneNumber?: boolean
    AccomplishedDate?: boolean
  }

  export type AppSurveyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Id" | "Rating" | "PhoneNumber" | "AccomplishedDate", ExtArgs["result"]["appSurvey"]>

  export type $AppSurveyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AppSurvey"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      Id: number
      Rating: number
      PhoneNumber: string | null
      AccomplishedDate: Date
    }, ExtArgs["result"]["appSurvey"]>
    composites: {}
  }

  type AppSurveyGetPayload<S extends boolean | null | undefined | AppSurveyDefaultArgs> = $Result.GetResult<Prisma.$AppSurveyPayload, S>

  type AppSurveyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AppSurveyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AppSurveyCountAggregateInputType | true
    }

  export interface AppSurveyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AppSurvey'], meta: { name: 'AppSurvey' } }
    /**
     * Find zero or one AppSurvey that matches the filter.
     * @param {AppSurveyFindUniqueArgs} args - Arguments to find a AppSurvey
     * @example
     * // Get one AppSurvey
     * const appSurvey = await prisma.appSurvey.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AppSurveyFindUniqueArgs>(args: SelectSubset<T, AppSurveyFindUniqueArgs<ExtArgs>>): Prisma__AppSurveyClient<$Result.GetResult<Prisma.$AppSurveyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AppSurvey that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AppSurveyFindUniqueOrThrowArgs} args - Arguments to find a AppSurvey
     * @example
     * // Get one AppSurvey
     * const appSurvey = await prisma.appSurvey.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AppSurveyFindUniqueOrThrowArgs>(args: SelectSubset<T, AppSurveyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AppSurveyClient<$Result.GetResult<Prisma.$AppSurveyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AppSurvey that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppSurveyFindFirstArgs} args - Arguments to find a AppSurvey
     * @example
     * // Get one AppSurvey
     * const appSurvey = await prisma.appSurvey.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AppSurveyFindFirstArgs>(args?: SelectSubset<T, AppSurveyFindFirstArgs<ExtArgs>>): Prisma__AppSurveyClient<$Result.GetResult<Prisma.$AppSurveyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AppSurvey that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppSurveyFindFirstOrThrowArgs} args - Arguments to find a AppSurvey
     * @example
     * // Get one AppSurvey
     * const appSurvey = await prisma.appSurvey.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AppSurveyFindFirstOrThrowArgs>(args?: SelectSubset<T, AppSurveyFindFirstOrThrowArgs<ExtArgs>>): Prisma__AppSurveyClient<$Result.GetResult<Prisma.$AppSurveyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AppSurveys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppSurveyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AppSurveys
     * const appSurveys = await prisma.appSurvey.findMany()
     * 
     * // Get first 10 AppSurveys
     * const appSurveys = await prisma.appSurvey.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const appSurveyWithIdOnly = await prisma.appSurvey.findMany({ select: { Id: true } })
     * 
     */
    findMany<T extends AppSurveyFindManyArgs>(args?: SelectSubset<T, AppSurveyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppSurveyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AppSurvey.
     * @param {AppSurveyCreateArgs} args - Arguments to create a AppSurvey.
     * @example
     * // Create one AppSurvey
     * const AppSurvey = await prisma.appSurvey.create({
     *   data: {
     *     // ... data to create a AppSurvey
     *   }
     * })
     * 
     */
    create<T extends AppSurveyCreateArgs>(args: SelectSubset<T, AppSurveyCreateArgs<ExtArgs>>): Prisma__AppSurveyClient<$Result.GetResult<Prisma.$AppSurveyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AppSurveys.
     * @param {AppSurveyCreateManyArgs} args - Arguments to create many AppSurveys.
     * @example
     * // Create many AppSurveys
     * const appSurvey = await prisma.appSurvey.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AppSurveyCreateManyArgs>(args?: SelectSubset<T, AppSurveyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AppSurvey.
     * @param {AppSurveyDeleteArgs} args - Arguments to delete one AppSurvey.
     * @example
     * // Delete one AppSurvey
     * const AppSurvey = await prisma.appSurvey.delete({
     *   where: {
     *     // ... filter to delete one AppSurvey
     *   }
     * })
     * 
     */
    delete<T extends AppSurveyDeleteArgs>(args: SelectSubset<T, AppSurveyDeleteArgs<ExtArgs>>): Prisma__AppSurveyClient<$Result.GetResult<Prisma.$AppSurveyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AppSurvey.
     * @param {AppSurveyUpdateArgs} args - Arguments to update one AppSurvey.
     * @example
     * // Update one AppSurvey
     * const appSurvey = await prisma.appSurvey.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AppSurveyUpdateArgs>(args: SelectSubset<T, AppSurveyUpdateArgs<ExtArgs>>): Prisma__AppSurveyClient<$Result.GetResult<Prisma.$AppSurveyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AppSurveys.
     * @param {AppSurveyDeleteManyArgs} args - Arguments to filter AppSurveys to delete.
     * @example
     * // Delete a few AppSurveys
     * const { count } = await prisma.appSurvey.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AppSurveyDeleteManyArgs>(args?: SelectSubset<T, AppSurveyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AppSurveys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppSurveyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AppSurveys
     * const appSurvey = await prisma.appSurvey.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AppSurveyUpdateManyArgs>(args: SelectSubset<T, AppSurveyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AppSurvey.
     * @param {AppSurveyUpsertArgs} args - Arguments to update or create a AppSurvey.
     * @example
     * // Update or create a AppSurvey
     * const appSurvey = await prisma.appSurvey.upsert({
     *   create: {
     *     // ... data to create a AppSurvey
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AppSurvey we want to update
     *   }
     * })
     */
    upsert<T extends AppSurveyUpsertArgs>(args: SelectSubset<T, AppSurveyUpsertArgs<ExtArgs>>): Prisma__AppSurveyClient<$Result.GetResult<Prisma.$AppSurveyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AppSurveys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppSurveyCountArgs} args - Arguments to filter AppSurveys to count.
     * @example
     * // Count the number of AppSurveys
     * const count = await prisma.appSurvey.count({
     *   where: {
     *     // ... the filter for the AppSurveys we want to count
     *   }
     * })
    **/
    count<T extends AppSurveyCountArgs>(
      args?: Subset<T, AppSurveyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AppSurveyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AppSurvey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppSurveyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AppSurveyAggregateArgs>(args: Subset<T, AppSurveyAggregateArgs>): Prisma.PrismaPromise<GetAppSurveyAggregateType<T>>

    /**
     * Group by AppSurvey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppSurveyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AppSurveyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AppSurveyGroupByArgs['orderBy'] }
        : { orderBy?: AppSurveyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AppSurveyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAppSurveyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AppSurvey model
   */
  readonly fields: AppSurveyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AppSurvey.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AppSurveyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AppSurvey model
   */
  interface AppSurveyFieldRefs {
    readonly Id: FieldRef<"AppSurvey", 'Int'>
    readonly Rating: FieldRef<"AppSurvey", 'Int'>
    readonly PhoneNumber: FieldRef<"AppSurvey", 'String'>
    readonly AccomplishedDate: FieldRef<"AppSurvey", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AppSurvey findUnique
   */
  export type AppSurveyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppSurvey
     */
    select?: AppSurveySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppSurvey
     */
    omit?: AppSurveyOmit<ExtArgs> | null
    /**
     * Filter, which AppSurvey to fetch.
     */
    where: AppSurveyWhereUniqueInput
  }

  /**
   * AppSurvey findUniqueOrThrow
   */
  export type AppSurveyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppSurvey
     */
    select?: AppSurveySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppSurvey
     */
    omit?: AppSurveyOmit<ExtArgs> | null
    /**
     * Filter, which AppSurvey to fetch.
     */
    where: AppSurveyWhereUniqueInput
  }

  /**
   * AppSurvey findFirst
   */
  export type AppSurveyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppSurvey
     */
    select?: AppSurveySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppSurvey
     */
    omit?: AppSurveyOmit<ExtArgs> | null
    /**
     * Filter, which AppSurvey to fetch.
     */
    where?: AppSurveyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppSurveys to fetch.
     */
    orderBy?: AppSurveyOrderByWithRelationInput | AppSurveyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AppSurveys.
     */
    cursor?: AppSurveyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppSurveys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppSurveys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AppSurveys.
     */
    distinct?: AppSurveyScalarFieldEnum | AppSurveyScalarFieldEnum[]
  }

  /**
   * AppSurvey findFirstOrThrow
   */
  export type AppSurveyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppSurvey
     */
    select?: AppSurveySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppSurvey
     */
    omit?: AppSurveyOmit<ExtArgs> | null
    /**
     * Filter, which AppSurvey to fetch.
     */
    where?: AppSurveyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppSurveys to fetch.
     */
    orderBy?: AppSurveyOrderByWithRelationInput | AppSurveyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AppSurveys.
     */
    cursor?: AppSurveyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppSurveys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppSurveys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AppSurveys.
     */
    distinct?: AppSurveyScalarFieldEnum | AppSurveyScalarFieldEnum[]
  }

  /**
   * AppSurvey findMany
   */
  export type AppSurveyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppSurvey
     */
    select?: AppSurveySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppSurvey
     */
    omit?: AppSurveyOmit<ExtArgs> | null
    /**
     * Filter, which AppSurveys to fetch.
     */
    where?: AppSurveyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppSurveys to fetch.
     */
    orderBy?: AppSurveyOrderByWithRelationInput | AppSurveyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AppSurveys.
     */
    cursor?: AppSurveyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppSurveys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppSurveys.
     */
    skip?: number
    distinct?: AppSurveyScalarFieldEnum | AppSurveyScalarFieldEnum[]
  }

  /**
   * AppSurvey create
   */
  export type AppSurveyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppSurvey
     */
    select?: AppSurveySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppSurvey
     */
    omit?: AppSurveyOmit<ExtArgs> | null
    /**
     * The data needed to create a AppSurvey.
     */
    data: XOR<AppSurveyCreateInput, AppSurveyUncheckedCreateInput>
  }

  /**
   * AppSurvey createMany
   */
  export type AppSurveyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AppSurveys.
     */
    data: AppSurveyCreateManyInput | AppSurveyCreateManyInput[]
  }

  /**
   * AppSurvey update
   */
  export type AppSurveyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppSurvey
     */
    select?: AppSurveySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppSurvey
     */
    omit?: AppSurveyOmit<ExtArgs> | null
    /**
     * The data needed to update a AppSurvey.
     */
    data: XOR<AppSurveyUpdateInput, AppSurveyUncheckedUpdateInput>
    /**
     * Choose, which AppSurvey to update.
     */
    where: AppSurveyWhereUniqueInput
  }

  /**
   * AppSurvey updateMany
   */
  export type AppSurveyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AppSurveys.
     */
    data: XOR<AppSurveyUpdateManyMutationInput, AppSurveyUncheckedUpdateManyInput>
    /**
     * Filter which AppSurveys to update
     */
    where?: AppSurveyWhereInput
    /**
     * Limit how many AppSurveys to update.
     */
    limit?: number
  }

  /**
   * AppSurvey upsert
   */
  export type AppSurveyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppSurvey
     */
    select?: AppSurveySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppSurvey
     */
    omit?: AppSurveyOmit<ExtArgs> | null
    /**
     * The filter to search for the AppSurvey to update in case it exists.
     */
    where: AppSurveyWhereUniqueInput
    /**
     * In case the AppSurvey found by the `where` argument doesn't exist, create a new AppSurvey with this data.
     */
    create: XOR<AppSurveyCreateInput, AppSurveyUncheckedCreateInput>
    /**
     * In case the AppSurvey was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AppSurveyUpdateInput, AppSurveyUncheckedUpdateInput>
  }

  /**
   * AppSurvey delete
   */
  export type AppSurveyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppSurvey
     */
    select?: AppSurveySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppSurvey
     */
    omit?: AppSurveyOmit<ExtArgs> | null
    /**
     * Filter which AppSurvey to delete.
     */
    where: AppSurveyWhereUniqueInput
  }

  /**
   * AppSurvey deleteMany
   */
  export type AppSurveyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AppSurveys to delete
     */
    where?: AppSurveyWhereInput
    /**
     * Limit how many AppSurveys to delete.
     */
    limit?: number
  }

  /**
   * AppSurvey without action
   */
  export type AppSurveyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppSurvey
     */
    select?: AppSurveySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppSurvey
     */
    omit?: AppSurveyOmit<ExtArgs> | null
  }


  /**
   * Model AspNetRoleClaims
   */

  export type AggregateAspNetRoleClaims = {
    _count: AspNetRoleClaimsCountAggregateOutputType | null
    _avg: AspNetRoleClaimsAvgAggregateOutputType | null
    _sum: AspNetRoleClaimsSumAggregateOutputType | null
    _min: AspNetRoleClaimsMinAggregateOutputType | null
    _max: AspNetRoleClaimsMaxAggregateOutputType | null
  }

  export type AspNetRoleClaimsAvgAggregateOutputType = {
    Id: number | null
  }

  export type AspNetRoleClaimsSumAggregateOutputType = {
    Id: number | null
  }

  export type AspNetRoleClaimsMinAggregateOutputType = {
    Id: number | null
    RoleId: string | null
    ClaimType: string | null
    ClaimValue: string | null
  }

  export type AspNetRoleClaimsMaxAggregateOutputType = {
    Id: number | null
    RoleId: string | null
    ClaimType: string | null
    ClaimValue: string | null
  }

  export type AspNetRoleClaimsCountAggregateOutputType = {
    Id: number
    RoleId: number
    ClaimType: number
    ClaimValue: number
    _all: number
  }


  export type AspNetRoleClaimsAvgAggregateInputType = {
    Id?: true
  }

  export type AspNetRoleClaimsSumAggregateInputType = {
    Id?: true
  }

  export type AspNetRoleClaimsMinAggregateInputType = {
    Id?: true
    RoleId?: true
    ClaimType?: true
    ClaimValue?: true
  }

  export type AspNetRoleClaimsMaxAggregateInputType = {
    Id?: true
    RoleId?: true
    ClaimType?: true
    ClaimValue?: true
  }

  export type AspNetRoleClaimsCountAggregateInputType = {
    Id?: true
    RoleId?: true
    ClaimType?: true
    ClaimValue?: true
    _all?: true
  }

  export type AspNetRoleClaimsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AspNetRoleClaims to aggregate.
     */
    where?: AspNetRoleClaimsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AspNetRoleClaims to fetch.
     */
    orderBy?: AspNetRoleClaimsOrderByWithRelationInput | AspNetRoleClaimsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AspNetRoleClaimsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AspNetRoleClaims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AspNetRoleClaims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AspNetRoleClaims
    **/
    _count?: true | AspNetRoleClaimsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AspNetRoleClaimsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AspNetRoleClaimsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AspNetRoleClaimsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AspNetRoleClaimsMaxAggregateInputType
  }

  export type GetAspNetRoleClaimsAggregateType<T extends AspNetRoleClaimsAggregateArgs> = {
        [P in keyof T & keyof AggregateAspNetRoleClaims]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAspNetRoleClaims[P]>
      : GetScalarType<T[P], AggregateAspNetRoleClaims[P]>
  }




  export type AspNetRoleClaimsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AspNetRoleClaimsWhereInput
    orderBy?: AspNetRoleClaimsOrderByWithAggregationInput | AspNetRoleClaimsOrderByWithAggregationInput[]
    by: AspNetRoleClaimsScalarFieldEnum[] | AspNetRoleClaimsScalarFieldEnum
    having?: AspNetRoleClaimsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AspNetRoleClaimsCountAggregateInputType | true
    _avg?: AspNetRoleClaimsAvgAggregateInputType
    _sum?: AspNetRoleClaimsSumAggregateInputType
    _min?: AspNetRoleClaimsMinAggregateInputType
    _max?: AspNetRoleClaimsMaxAggregateInputType
  }

  export type AspNetRoleClaimsGroupByOutputType = {
    Id: number
    RoleId: string
    ClaimType: string | null
    ClaimValue: string | null
    _count: AspNetRoleClaimsCountAggregateOutputType | null
    _avg: AspNetRoleClaimsAvgAggregateOutputType | null
    _sum: AspNetRoleClaimsSumAggregateOutputType | null
    _min: AspNetRoleClaimsMinAggregateOutputType | null
    _max: AspNetRoleClaimsMaxAggregateOutputType | null
  }

  type GetAspNetRoleClaimsGroupByPayload<T extends AspNetRoleClaimsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AspNetRoleClaimsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AspNetRoleClaimsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AspNetRoleClaimsGroupByOutputType[P]>
            : GetScalarType<T[P], AspNetRoleClaimsGroupByOutputType[P]>
        }
      >
    >


  export type AspNetRoleClaimsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    RoleId?: boolean
    ClaimType?: boolean
    ClaimValue?: boolean
    AspNetRoles?: boolean | AspNetRolesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aspNetRoleClaims"]>



  export type AspNetRoleClaimsSelectScalar = {
    Id?: boolean
    RoleId?: boolean
    ClaimType?: boolean
    ClaimValue?: boolean
  }

  export type AspNetRoleClaimsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Id" | "RoleId" | "ClaimType" | "ClaimValue", ExtArgs["result"]["aspNetRoleClaims"]>
  export type AspNetRoleClaimsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AspNetRoles?: boolean | AspNetRolesDefaultArgs<ExtArgs>
  }

  export type $AspNetRoleClaimsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AspNetRoleClaims"
    objects: {
      AspNetRoles: Prisma.$AspNetRolesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      Id: number
      RoleId: string
      ClaimType: string | null
      ClaimValue: string | null
    }, ExtArgs["result"]["aspNetRoleClaims"]>
    composites: {}
  }

  type AspNetRoleClaimsGetPayload<S extends boolean | null | undefined | AspNetRoleClaimsDefaultArgs> = $Result.GetResult<Prisma.$AspNetRoleClaimsPayload, S>

  type AspNetRoleClaimsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AspNetRoleClaimsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AspNetRoleClaimsCountAggregateInputType | true
    }

  export interface AspNetRoleClaimsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AspNetRoleClaims'], meta: { name: 'AspNetRoleClaims' } }
    /**
     * Find zero or one AspNetRoleClaims that matches the filter.
     * @param {AspNetRoleClaimsFindUniqueArgs} args - Arguments to find a AspNetRoleClaims
     * @example
     * // Get one AspNetRoleClaims
     * const aspNetRoleClaims = await prisma.aspNetRoleClaims.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AspNetRoleClaimsFindUniqueArgs>(args: SelectSubset<T, AspNetRoleClaimsFindUniqueArgs<ExtArgs>>): Prisma__AspNetRoleClaimsClient<$Result.GetResult<Prisma.$AspNetRoleClaimsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AspNetRoleClaims that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AspNetRoleClaimsFindUniqueOrThrowArgs} args - Arguments to find a AspNetRoleClaims
     * @example
     * // Get one AspNetRoleClaims
     * const aspNetRoleClaims = await prisma.aspNetRoleClaims.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AspNetRoleClaimsFindUniqueOrThrowArgs>(args: SelectSubset<T, AspNetRoleClaimsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AspNetRoleClaimsClient<$Result.GetResult<Prisma.$AspNetRoleClaimsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AspNetRoleClaims that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetRoleClaimsFindFirstArgs} args - Arguments to find a AspNetRoleClaims
     * @example
     * // Get one AspNetRoleClaims
     * const aspNetRoleClaims = await prisma.aspNetRoleClaims.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AspNetRoleClaimsFindFirstArgs>(args?: SelectSubset<T, AspNetRoleClaimsFindFirstArgs<ExtArgs>>): Prisma__AspNetRoleClaimsClient<$Result.GetResult<Prisma.$AspNetRoleClaimsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AspNetRoleClaims that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetRoleClaimsFindFirstOrThrowArgs} args - Arguments to find a AspNetRoleClaims
     * @example
     * // Get one AspNetRoleClaims
     * const aspNetRoleClaims = await prisma.aspNetRoleClaims.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AspNetRoleClaimsFindFirstOrThrowArgs>(args?: SelectSubset<T, AspNetRoleClaimsFindFirstOrThrowArgs<ExtArgs>>): Prisma__AspNetRoleClaimsClient<$Result.GetResult<Prisma.$AspNetRoleClaimsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AspNetRoleClaims that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetRoleClaimsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AspNetRoleClaims
     * const aspNetRoleClaims = await prisma.aspNetRoleClaims.findMany()
     * 
     * // Get first 10 AspNetRoleClaims
     * const aspNetRoleClaims = await prisma.aspNetRoleClaims.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const aspNetRoleClaimsWithIdOnly = await prisma.aspNetRoleClaims.findMany({ select: { Id: true } })
     * 
     */
    findMany<T extends AspNetRoleClaimsFindManyArgs>(args?: SelectSubset<T, AspNetRoleClaimsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AspNetRoleClaimsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AspNetRoleClaims.
     * @param {AspNetRoleClaimsCreateArgs} args - Arguments to create a AspNetRoleClaims.
     * @example
     * // Create one AspNetRoleClaims
     * const AspNetRoleClaims = await prisma.aspNetRoleClaims.create({
     *   data: {
     *     // ... data to create a AspNetRoleClaims
     *   }
     * })
     * 
     */
    create<T extends AspNetRoleClaimsCreateArgs>(args: SelectSubset<T, AspNetRoleClaimsCreateArgs<ExtArgs>>): Prisma__AspNetRoleClaimsClient<$Result.GetResult<Prisma.$AspNetRoleClaimsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AspNetRoleClaims.
     * @param {AspNetRoleClaimsCreateManyArgs} args - Arguments to create many AspNetRoleClaims.
     * @example
     * // Create many AspNetRoleClaims
     * const aspNetRoleClaims = await prisma.aspNetRoleClaims.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AspNetRoleClaimsCreateManyArgs>(args?: SelectSubset<T, AspNetRoleClaimsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AspNetRoleClaims.
     * @param {AspNetRoleClaimsDeleteArgs} args - Arguments to delete one AspNetRoleClaims.
     * @example
     * // Delete one AspNetRoleClaims
     * const AspNetRoleClaims = await prisma.aspNetRoleClaims.delete({
     *   where: {
     *     // ... filter to delete one AspNetRoleClaims
     *   }
     * })
     * 
     */
    delete<T extends AspNetRoleClaimsDeleteArgs>(args: SelectSubset<T, AspNetRoleClaimsDeleteArgs<ExtArgs>>): Prisma__AspNetRoleClaimsClient<$Result.GetResult<Prisma.$AspNetRoleClaimsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AspNetRoleClaims.
     * @param {AspNetRoleClaimsUpdateArgs} args - Arguments to update one AspNetRoleClaims.
     * @example
     * // Update one AspNetRoleClaims
     * const aspNetRoleClaims = await prisma.aspNetRoleClaims.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AspNetRoleClaimsUpdateArgs>(args: SelectSubset<T, AspNetRoleClaimsUpdateArgs<ExtArgs>>): Prisma__AspNetRoleClaimsClient<$Result.GetResult<Prisma.$AspNetRoleClaimsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AspNetRoleClaims.
     * @param {AspNetRoleClaimsDeleteManyArgs} args - Arguments to filter AspNetRoleClaims to delete.
     * @example
     * // Delete a few AspNetRoleClaims
     * const { count } = await prisma.aspNetRoleClaims.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AspNetRoleClaimsDeleteManyArgs>(args?: SelectSubset<T, AspNetRoleClaimsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AspNetRoleClaims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetRoleClaimsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AspNetRoleClaims
     * const aspNetRoleClaims = await prisma.aspNetRoleClaims.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AspNetRoleClaimsUpdateManyArgs>(args: SelectSubset<T, AspNetRoleClaimsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AspNetRoleClaims.
     * @param {AspNetRoleClaimsUpsertArgs} args - Arguments to update or create a AspNetRoleClaims.
     * @example
     * // Update or create a AspNetRoleClaims
     * const aspNetRoleClaims = await prisma.aspNetRoleClaims.upsert({
     *   create: {
     *     // ... data to create a AspNetRoleClaims
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AspNetRoleClaims we want to update
     *   }
     * })
     */
    upsert<T extends AspNetRoleClaimsUpsertArgs>(args: SelectSubset<T, AspNetRoleClaimsUpsertArgs<ExtArgs>>): Prisma__AspNetRoleClaimsClient<$Result.GetResult<Prisma.$AspNetRoleClaimsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AspNetRoleClaims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetRoleClaimsCountArgs} args - Arguments to filter AspNetRoleClaims to count.
     * @example
     * // Count the number of AspNetRoleClaims
     * const count = await prisma.aspNetRoleClaims.count({
     *   where: {
     *     // ... the filter for the AspNetRoleClaims we want to count
     *   }
     * })
    **/
    count<T extends AspNetRoleClaimsCountArgs>(
      args?: Subset<T, AspNetRoleClaimsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AspNetRoleClaimsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AspNetRoleClaims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetRoleClaimsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AspNetRoleClaimsAggregateArgs>(args: Subset<T, AspNetRoleClaimsAggregateArgs>): Prisma.PrismaPromise<GetAspNetRoleClaimsAggregateType<T>>

    /**
     * Group by AspNetRoleClaims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetRoleClaimsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AspNetRoleClaimsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AspNetRoleClaimsGroupByArgs['orderBy'] }
        : { orderBy?: AspNetRoleClaimsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AspNetRoleClaimsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAspNetRoleClaimsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AspNetRoleClaims model
   */
  readonly fields: AspNetRoleClaimsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AspNetRoleClaims.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AspNetRoleClaimsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    AspNetRoles<T extends AspNetRolesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AspNetRolesDefaultArgs<ExtArgs>>): Prisma__AspNetRolesClient<$Result.GetResult<Prisma.$AspNetRolesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AspNetRoleClaims model
   */
  interface AspNetRoleClaimsFieldRefs {
    readonly Id: FieldRef<"AspNetRoleClaims", 'Int'>
    readonly RoleId: FieldRef<"AspNetRoleClaims", 'String'>
    readonly ClaimType: FieldRef<"AspNetRoleClaims", 'String'>
    readonly ClaimValue: FieldRef<"AspNetRoleClaims", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AspNetRoleClaims findUnique
   */
  export type AspNetRoleClaimsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetRoleClaims
     */
    select?: AspNetRoleClaimsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspNetRoleClaims
     */
    omit?: AspNetRoleClaimsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetRoleClaimsInclude<ExtArgs> | null
    /**
     * Filter, which AspNetRoleClaims to fetch.
     */
    where: AspNetRoleClaimsWhereUniqueInput
  }

  /**
   * AspNetRoleClaims findUniqueOrThrow
   */
  export type AspNetRoleClaimsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetRoleClaims
     */
    select?: AspNetRoleClaimsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspNetRoleClaims
     */
    omit?: AspNetRoleClaimsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetRoleClaimsInclude<ExtArgs> | null
    /**
     * Filter, which AspNetRoleClaims to fetch.
     */
    where: AspNetRoleClaimsWhereUniqueInput
  }

  /**
   * AspNetRoleClaims findFirst
   */
  export type AspNetRoleClaimsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetRoleClaims
     */
    select?: AspNetRoleClaimsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspNetRoleClaims
     */
    omit?: AspNetRoleClaimsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetRoleClaimsInclude<ExtArgs> | null
    /**
     * Filter, which AspNetRoleClaims to fetch.
     */
    where?: AspNetRoleClaimsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AspNetRoleClaims to fetch.
     */
    orderBy?: AspNetRoleClaimsOrderByWithRelationInput | AspNetRoleClaimsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AspNetRoleClaims.
     */
    cursor?: AspNetRoleClaimsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AspNetRoleClaims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AspNetRoleClaims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AspNetRoleClaims.
     */
    distinct?: AspNetRoleClaimsScalarFieldEnum | AspNetRoleClaimsScalarFieldEnum[]
  }

  /**
   * AspNetRoleClaims findFirstOrThrow
   */
  export type AspNetRoleClaimsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetRoleClaims
     */
    select?: AspNetRoleClaimsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspNetRoleClaims
     */
    omit?: AspNetRoleClaimsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetRoleClaimsInclude<ExtArgs> | null
    /**
     * Filter, which AspNetRoleClaims to fetch.
     */
    where?: AspNetRoleClaimsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AspNetRoleClaims to fetch.
     */
    orderBy?: AspNetRoleClaimsOrderByWithRelationInput | AspNetRoleClaimsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AspNetRoleClaims.
     */
    cursor?: AspNetRoleClaimsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AspNetRoleClaims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AspNetRoleClaims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AspNetRoleClaims.
     */
    distinct?: AspNetRoleClaimsScalarFieldEnum | AspNetRoleClaimsScalarFieldEnum[]
  }

  /**
   * AspNetRoleClaims findMany
   */
  export type AspNetRoleClaimsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetRoleClaims
     */
    select?: AspNetRoleClaimsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspNetRoleClaims
     */
    omit?: AspNetRoleClaimsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetRoleClaimsInclude<ExtArgs> | null
    /**
     * Filter, which AspNetRoleClaims to fetch.
     */
    where?: AspNetRoleClaimsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AspNetRoleClaims to fetch.
     */
    orderBy?: AspNetRoleClaimsOrderByWithRelationInput | AspNetRoleClaimsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AspNetRoleClaims.
     */
    cursor?: AspNetRoleClaimsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AspNetRoleClaims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AspNetRoleClaims.
     */
    skip?: number
    distinct?: AspNetRoleClaimsScalarFieldEnum | AspNetRoleClaimsScalarFieldEnum[]
  }

  /**
   * AspNetRoleClaims create
   */
  export type AspNetRoleClaimsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetRoleClaims
     */
    select?: AspNetRoleClaimsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspNetRoleClaims
     */
    omit?: AspNetRoleClaimsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetRoleClaimsInclude<ExtArgs> | null
    /**
     * The data needed to create a AspNetRoleClaims.
     */
    data: XOR<AspNetRoleClaimsCreateInput, AspNetRoleClaimsUncheckedCreateInput>
  }

  /**
   * AspNetRoleClaims createMany
   */
  export type AspNetRoleClaimsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AspNetRoleClaims.
     */
    data: AspNetRoleClaimsCreateManyInput | AspNetRoleClaimsCreateManyInput[]
  }

  /**
   * AspNetRoleClaims update
   */
  export type AspNetRoleClaimsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetRoleClaims
     */
    select?: AspNetRoleClaimsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspNetRoleClaims
     */
    omit?: AspNetRoleClaimsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetRoleClaimsInclude<ExtArgs> | null
    /**
     * The data needed to update a AspNetRoleClaims.
     */
    data: XOR<AspNetRoleClaimsUpdateInput, AspNetRoleClaimsUncheckedUpdateInput>
    /**
     * Choose, which AspNetRoleClaims to update.
     */
    where: AspNetRoleClaimsWhereUniqueInput
  }

  /**
   * AspNetRoleClaims updateMany
   */
  export type AspNetRoleClaimsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AspNetRoleClaims.
     */
    data: XOR<AspNetRoleClaimsUpdateManyMutationInput, AspNetRoleClaimsUncheckedUpdateManyInput>
    /**
     * Filter which AspNetRoleClaims to update
     */
    where?: AspNetRoleClaimsWhereInput
    /**
     * Limit how many AspNetRoleClaims to update.
     */
    limit?: number
  }

  /**
   * AspNetRoleClaims upsert
   */
  export type AspNetRoleClaimsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetRoleClaims
     */
    select?: AspNetRoleClaimsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspNetRoleClaims
     */
    omit?: AspNetRoleClaimsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetRoleClaimsInclude<ExtArgs> | null
    /**
     * The filter to search for the AspNetRoleClaims to update in case it exists.
     */
    where: AspNetRoleClaimsWhereUniqueInput
    /**
     * In case the AspNetRoleClaims found by the `where` argument doesn't exist, create a new AspNetRoleClaims with this data.
     */
    create: XOR<AspNetRoleClaimsCreateInput, AspNetRoleClaimsUncheckedCreateInput>
    /**
     * In case the AspNetRoleClaims was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AspNetRoleClaimsUpdateInput, AspNetRoleClaimsUncheckedUpdateInput>
  }

  /**
   * AspNetRoleClaims delete
   */
  export type AspNetRoleClaimsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetRoleClaims
     */
    select?: AspNetRoleClaimsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspNetRoleClaims
     */
    omit?: AspNetRoleClaimsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetRoleClaimsInclude<ExtArgs> | null
    /**
     * Filter which AspNetRoleClaims to delete.
     */
    where: AspNetRoleClaimsWhereUniqueInput
  }

  /**
   * AspNetRoleClaims deleteMany
   */
  export type AspNetRoleClaimsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AspNetRoleClaims to delete
     */
    where?: AspNetRoleClaimsWhereInput
    /**
     * Limit how many AspNetRoleClaims to delete.
     */
    limit?: number
  }

  /**
   * AspNetRoleClaims without action
   */
  export type AspNetRoleClaimsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetRoleClaims
     */
    select?: AspNetRoleClaimsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspNetRoleClaims
     */
    omit?: AspNetRoleClaimsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetRoleClaimsInclude<ExtArgs> | null
  }


  /**
   * Model AspNetRoles
   */

  export type AggregateAspNetRoles = {
    _count: AspNetRolesCountAggregateOutputType | null
    _min: AspNetRolesMinAggregateOutputType | null
    _max: AspNetRolesMaxAggregateOutputType | null
  }

  export type AspNetRolesMinAggregateOutputType = {
    Id: string | null
    Name: string | null
    NormalizedName: string | null
    ConcurrencyStamp: string | null
  }

  export type AspNetRolesMaxAggregateOutputType = {
    Id: string | null
    Name: string | null
    NormalizedName: string | null
    ConcurrencyStamp: string | null
  }

  export type AspNetRolesCountAggregateOutputType = {
    Id: number
    Name: number
    NormalizedName: number
    ConcurrencyStamp: number
    _all: number
  }


  export type AspNetRolesMinAggregateInputType = {
    Id?: true
    Name?: true
    NormalizedName?: true
    ConcurrencyStamp?: true
  }

  export type AspNetRolesMaxAggregateInputType = {
    Id?: true
    Name?: true
    NormalizedName?: true
    ConcurrencyStamp?: true
  }

  export type AspNetRolesCountAggregateInputType = {
    Id?: true
    Name?: true
    NormalizedName?: true
    ConcurrencyStamp?: true
    _all?: true
  }

  export type AspNetRolesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AspNetRoles to aggregate.
     */
    where?: AspNetRolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AspNetRoles to fetch.
     */
    orderBy?: AspNetRolesOrderByWithRelationInput | AspNetRolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AspNetRolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AspNetRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AspNetRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AspNetRoles
    **/
    _count?: true | AspNetRolesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AspNetRolesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AspNetRolesMaxAggregateInputType
  }

  export type GetAspNetRolesAggregateType<T extends AspNetRolesAggregateArgs> = {
        [P in keyof T & keyof AggregateAspNetRoles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAspNetRoles[P]>
      : GetScalarType<T[P], AggregateAspNetRoles[P]>
  }




  export type AspNetRolesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AspNetRolesWhereInput
    orderBy?: AspNetRolesOrderByWithAggregationInput | AspNetRolesOrderByWithAggregationInput[]
    by: AspNetRolesScalarFieldEnum[] | AspNetRolesScalarFieldEnum
    having?: AspNetRolesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AspNetRolesCountAggregateInputType | true
    _min?: AspNetRolesMinAggregateInputType
    _max?: AspNetRolesMaxAggregateInputType
  }

  export type AspNetRolesGroupByOutputType = {
    Id: string
    Name: string | null
    NormalizedName: string | null
    ConcurrencyStamp: string | null
    _count: AspNetRolesCountAggregateOutputType | null
    _min: AspNetRolesMinAggregateOutputType | null
    _max: AspNetRolesMaxAggregateOutputType | null
  }

  type GetAspNetRolesGroupByPayload<T extends AspNetRolesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AspNetRolesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AspNetRolesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AspNetRolesGroupByOutputType[P]>
            : GetScalarType<T[P], AspNetRolesGroupByOutputType[P]>
        }
      >
    >


  export type AspNetRolesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    Name?: boolean
    NormalizedName?: boolean
    ConcurrencyStamp?: boolean
    AspNetRoleClaims?: boolean | AspNetRoles$AspNetRoleClaimsArgs<ExtArgs>
    AspNetUserRoles?: boolean | AspNetRoles$AspNetUserRolesArgs<ExtArgs>
    _count?: boolean | AspNetRolesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aspNetRoles"]>



  export type AspNetRolesSelectScalar = {
    Id?: boolean
    Name?: boolean
    NormalizedName?: boolean
    ConcurrencyStamp?: boolean
  }

  export type AspNetRolesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Id" | "Name" | "NormalizedName" | "ConcurrencyStamp", ExtArgs["result"]["aspNetRoles"]>
  export type AspNetRolesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AspNetRoleClaims?: boolean | AspNetRoles$AspNetRoleClaimsArgs<ExtArgs>
    AspNetUserRoles?: boolean | AspNetRoles$AspNetUserRolesArgs<ExtArgs>
    _count?: boolean | AspNetRolesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AspNetRolesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AspNetRoles"
    objects: {
      AspNetRoleClaims: Prisma.$AspNetRoleClaimsPayload<ExtArgs>[]
      AspNetUserRoles: Prisma.$AspNetUserRolesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      Id: string
      Name: string | null
      NormalizedName: string | null
      ConcurrencyStamp: string | null
    }, ExtArgs["result"]["aspNetRoles"]>
    composites: {}
  }

  type AspNetRolesGetPayload<S extends boolean | null | undefined | AspNetRolesDefaultArgs> = $Result.GetResult<Prisma.$AspNetRolesPayload, S>

  type AspNetRolesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AspNetRolesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AspNetRolesCountAggregateInputType | true
    }

  export interface AspNetRolesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AspNetRoles'], meta: { name: 'AspNetRoles' } }
    /**
     * Find zero or one AspNetRoles that matches the filter.
     * @param {AspNetRolesFindUniqueArgs} args - Arguments to find a AspNetRoles
     * @example
     * // Get one AspNetRoles
     * const aspNetRoles = await prisma.aspNetRoles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AspNetRolesFindUniqueArgs>(args: SelectSubset<T, AspNetRolesFindUniqueArgs<ExtArgs>>): Prisma__AspNetRolesClient<$Result.GetResult<Prisma.$AspNetRolesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AspNetRoles that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AspNetRolesFindUniqueOrThrowArgs} args - Arguments to find a AspNetRoles
     * @example
     * // Get one AspNetRoles
     * const aspNetRoles = await prisma.aspNetRoles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AspNetRolesFindUniqueOrThrowArgs>(args: SelectSubset<T, AspNetRolesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AspNetRolesClient<$Result.GetResult<Prisma.$AspNetRolesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AspNetRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetRolesFindFirstArgs} args - Arguments to find a AspNetRoles
     * @example
     * // Get one AspNetRoles
     * const aspNetRoles = await prisma.aspNetRoles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AspNetRolesFindFirstArgs>(args?: SelectSubset<T, AspNetRolesFindFirstArgs<ExtArgs>>): Prisma__AspNetRolesClient<$Result.GetResult<Prisma.$AspNetRolesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AspNetRoles that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetRolesFindFirstOrThrowArgs} args - Arguments to find a AspNetRoles
     * @example
     * // Get one AspNetRoles
     * const aspNetRoles = await prisma.aspNetRoles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AspNetRolesFindFirstOrThrowArgs>(args?: SelectSubset<T, AspNetRolesFindFirstOrThrowArgs<ExtArgs>>): Prisma__AspNetRolesClient<$Result.GetResult<Prisma.$AspNetRolesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AspNetRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetRolesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AspNetRoles
     * const aspNetRoles = await prisma.aspNetRoles.findMany()
     * 
     * // Get first 10 AspNetRoles
     * const aspNetRoles = await prisma.aspNetRoles.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const aspNetRolesWithIdOnly = await prisma.aspNetRoles.findMany({ select: { Id: true } })
     * 
     */
    findMany<T extends AspNetRolesFindManyArgs>(args?: SelectSubset<T, AspNetRolesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AspNetRolesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AspNetRoles.
     * @param {AspNetRolesCreateArgs} args - Arguments to create a AspNetRoles.
     * @example
     * // Create one AspNetRoles
     * const AspNetRoles = await prisma.aspNetRoles.create({
     *   data: {
     *     // ... data to create a AspNetRoles
     *   }
     * })
     * 
     */
    create<T extends AspNetRolesCreateArgs>(args: SelectSubset<T, AspNetRolesCreateArgs<ExtArgs>>): Prisma__AspNetRolesClient<$Result.GetResult<Prisma.$AspNetRolesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AspNetRoles.
     * @param {AspNetRolesCreateManyArgs} args - Arguments to create many AspNetRoles.
     * @example
     * // Create many AspNetRoles
     * const aspNetRoles = await prisma.aspNetRoles.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AspNetRolesCreateManyArgs>(args?: SelectSubset<T, AspNetRolesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AspNetRoles.
     * @param {AspNetRolesDeleteArgs} args - Arguments to delete one AspNetRoles.
     * @example
     * // Delete one AspNetRoles
     * const AspNetRoles = await prisma.aspNetRoles.delete({
     *   where: {
     *     // ... filter to delete one AspNetRoles
     *   }
     * })
     * 
     */
    delete<T extends AspNetRolesDeleteArgs>(args: SelectSubset<T, AspNetRolesDeleteArgs<ExtArgs>>): Prisma__AspNetRolesClient<$Result.GetResult<Prisma.$AspNetRolesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AspNetRoles.
     * @param {AspNetRolesUpdateArgs} args - Arguments to update one AspNetRoles.
     * @example
     * // Update one AspNetRoles
     * const aspNetRoles = await prisma.aspNetRoles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AspNetRolesUpdateArgs>(args: SelectSubset<T, AspNetRolesUpdateArgs<ExtArgs>>): Prisma__AspNetRolesClient<$Result.GetResult<Prisma.$AspNetRolesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AspNetRoles.
     * @param {AspNetRolesDeleteManyArgs} args - Arguments to filter AspNetRoles to delete.
     * @example
     * // Delete a few AspNetRoles
     * const { count } = await prisma.aspNetRoles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AspNetRolesDeleteManyArgs>(args?: SelectSubset<T, AspNetRolesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AspNetRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetRolesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AspNetRoles
     * const aspNetRoles = await prisma.aspNetRoles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AspNetRolesUpdateManyArgs>(args: SelectSubset<T, AspNetRolesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AspNetRoles.
     * @param {AspNetRolesUpsertArgs} args - Arguments to update or create a AspNetRoles.
     * @example
     * // Update or create a AspNetRoles
     * const aspNetRoles = await prisma.aspNetRoles.upsert({
     *   create: {
     *     // ... data to create a AspNetRoles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AspNetRoles we want to update
     *   }
     * })
     */
    upsert<T extends AspNetRolesUpsertArgs>(args: SelectSubset<T, AspNetRolesUpsertArgs<ExtArgs>>): Prisma__AspNetRolesClient<$Result.GetResult<Prisma.$AspNetRolesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AspNetRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetRolesCountArgs} args - Arguments to filter AspNetRoles to count.
     * @example
     * // Count the number of AspNetRoles
     * const count = await prisma.aspNetRoles.count({
     *   where: {
     *     // ... the filter for the AspNetRoles we want to count
     *   }
     * })
    **/
    count<T extends AspNetRolesCountArgs>(
      args?: Subset<T, AspNetRolesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AspNetRolesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AspNetRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetRolesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AspNetRolesAggregateArgs>(args: Subset<T, AspNetRolesAggregateArgs>): Prisma.PrismaPromise<GetAspNetRolesAggregateType<T>>

    /**
     * Group by AspNetRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetRolesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AspNetRolesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AspNetRolesGroupByArgs['orderBy'] }
        : { orderBy?: AspNetRolesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AspNetRolesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAspNetRolesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AspNetRoles model
   */
  readonly fields: AspNetRolesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AspNetRoles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AspNetRolesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    AspNetRoleClaims<T extends AspNetRoles$AspNetRoleClaimsArgs<ExtArgs> = {}>(args?: Subset<T, AspNetRoles$AspNetRoleClaimsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AspNetRoleClaimsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    AspNetUserRoles<T extends AspNetRoles$AspNetUserRolesArgs<ExtArgs> = {}>(args?: Subset<T, AspNetRoles$AspNetUserRolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AspNetUserRolesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AspNetRoles model
   */
  interface AspNetRolesFieldRefs {
    readonly Id: FieldRef<"AspNetRoles", 'String'>
    readonly Name: FieldRef<"AspNetRoles", 'String'>
    readonly NormalizedName: FieldRef<"AspNetRoles", 'String'>
    readonly ConcurrencyStamp: FieldRef<"AspNetRoles", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AspNetRoles findUnique
   */
  export type AspNetRolesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetRoles
     */
    select?: AspNetRolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspNetRoles
     */
    omit?: AspNetRolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetRolesInclude<ExtArgs> | null
    /**
     * Filter, which AspNetRoles to fetch.
     */
    where: AspNetRolesWhereUniqueInput
  }

  /**
   * AspNetRoles findUniqueOrThrow
   */
  export type AspNetRolesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetRoles
     */
    select?: AspNetRolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspNetRoles
     */
    omit?: AspNetRolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetRolesInclude<ExtArgs> | null
    /**
     * Filter, which AspNetRoles to fetch.
     */
    where: AspNetRolesWhereUniqueInput
  }

  /**
   * AspNetRoles findFirst
   */
  export type AspNetRolesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetRoles
     */
    select?: AspNetRolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspNetRoles
     */
    omit?: AspNetRolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetRolesInclude<ExtArgs> | null
    /**
     * Filter, which AspNetRoles to fetch.
     */
    where?: AspNetRolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AspNetRoles to fetch.
     */
    orderBy?: AspNetRolesOrderByWithRelationInput | AspNetRolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AspNetRoles.
     */
    cursor?: AspNetRolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AspNetRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AspNetRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AspNetRoles.
     */
    distinct?: AspNetRolesScalarFieldEnum | AspNetRolesScalarFieldEnum[]
  }

  /**
   * AspNetRoles findFirstOrThrow
   */
  export type AspNetRolesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetRoles
     */
    select?: AspNetRolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspNetRoles
     */
    omit?: AspNetRolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetRolesInclude<ExtArgs> | null
    /**
     * Filter, which AspNetRoles to fetch.
     */
    where?: AspNetRolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AspNetRoles to fetch.
     */
    orderBy?: AspNetRolesOrderByWithRelationInput | AspNetRolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AspNetRoles.
     */
    cursor?: AspNetRolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AspNetRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AspNetRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AspNetRoles.
     */
    distinct?: AspNetRolesScalarFieldEnum | AspNetRolesScalarFieldEnum[]
  }

  /**
   * AspNetRoles findMany
   */
  export type AspNetRolesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetRoles
     */
    select?: AspNetRolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspNetRoles
     */
    omit?: AspNetRolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetRolesInclude<ExtArgs> | null
    /**
     * Filter, which AspNetRoles to fetch.
     */
    where?: AspNetRolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AspNetRoles to fetch.
     */
    orderBy?: AspNetRolesOrderByWithRelationInput | AspNetRolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AspNetRoles.
     */
    cursor?: AspNetRolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AspNetRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AspNetRoles.
     */
    skip?: number
    distinct?: AspNetRolesScalarFieldEnum | AspNetRolesScalarFieldEnum[]
  }

  /**
   * AspNetRoles create
   */
  export type AspNetRolesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetRoles
     */
    select?: AspNetRolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspNetRoles
     */
    omit?: AspNetRolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetRolesInclude<ExtArgs> | null
    /**
     * The data needed to create a AspNetRoles.
     */
    data: XOR<AspNetRolesCreateInput, AspNetRolesUncheckedCreateInput>
  }

  /**
   * AspNetRoles createMany
   */
  export type AspNetRolesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AspNetRoles.
     */
    data: AspNetRolesCreateManyInput | AspNetRolesCreateManyInput[]
  }

  /**
   * AspNetRoles update
   */
  export type AspNetRolesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetRoles
     */
    select?: AspNetRolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspNetRoles
     */
    omit?: AspNetRolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetRolesInclude<ExtArgs> | null
    /**
     * The data needed to update a AspNetRoles.
     */
    data: XOR<AspNetRolesUpdateInput, AspNetRolesUncheckedUpdateInput>
    /**
     * Choose, which AspNetRoles to update.
     */
    where: AspNetRolesWhereUniqueInput
  }

  /**
   * AspNetRoles updateMany
   */
  export type AspNetRolesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AspNetRoles.
     */
    data: XOR<AspNetRolesUpdateManyMutationInput, AspNetRolesUncheckedUpdateManyInput>
    /**
     * Filter which AspNetRoles to update
     */
    where?: AspNetRolesWhereInput
    /**
     * Limit how many AspNetRoles to update.
     */
    limit?: number
  }

  /**
   * AspNetRoles upsert
   */
  export type AspNetRolesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetRoles
     */
    select?: AspNetRolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspNetRoles
     */
    omit?: AspNetRolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetRolesInclude<ExtArgs> | null
    /**
     * The filter to search for the AspNetRoles to update in case it exists.
     */
    where: AspNetRolesWhereUniqueInput
    /**
     * In case the AspNetRoles found by the `where` argument doesn't exist, create a new AspNetRoles with this data.
     */
    create: XOR<AspNetRolesCreateInput, AspNetRolesUncheckedCreateInput>
    /**
     * In case the AspNetRoles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AspNetRolesUpdateInput, AspNetRolesUncheckedUpdateInput>
  }

  /**
   * AspNetRoles delete
   */
  export type AspNetRolesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetRoles
     */
    select?: AspNetRolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspNetRoles
     */
    omit?: AspNetRolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetRolesInclude<ExtArgs> | null
    /**
     * Filter which AspNetRoles to delete.
     */
    where: AspNetRolesWhereUniqueInput
  }

  /**
   * AspNetRoles deleteMany
   */
  export type AspNetRolesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AspNetRoles to delete
     */
    where?: AspNetRolesWhereInput
    /**
     * Limit how many AspNetRoles to delete.
     */
    limit?: number
  }

  /**
   * AspNetRoles.AspNetRoleClaims
   */
  export type AspNetRoles$AspNetRoleClaimsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetRoleClaims
     */
    select?: AspNetRoleClaimsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspNetRoleClaims
     */
    omit?: AspNetRoleClaimsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetRoleClaimsInclude<ExtArgs> | null
    where?: AspNetRoleClaimsWhereInput
    orderBy?: AspNetRoleClaimsOrderByWithRelationInput | AspNetRoleClaimsOrderByWithRelationInput[]
    cursor?: AspNetRoleClaimsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AspNetRoleClaimsScalarFieldEnum | AspNetRoleClaimsScalarFieldEnum[]
  }

  /**
   * AspNetRoles.AspNetUserRoles
   */
  export type AspNetRoles$AspNetUserRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserRoles
     */
    select?: AspNetUserRolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspNetUserRoles
     */
    omit?: AspNetUserRolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserRolesInclude<ExtArgs> | null
    where?: AspNetUserRolesWhereInput
    orderBy?: AspNetUserRolesOrderByWithRelationInput | AspNetUserRolesOrderByWithRelationInput[]
    cursor?: AspNetUserRolesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AspNetUserRolesScalarFieldEnum | AspNetUserRolesScalarFieldEnum[]
  }

  /**
   * AspNetRoles without action
   */
  export type AspNetRolesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetRoles
     */
    select?: AspNetRolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspNetRoles
     */
    omit?: AspNetRolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetRolesInclude<ExtArgs> | null
  }


  /**
   * Model AspNetUserClaims
   */

  export type AggregateAspNetUserClaims = {
    _count: AspNetUserClaimsCountAggregateOutputType | null
    _avg: AspNetUserClaimsAvgAggregateOutputType | null
    _sum: AspNetUserClaimsSumAggregateOutputType | null
    _min: AspNetUserClaimsMinAggregateOutputType | null
    _max: AspNetUserClaimsMaxAggregateOutputType | null
  }

  export type AspNetUserClaimsAvgAggregateOutputType = {
    Id: number | null
  }

  export type AspNetUserClaimsSumAggregateOutputType = {
    Id: number | null
  }

  export type AspNetUserClaimsMinAggregateOutputType = {
    Id: number | null
    UserId: string | null
    ClaimType: string | null
    ClaimValue: string | null
  }

  export type AspNetUserClaimsMaxAggregateOutputType = {
    Id: number | null
    UserId: string | null
    ClaimType: string | null
    ClaimValue: string | null
  }

  export type AspNetUserClaimsCountAggregateOutputType = {
    Id: number
    UserId: number
    ClaimType: number
    ClaimValue: number
    _all: number
  }


  export type AspNetUserClaimsAvgAggregateInputType = {
    Id?: true
  }

  export type AspNetUserClaimsSumAggregateInputType = {
    Id?: true
  }

  export type AspNetUserClaimsMinAggregateInputType = {
    Id?: true
    UserId?: true
    ClaimType?: true
    ClaimValue?: true
  }

  export type AspNetUserClaimsMaxAggregateInputType = {
    Id?: true
    UserId?: true
    ClaimType?: true
    ClaimValue?: true
  }

  export type AspNetUserClaimsCountAggregateInputType = {
    Id?: true
    UserId?: true
    ClaimType?: true
    ClaimValue?: true
    _all?: true
  }

  export type AspNetUserClaimsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AspNetUserClaims to aggregate.
     */
    where?: AspNetUserClaimsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AspNetUserClaims to fetch.
     */
    orderBy?: AspNetUserClaimsOrderByWithRelationInput | AspNetUserClaimsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AspNetUserClaimsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AspNetUserClaims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AspNetUserClaims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AspNetUserClaims
    **/
    _count?: true | AspNetUserClaimsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AspNetUserClaimsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AspNetUserClaimsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AspNetUserClaimsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AspNetUserClaimsMaxAggregateInputType
  }

  export type GetAspNetUserClaimsAggregateType<T extends AspNetUserClaimsAggregateArgs> = {
        [P in keyof T & keyof AggregateAspNetUserClaims]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAspNetUserClaims[P]>
      : GetScalarType<T[P], AggregateAspNetUserClaims[P]>
  }




  export type AspNetUserClaimsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AspNetUserClaimsWhereInput
    orderBy?: AspNetUserClaimsOrderByWithAggregationInput | AspNetUserClaimsOrderByWithAggregationInput[]
    by: AspNetUserClaimsScalarFieldEnum[] | AspNetUserClaimsScalarFieldEnum
    having?: AspNetUserClaimsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AspNetUserClaimsCountAggregateInputType | true
    _avg?: AspNetUserClaimsAvgAggregateInputType
    _sum?: AspNetUserClaimsSumAggregateInputType
    _min?: AspNetUserClaimsMinAggregateInputType
    _max?: AspNetUserClaimsMaxAggregateInputType
  }

  export type AspNetUserClaimsGroupByOutputType = {
    Id: number
    UserId: string
    ClaimType: string | null
    ClaimValue: string | null
    _count: AspNetUserClaimsCountAggregateOutputType | null
    _avg: AspNetUserClaimsAvgAggregateOutputType | null
    _sum: AspNetUserClaimsSumAggregateOutputType | null
    _min: AspNetUserClaimsMinAggregateOutputType | null
    _max: AspNetUserClaimsMaxAggregateOutputType | null
  }

  type GetAspNetUserClaimsGroupByPayload<T extends AspNetUserClaimsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AspNetUserClaimsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AspNetUserClaimsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AspNetUserClaimsGroupByOutputType[P]>
            : GetScalarType<T[P], AspNetUserClaimsGroupByOutputType[P]>
        }
      >
    >


  export type AspNetUserClaimsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    UserId?: boolean
    ClaimType?: boolean
    ClaimValue?: boolean
    AspNetUsers?: boolean | AspNetUsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aspNetUserClaims"]>



  export type AspNetUserClaimsSelectScalar = {
    Id?: boolean
    UserId?: boolean
    ClaimType?: boolean
    ClaimValue?: boolean
  }

  export type AspNetUserClaimsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Id" | "UserId" | "ClaimType" | "ClaimValue", ExtArgs["result"]["aspNetUserClaims"]>
  export type AspNetUserClaimsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AspNetUsers?: boolean | AspNetUsersDefaultArgs<ExtArgs>
  }

  export type $AspNetUserClaimsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AspNetUserClaims"
    objects: {
      AspNetUsers: Prisma.$AspNetUsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      Id: number
      UserId: string
      ClaimType: string | null
      ClaimValue: string | null
    }, ExtArgs["result"]["aspNetUserClaims"]>
    composites: {}
  }

  type AspNetUserClaimsGetPayload<S extends boolean | null | undefined | AspNetUserClaimsDefaultArgs> = $Result.GetResult<Prisma.$AspNetUserClaimsPayload, S>

  type AspNetUserClaimsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AspNetUserClaimsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AspNetUserClaimsCountAggregateInputType | true
    }

  export interface AspNetUserClaimsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AspNetUserClaims'], meta: { name: 'AspNetUserClaims' } }
    /**
     * Find zero or one AspNetUserClaims that matches the filter.
     * @param {AspNetUserClaimsFindUniqueArgs} args - Arguments to find a AspNetUserClaims
     * @example
     * // Get one AspNetUserClaims
     * const aspNetUserClaims = await prisma.aspNetUserClaims.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AspNetUserClaimsFindUniqueArgs>(args: SelectSubset<T, AspNetUserClaimsFindUniqueArgs<ExtArgs>>): Prisma__AspNetUserClaimsClient<$Result.GetResult<Prisma.$AspNetUserClaimsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AspNetUserClaims that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AspNetUserClaimsFindUniqueOrThrowArgs} args - Arguments to find a AspNetUserClaims
     * @example
     * // Get one AspNetUserClaims
     * const aspNetUserClaims = await prisma.aspNetUserClaims.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AspNetUserClaimsFindUniqueOrThrowArgs>(args: SelectSubset<T, AspNetUserClaimsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AspNetUserClaimsClient<$Result.GetResult<Prisma.$AspNetUserClaimsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AspNetUserClaims that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetUserClaimsFindFirstArgs} args - Arguments to find a AspNetUserClaims
     * @example
     * // Get one AspNetUserClaims
     * const aspNetUserClaims = await prisma.aspNetUserClaims.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AspNetUserClaimsFindFirstArgs>(args?: SelectSubset<T, AspNetUserClaimsFindFirstArgs<ExtArgs>>): Prisma__AspNetUserClaimsClient<$Result.GetResult<Prisma.$AspNetUserClaimsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AspNetUserClaims that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetUserClaimsFindFirstOrThrowArgs} args - Arguments to find a AspNetUserClaims
     * @example
     * // Get one AspNetUserClaims
     * const aspNetUserClaims = await prisma.aspNetUserClaims.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AspNetUserClaimsFindFirstOrThrowArgs>(args?: SelectSubset<T, AspNetUserClaimsFindFirstOrThrowArgs<ExtArgs>>): Prisma__AspNetUserClaimsClient<$Result.GetResult<Prisma.$AspNetUserClaimsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AspNetUserClaims that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetUserClaimsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AspNetUserClaims
     * const aspNetUserClaims = await prisma.aspNetUserClaims.findMany()
     * 
     * // Get first 10 AspNetUserClaims
     * const aspNetUserClaims = await prisma.aspNetUserClaims.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const aspNetUserClaimsWithIdOnly = await prisma.aspNetUserClaims.findMany({ select: { Id: true } })
     * 
     */
    findMany<T extends AspNetUserClaimsFindManyArgs>(args?: SelectSubset<T, AspNetUserClaimsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AspNetUserClaimsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AspNetUserClaims.
     * @param {AspNetUserClaimsCreateArgs} args - Arguments to create a AspNetUserClaims.
     * @example
     * // Create one AspNetUserClaims
     * const AspNetUserClaims = await prisma.aspNetUserClaims.create({
     *   data: {
     *     // ... data to create a AspNetUserClaims
     *   }
     * })
     * 
     */
    create<T extends AspNetUserClaimsCreateArgs>(args: SelectSubset<T, AspNetUserClaimsCreateArgs<ExtArgs>>): Prisma__AspNetUserClaimsClient<$Result.GetResult<Prisma.$AspNetUserClaimsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AspNetUserClaims.
     * @param {AspNetUserClaimsCreateManyArgs} args - Arguments to create many AspNetUserClaims.
     * @example
     * // Create many AspNetUserClaims
     * const aspNetUserClaims = await prisma.aspNetUserClaims.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AspNetUserClaimsCreateManyArgs>(args?: SelectSubset<T, AspNetUserClaimsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AspNetUserClaims.
     * @param {AspNetUserClaimsDeleteArgs} args - Arguments to delete one AspNetUserClaims.
     * @example
     * // Delete one AspNetUserClaims
     * const AspNetUserClaims = await prisma.aspNetUserClaims.delete({
     *   where: {
     *     // ... filter to delete one AspNetUserClaims
     *   }
     * })
     * 
     */
    delete<T extends AspNetUserClaimsDeleteArgs>(args: SelectSubset<T, AspNetUserClaimsDeleteArgs<ExtArgs>>): Prisma__AspNetUserClaimsClient<$Result.GetResult<Prisma.$AspNetUserClaimsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AspNetUserClaims.
     * @param {AspNetUserClaimsUpdateArgs} args - Arguments to update one AspNetUserClaims.
     * @example
     * // Update one AspNetUserClaims
     * const aspNetUserClaims = await prisma.aspNetUserClaims.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AspNetUserClaimsUpdateArgs>(args: SelectSubset<T, AspNetUserClaimsUpdateArgs<ExtArgs>>): Prisma__AspNetUserClaimsClient<$Result.GetResult<Prisma.$AspNetUserClaimsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AspNetUserClaims.
     * @param {AspNetUserClaimsDeleteManyArgs} args - Arguments to filter AspNetUserClaims to delete.
     * @example
     * // Delete a few AspNetUserClaims
     * const { count } = await prisma.aspNetUserClaims.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AspNetUserClaimsDeleteManyArgs>(args?: SelectSubset<T, AspNetUserClaimsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AspNetUserClaims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetUserClaimsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AspNetUserClaims
     * const aspNetUserClaims = await prisma.aspNetUserClaims.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AspNetUserClaimsUpdateManyArgs>(args: SelectSubset<T, AspNetUserClaimsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AspNetUserClaims.
     * @param {AspNetUserClaimsUpsertArgs} args - Arguments to update or create a AspNetUserClaims.
     * @example
     * // Update or create a AspNetUserClaims
     * const aspNetUserClaims = await prisma.aspNetUserClaims.upsert({
     *   create: {
     *     // ... data to create a AspNetUserClaims
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AspNetUserClaims we want to update
     *   }
     * })
     */
    upsert<T extends AspNetUserClaimsUpsertArgs>(args: SelectSubset<T, AspNetUserClaimsUpsertArgs<ExtArgs>>): Prisma__AspNetUserClaimsClient<$Result.GetResult<Prisma.$AspNetUserClaimsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AspNetUserClaims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetUserClaimsCountArgs} args - Arguments to filter AspNetUserClaims to count.
     * @example
     * // Count the number of AspNetUserClaims
     * const count = await prisma.aspNetUserClaims.count({
     *   where: {
     *     // ... the filter for the AspNetUserClaims we want to count
     *   }
     * })
    **/
    count<T extends AspNetUserClaimsCountArgs>(
      args?: Subset<T, AspNetUserClaimsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AspNetUserClaimsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AspNetUserClaims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetUserClaimsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AspNetUserClaimsAggregateArgs>(args: Subset<T, AspNetUserClaimsAggregateArgs>): Prisma.PrismaPromise<GetAspNetUserClaimsAggregateType<T>>

    /**
     * Group by AspNetUserClaims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetUserClaimsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AspNetUserClaimsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AspNetUserClaimsGroupByArgs['orderBy'] }
        : { orderBy?: AspNetUserClaimsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AspNetUserClaimsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAspNetUserClaimsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AspNetUserClaims model
   */
  readonly fields: AspNetUserClaimsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AspNetUserClaims.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AspNetUserClaimsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    AspNetUsers<T extends AspNetUsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AspNetUsersDefaultArgs<ExtArgs>>): Prisma__AspNetUsersClient<$Result.GetResult<Prisma.$AspNetUsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AspNetUserClaims model
   */
  interface AspNetUserClaimsFieldRefs {
    readonly Id: FieldRef<"AspNetUserClaims", 'Int'>
    readonly UserId: FieldRef<"AspNetUserClaims", 'String'>
    readonly ClaimType: FieldRef<"AspNetUserClaims", 'String'>
    readonly ClaimValue: FieldRef<"AspNetUserClaims", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AspNetUserClaims findUnique
   */
  export type AspNetUserClaimsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserClaims
     */
    select?: AspNetUserClaimsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspNetUserClaims
     */
    omit?: AspNetUserClaimsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserClaimsInclude<ExtArgs> | null
    /**
     * Filter, which AspNetUserClaims to fetch.
     */
    where: AspNetUserClaimsWhereUniqueInput
  }

  /**
   * AspNetUserClaims findUniqueOrThrow
   */
  export type AspNetUserClaimsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserClaims
     */
    select?: AspNetUserClaimsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspNetUserClaims
     */
    omit?: AspNetUserClaimsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserClaimsInclude<ExtArgs> | null
    /**
     * Filter, which AspNetUserClaims to fetch.
     */
    where: AspNetUserClaimsWhereUniqueInput
  }

  /**
   * AspNetUserClaims findFirst
   */
  export type AspNetUserClaimsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserClaims
     */
    select?: AspNetUserClaimsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspNetUserClaims
     */
    omit?: AspNetUserClaimsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserClaimsInclude<ExtArgs> | null
    /**
     * Filter, which AspNetUserClaims to fetch.
     */
    where?: AspNetUserClaimsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AspNetUserClaims to fetch.
     */
    orderBy?: AspNetUserClaimsOrderByWithRelationInput | AspNetUserClaimsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AspNetUserClaims.
     */
    cursor?: AspNetUserClaimsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AspNetUserClaims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AspNetUserClaims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AspNetUserClaims.
     */
    distinct?: AspNetUserClaimsScalarFieldEnum | AspNetUserClaimsScalarFieldEnum[]
  }

  /**
   * AspNetUserClaims findFirstOrThrow
   */
  export type AspNetUserClaimsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserClaims
     */
    select?: AspNetUserClaimsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspNetUserClaims
     */
    omit?: AspNetUserClaimsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserClaimsInclude<ExtArgs> | null
    /**
     * Filter, which AspNetUserClaims to fetch.
     */
    where?: AspNetUserClaimsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AspNetUserClaims to fetch.
     */
    orderBy?: AspNetUserClaimsOrderByWithRelationInput | AspNetUserClaimsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AspNetUserClaims.
     */
    cursor?: AspNetUserClaimsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AspNetUserClaims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AspNetUserClaims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AspNetUserClaims.
     */
    distinct?: AspNetUserClaimsScalarFieldEnum | AspNetUserClaimsScalarFieldEnum[]
  }

  /**
   * AspNetUserClaims findMany
   */
  export type AspNetUserClaimsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserClaims
     */
    select?: AspNetUserClaimsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspNetUserClaims
     */
    omit?: AspNetUserClaimsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserClaimsInclude<ExtArgs> | null
    /**
     * Filter, which AspNetUserClaims to fetch.
     */
    where?: AspNetUserClaimsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AspNetUserClaims to fetch.
     */
    orderBy?: AspNetUserClaimsOrderByWithRelationInput | AspNetUserClaimsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AspNetUserClaims.
     */
    cursor?: AspNetUserClaimsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AspNetUserClaims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AspNetUserClaims.
     */
    skip?: number
    distinct?: AspNetUserClaimsScalarFieldEnum | AspNetUserClaimsScalarFieldEnum[]
  }

  /**
   * AspNetUserClaims create
   */
  export type AspNetUserClaimsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserClaims
     */
    select?: AspNetUserClaimsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspNetUserClaims
     */
    omit?: AspNetUserClaimsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserClaimsInclude<ExtArgs> | null
    /**
     * The data needed to create a AspNetUserClaims.
     */
    data: XOR<AspNetUserClaimsCreateInput, AspNetUserClaimsUncheckedCreateInput>
  }

  /**
   * AspNetUserClaims createMany
   */
  export type AspNetUserClaimsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AspNetUserClaims.
     */
    data: AspNetUserClaimsCreateManyInput | AspNetUserClaimsCreateManyInput[]
  }

  /**
   * AspNetUserClaims update
   */
  export type AspNetUserClaimsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserClaims
     */
    select?: AspNetUserClaimsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspNetUserClaims
     */
    omit?: AspNetUserClaimsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserClaimsInclude<ExtArgs> | null
    /**
     * The data needed to update a AspNetUserClaims.
     */
    data: XOR<AspNetUserClaimsUpdateInput, AspNetUserClaimsUncheckedUpdateInput>
    /**
     * Choose, which AspNetUserClaims to update.
     */
    where: AspNetUserClaimsWhereUniqueInput
  }

  /**
   * AspNetUserClaims updateMany
   */
  export type AspNetUserClaimsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AspNetUserClaims.
     */
    data: XOR<AspNetUserClaimsUpdateManyMutationInput, AspNetUserClaimsUncheckedUpdateManyInput>
    /**
     * Filter which AspNetUserClaims to update
     */
    where?: AspNetUserClaimsWhereInput
    /**
     * Limit how many AspNetUserClaims to update.
     */
    limit?: number
  }

  /**
   * AspNetUserClaims upsert
   */
  export type AspNetUserClaimsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserClaims
     */
    select?: AspNetUserClaimsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspNetUserClaims
     */
    omit?: AspNetUserClaimsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserClaimsInclude<ExtArgs> | null
    /**
     * The filter to search for the AspNetUserClaims to update in case it exists.
     */
    where: AspNetUserClaimsWhereUniqueInput
    /**
     * In case the AspNetUserClaims found by the `where` argument doesn't exist, create a new AspNetUserClaims with this data.
     */
    create: XOR<AspNetUserClaimsCreateInput, AspNetUserClaimsUncheckedCreateInput>
    /**
     * In case the AspNetUserClaims was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AspNetUserClaimsUpdateInput, AspNetUserClaimsUncheckedUpdateInput>
  }

  /**
   * AspNetUserClaims delete
   */
  export type AspNetUserClaimsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserClaims
     */
    select?: AspNetUserClaimsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspNetUserClaims
     */
    omit?: AspNetUserClaimsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserClaimsInclude<ExtArgs> | null
    /**
     * Filter which AspNetUserClaims to delete.
     */
    where: AspNetUserClaimsWhereUniqueInput
  }

  /**
   * AspNetUserClaims deleteMany
   */
  export type AspNetUserClaimsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AspNetUserClaims to delete
     */
    where?: AspNetUserClaimsWhereInput
    /**
     * Limit how many AspNetUserClaims to delete.
     */
    limit?: number
  }

  /**
   * AspNetUserClaims without action
   */
  export type AspNetUserClaimsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserClaims
     */
    select?: AspNetUserClaimsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspNetUserClaims
     */
    omit?: AspNetUserClaimsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserClaimsInclude<ExtArgs> | null
  }


  /**
   * Model AspNetUserLogins
   */

  export type AggregateAspNetUserLogins = {
    _count: AspNetUserLoginsCountAggregateOutputType | null
    _min: AspNetUserLoginsMinAggregateOutputType | null
    _max: AspNetUserLoginsMaxAggregateOutputType | null
  }

  export type AspNetUserLoginsMinAggregateOutputType = {
    LoginProvider: string | null
    ProviderKey: string | null
    ProviderDisplayName: string | null
    UserId: string | null
  }

  export type AspNetUserLoginsMaxAggregateOutputType = {
    LoginProvider: string | null
    ProviderKey: string | null
    ProviderDisplayName: string | null
    UserId: string | null
  }

  export type AspNetUserLoginsCountAggregateOutputType = {
    LoginProvider: number
    ProviderKey: number
    ProviderDisplayName: number
    UserId: number
    _all: number
  }


  export type AspNetUserLoginsMinAggregateInputType = {
    LoginProvider?: true
    ProviderKey?: true
    ProviderDisplayName?: true
    UserId?: true
  }

  export type AspNetUserLoginsMaxAggregateInputType = {
    LoginProvider?: true
    ProviderKey?: true
    ProviderDisplayName?: true
    UserId?: true
  }

  export type AspNetUserLoginsCountAggregateInputType = {
    LoginProvider?: true
    ProviderKey?: true
    ProviderDisplayName?: true
    UserId?: true
    _all?: true
  }

  export type AspNetUserLoginsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AspNetUserLogins to aggregate.
     */
    where?: AspNetUserLoginsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AspNetUserLogins to fetch.
     */
    orderBy?: AspNetUserLoginsOrderByWithRelationInput | AspNetUserLoginsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AspNetUserLoginsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AspNetUserLogins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AspNetUserLogins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AspNetUserLogins
    **/
    _count?: true | AspNetUserLoginsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AspNetUserLoginsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AspNetUserLoginsMaxAggregateInputType
  }

  export type GetAspNetUserLoginsAggregateType<T extends AspNetUserLoginsAggregateArgs> = {
        [P in keyof T & keyof AggregateAspNetUserLogins]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAspNetUserLogins[P]>
      : GetScalarType<T[P], AggregateAspNetUserLogins[P]>
  }




  export type AspNetUserLoginsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AspNetUserLoginsWhereInput
    orderBy?: AspNetUserLoginsOrderByWithAggregationInput | AspNetUserLoginsOrderByWithAggregationInput[]
    by: AspNetUserLoginsScalarFieldEnum[] | AspNetUserLoginsScalarFieldEnum
    having?: AspNetUserLoginsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AspNetUserLoginsCountAggregateInputType | true
    _min?: AspNetUserLoginsMinAggregateInputType
    _max?: AspNetUserLoginsMaxAggregateInputType
  }

  export type AspNetUserLoginsGroupByOutputType = {
    LoginProvider: string
    ProviderKey: string
    ProviderDisplayName: string | null
    UserId: string
    _count: AspNetUserLoginsCountAggregateOutputType | null
    _min: AspNetUserLoginsMinAggregateOutputType | null
    _max: AspNetUserLoginsMaxAggregateOutputType | null
  }

  type GetAspNetUserLoginsGroupByPayload<T extends AspNetUserLoginsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AspNetUserLoginsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AspNetUserLoginsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AspNetUserLoginsGroupByOutputType[P]>
            : GetScalarType<T[P], AspNetUserLoginsGroupByOutputType[P]>
        }
      >
    >


  export type AspNetUserLoginsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    LoginProvider?: boolean
    ProviderKey?: boolean
    ProviderDisplayName?: boolean
    UserId?: boolean
    AspNetUsers?: boolean | AspNetUsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aspNetUserLogins"]>



  export type AspNetUserLoginsSelectScalar = {
    LoginProvider?: boolean
    ProviderKey?: boolean
    ProviderDisplayName?: boolean
    UserId?: boolean
  }

  export type AspNetUserLoginsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"LoginProvider" | "ProviderKey" | "ProviderDisplayName" | "UserId", ExtArgs["result"]["aspNetUserLogins"]>
  export type AspNetUserLoginsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AspNetUsers?: boolean | AspNetUsersDefaultArgs<ExtArgs>
  }

  export type $AspNetUserLoginsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AspNetUserLogins"
    objects: {
      AspNetUsers: Prisma.$AspNetUsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      LoginProvider: string
      ProviderKey: string
      ProviderDisplayName: string | null
      UserId: string
    }, ExtArgs["result"]["aspNetUserLogins"]>
    composites: {}
  }

  type AspNetUserLoginsGetPayload<S extends boolean | null | undefined | AspNetUserLoginsDefaultArgs> = $Result.GetResult<Prisma.$AspNetUserLoginsPayload, S>

  type AspNetUserLoginsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AspNetUserLoginsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AspNetUserLoginsCountAggregateInputType | true
    }

  export interface AspNetUserLoginsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AspNetUserLogins'], meta: { name: 'AspNetUserLogins' } }
    /**
     * Find zero or one AspNetUserLogins that matches the filter.
     * @param {AspNetUserLoginsFindUniqueArgs} args - Arguments to find a AspNetUserLogins
     * @example
     * // Get one AspNetUserLogins
     * const aspNetUserLogins = await prisma.aspNetUserLogins.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AspNetUserLoginsFindUniqueArgs>(args: SelectSubset<T, AspNetUserLoginsFindUniqueArgs<ExtArgs>>): Prisma__AspNetUserLoginsClient<$Result.GetResult<Prisma.$AspNetUserLoginsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AspNetUserLogins that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AspNetUserLoginsFindUniqueOrThrowArgs} args - Arguments to find a AspNetUserLogins
     * @example
     * // Get one AspNetUserLogins
     * const aspNetUserLogins = await prisma.aspNetUserLogins.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AspNetUserLoginsFindUniqueOrThrowArgs>(args: SelectSubset<T, AspNetUserLoginsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AspNetUserLoginsClient<$Result.GetResult<Prisma.$AspNetUserLoginsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AspNetUserLogins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetUserLoginsFindFirstArgs} args - Arguments to find a AspNetUserLogins
     * @example
     * // Get one AspNetUserLogins
     * const aspNetUserLogins = await prisma.aspNetUserLogins.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AspNetUserLoginsFindFirstArgs>(args?: SelectSubset<T, AspNetUserLoginsFindFirstArgs<ExtArgs>>): Prisma__AspNetUserLoginsClient<$Result.GetResult<Prisma.$AspNetUserLoginsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AspNetUserLogins that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetUserLoginsFindFirstOrThrowArgs} args - Arguments to find a AspNetUserLogins
     * @example
     * // Get one AspNetUserLogins
     * const aspNetUserLogins = await prisma.aspNetUserLogins.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AspNetUserLoginsFindFirstOrThrowArgs>(args?: SelectSubset<T, AspNetUserLoginsFindFirstOrThrowArgs<ExtArgs>>): Prisma__AspNetUserLoginsClient<$Result.GetResult<Prisma.$AspNetUserLoginsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AspNetUserLogins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetUserLoginsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AspNetUserLogins
     * const aspNetUserLogins = await prisma.aspNetUserLogins.findMany()
     * 
     * // Get first 10 AspNetUserLogins
     * const aspNetUserLogins = await prisma.aspNetUserLogins.findMany({ take: 10 })
     * 
     * // Only select the `LoginProvider`
     * const aspNetUserLoginsWithLoginProviderOnly = await prisma.aspNetUserLogins.findMany({ select: { LoginProvider: true } })
     * 
     */
    findMany<T extends AspNetUserLoginsFindManyArgs>(args?: SelectSubset<T, AspNetUserLoginsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AspNetUserLoginsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AspNetUserLogins.
     * @param {AspNetUserLoginsCreateArgs} args - Arguments to create a AspNetUserLogins.
     * @example
     * // Create one AspNetUserLogins
     * const AspNetUserLogins = await prisma.aspNetUserLogins.create({
     *   data: {
     *     // ... data to create a AspNetUserLogins
     *   }
     * })
     * 
     */
    create<T extends AspNetUserLoginsCreateArgs>(args: SelectSubset<T, AspNetUserLoginsCreateArgs<ExtArgs>>): Prisma__AspNetUserLoginsClient<$Result.GetResult<Prisma.$AspNetUserLoginsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AspNetUserLogins.
     * @param {AspNetUserLoginsCreateManyArgs} args - Arguments to create many AspNetUserLogins.
     * @example
     * // Create many AspNetUserLogins
     * const aspNetUserLogins = await prisma.aspNetUserLogins.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AspNetUserLoginsCreateManyArgs>(args?: SelectSubset<T, AspNetUserLoginsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AspNetUserLogins.
     * @param {AspNetUserLoginsDeleteArgs} args - Arguments to delete one AspNetUserLogins.
     * @example
     * // Delete one AspNetUserLogins
     * const AspNetUserLogins = await prisma.aspNetUserLogins.delete({
     *   where: {
     *     // ... filter to delete one AspNetUserLogins
     *   }
     * })
     * 
     */
    delete<T extends AspNetUserLoginsDeleteArgs>(args: SelectSubset<T, AspNetUserLoginsDeleteArgs<ExtArgs>>): Prisma__AspNetUserLoginsClient<$Result.GetResult<Prisma.$AspNetUserLoginsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AspNetUserLogins.
     * @param {AspNetUserLoginsUpdateArgs} args - Arguments to update one AspNetUserLogins.
     * @example
     * // Update one AspNetUserLogins
     * const aspNetUserLogins = await prisma.aspNetUserLogins.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AspNetUserLoginsUpdateArgs>(args: SelectSubset<T, AspNetUserLoginsUpdateArgs<ExtArgs>>): Prisma__AspNetUserLoginsClient<$Result.GetResult<Prisma.$AspNetUserLoginsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AspNetUserLogins.
     * @param {AspNetUserLoginsDeleteManyArgs} args - Arguments to filter AspNetUserLogins to delete.
     * @example
     * // Delete a few AspNetUserLogins
     * const { count } = await prisma.aspNetUserLogins.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AspNetUserLoginsDeleteManyArgs>(args?: SelectSubset<T, AspNetUserLoginsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AspNetUserLogins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetUserLoginsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AspNetUserLogins
     * const aspNetUserLogins = await prisma.aspNetUserLogins.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AspNetUserLoginsUpdateManyArgs>(args: SelectSubset<T, AspNetUserLoginsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AspNetUserLogins.
     * @param {AspNetUserLoginsUpsertArgs} args - Arguments to update or create a AspNetUserLogins.
     * @example
     * // Update or create a AspNetUserLogins
     * const aspNetUserLogins = await prisma.aspNetUserLogins.upsert({
     *   create: {
     *     // ... data to create a AspNetUserLogins
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AspNetUserLogins we want to update
     *   }
     * })
     */
    upsert<T extends AspNetUserLoginsUpsertArgs>(args: SelectSubset<T, AspNetUserLoginsUpsertArgs<ExtArgs>>): Prisma__AspNetUserLoginsClient<$Result.GetResult<Prisma.$AspNetUserLoginsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AspNetUserLogins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetUserLoginsCountArgs} args - Arguments to filter AspNetUserLogins to count.
     * @example
     * // Count the number of AspNetUserLogins
     * const count = await prisma.aspNetUserLogins.count({
     *   where: {
     *     // ... the filter for the AspNetUserLogins we want to count
     *   }
     * })
    **/
    count<T extends AspNetUserLoginsCountArgs>(
      args?: Subset<T, AspNetUserLoginsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AspNetUserLoginsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AspNetUserLogins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetUserLoginsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AspNetUserLoginsAggregateArgs>(args: Subset<T, AspNetUserLoginsAggregateArgs>): Prisma.PrismaPromise<GetAspNetUserLoginsAggregateType<T>>

    /**
     * Group by AspNetUserLogins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetUserLoginsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AspNetUserLoginsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AspNetUserLoginsGroupByArgs['orderBy'] }
        : { orderBy?: AspNetUserLoginsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AspNetUserLoginsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAspNetUserLoginsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AspNetUserLogins model
   */
  readonly fields: AspNetUserLoginsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AspNetUserLogins.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AspNetUserLoginsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    AspNetUsers<T extends AspNetUsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AspNetUsersDefaultArgs<ExtArgs>>): Prisma__AspNetUsersClient<$Result.GetResult<Prisma.$AspNetUsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AspNetUserLogins model
   */
  interface AspNetUserLoginsFieldRefs {
    readonly LoginProvider: FieldRef<"AspNetUserLogins", 'String'>
    readonly ProviderKey: FieldRef<"AspNetUserLogins", 'String'>
    readonly ProviderDisplayName: FieldRef<"AspNetUserLogins", 'String'>
    readonly UserId: FieldRef<"AspNetUserLogins", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AspNetUserLogins findUnique
   */
  export type AspNetUserLoginsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserLogins
     */
    select?: AspNetUserLoginsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspNetUserLogins
     */
    omit?: AspNetUserLoginsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserLoginsInclude<ExtArgs> | null
    /**
     * Filter, which AspNetUserLogins to fetch.
     */
    where: AspNetUserLoginsWhereUniqueInput
  }

  /**
   * AspNetUserLogins findUniqueOrThrow
   */
  export type AspNetUserLoginsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserLogins
     */
    select?: AspNetUserLoginsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspNetUserLogins
     */
    omit?: AspNetUserLoginsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserLoginsInclude<ExtArgs> | null
    /**
     * Filter, which AspNetUserLogins to fetch.
     */
    where: AspNetUserLoginsWhereUniqueInput
  }

  /**
   * AspNetUserLogins findFirst
   */
  export type AspNetUserLoginsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserLogins
     */
    select?: AspNetUserLoginsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspNetUserLogins
     */
    omit?: AspNetUserLoginsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserLoginsInclude<ExtArgs> | null
    /**
     * Filter, which AspNetUserLogins to fetch.
     */
    where?: AspNetUserLoginsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AspNetUserLogins to fetch.
     */
    orderBy?: AspNetUserLoginsOrderByWithRelationInput | AspNetUserLoginsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AspNetUserLogins.
     */
    cursor?: AspNetUserLoginsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AspNetUserLogins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AspNetUserLogins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AspNetUserLogins.
     */
    distinct?: AspNetUserLoginsScalarFieldEnum | AspNetUserLoginsScalarFieldEnum[]
  }

  /**
   * AspNetUserLogins findFirstOrThrow
   */
  export type AspNetUserLoginsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserLogins
     */
    select?: AspNetUserLoginsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspNetUserLogins
     */
    omit?: AspNetUserLoginsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserLoginsInclude<ExtArgs> | null
    /**
     * Filter, which AspNetUserLogins to fetch.
     */
    where?: AspNetUserLoginsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AspNetUserLogins to fetch.
     */
    orderBy?: AspNetUserLoginsOrderByWithRelationInput | AspNetUserLoginsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AspNetUserLogins.
     */
    cursor?: AspNetUserLoginsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AspNetUserLogins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AspNetUserLogins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AspNetUserLogins.
     */
    distinct?: AspNetUserLoginsScalarFieldEnum | AspNetUserLoginsScalarFieldEnum[]
  }

  /**
   * AspNetUserLogins findMany
   */
  export type AspNetUserLoginsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserLogins
     */
    select?: AspNetUserLoginsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspNetUserLogins
     */
    omit?: AspNetUserLoginsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserLoginsInclude<ExtArgs> | null
    /**
     * Filter, which AspNetUserLogins to fetch.
     */
    where?: AspNetUserLoginsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AspNetUserLogins to fetch.
     */
    orderBy?: AspNetUserLoginsOrderByWithRelationInput | AspNetUserLoginsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AspNetUserLogins.
     */
    cursor?: AspNetUserLoginsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AspNetUserLogins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AspNetUserLogins.
     */
    skip?: number
    distinct?: AspNetUserLoginsScalarFieldEnum | AspNetUserLoginsScalarFieldEnum[]
  }

  /**
   * AspNetUserLogins create
   */
  export type AspNetUserLoginsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserLogins
     */
    select?: AspNetUserLoginsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspNetUserLogins
     */
    omit?: AspNetUserLoginsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserLoginsInclude<ExtArgs> | null
    /**
     * The data needed to create a AspNetUserLogins.
     */
    data: XOR<AspNetUserLoginsCreateInput, AspNetUserLoginsUncheckedCreateInput>
  }

  /**
   * AspNetUserLogins createMany
   */
  export type AspNetUserLoginsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AspNetUserLogins.
     */
    data: AspNetUserLoginsCreateManyInput | AspNetUserLoginsCreateManyInput[]
  }

  /**
   * AspNetUserLogins update
   */
  export type AspNetUserLoginsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserLogins
     */
    select?: AspNetUserLoginsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspNetUserLogins
     */
    omit?: AspNetUserLoginsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserLoginsInclude<ExtArgs> | null
    /**
     * The data needed to update a AspNetUserLogins.
     */
    data: XOR<AspNetUserLoginsUpdateInput, AspNetUserLoginsUncheckedUpdateInput>
    /**
     * Choose, which AspNetUserLogins to update.
     */
    where: AspNetUserLoginsWhereUniqueInput
  }

  /**
   * AspNetUserLogins updateMany
   */
  export type AspNetUserLoginsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AspNetUserLogins.
     */
    data: XOR<AspNetUserLoginsUpdateManyMutationInput, AspNetUserLoginsUncheckedUpdateManyInput>
    /**
     * Filter which AspNetUserLogins to update
     */
    where?: AspNetUserLoginsWhereInput
    /**
     * Limit how many AspNetUserLogins to update.
     */
    limit?: number
  }

  /**
   * AspNetUserLogins upsert
   */
  export type AspNetUserLoginsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserLogins
     */
    select?: AspNetUserLoginsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspNetUserLogins
     */
    omit?: AspNetUserLoginsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserLoginsInclude<ExtArgs> | null
    /**
     * The filter to search for the AspNetUserLogins to update in case it exists.
     */
    where: AspNetUserLoginsWhereUniqueInput
    /**
     * In case the AspNetUserLogins found by the `where` argument doesn't exist, create a new AspNetUserLogins with this data.
     */
    create: XOR<AspNetUserLoginsCreateInput, AspNetUserLoginsUncheckedCreateInput>
    /**
     * In case the AspNetUserLogins was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AspNetUserLoginsUpdateInput, AspNetUserLoginsUncheckedUpdateInput>
  }

  /**
   * AspNetUserLogins delete
   */
  export type AspNetUserLoginsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserLogins
     */
    select?: AspNetUserLoginsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspNetUserLogins
     */
    omit?: AspNetUserLoginsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserLoginsInclude<ExtArgs> | null
    /**
     * Filter which AspNetUserLogins to delete.
     */
    where: AspNetUserLoginsWhereUniqueInput
  }

  /**
   * AspNetUserLogins deleteMany
   */
  export type AspNetUserLoginsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AspNetUserLogins to delete
     */
    where?: AspNetUserLoginsWhereInput
    /**
     * Limit how many AspNetUserLogins to delete.
     */
    limit?: number
  }

  /**
   * AspNetUserLogins without action
   */
  export type AspNetUserLoginsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserLogins
     */
    select?: AspNetUserLoginsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspNetUserLogins
     */
    omit?: AspNetUserLoginsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserLoginsInclude<ExtArgs> | null
  }


  /**
   * Model AspNetUserRoles
   */

  export type AggregateAspNetUserRoles = {
    _count: AspNetUserRolesCountAggregateOutputType | null
    _min: AspNetUserRolesMinAggregateOutputType | null
    _max: AspNetUserRolesMaxAggregateOutputType | null
  }

  export type AspNetUserRolesMinAggregateOutputType = {
    UserId: string | null
    RoleId: string | null
  }

  export type AspNetUserRolesMaxAggregateOutputType = {
    UserId: string | null
    RoleId: string | null
  }

  export type AspNetUserRolesCountAggregateOutputType = {
    UserId: number
    RoleId: number
    _all: number
  }


  export type AspNetUserRolesMinAggregateInputType = {
    UserId?: true
    RoleId?: true
  }

  export type AspNetUserRolesMaxAggregateInputType = {
    UserId?: true
    RoleId?: true
  }

  export type AspNetUserRolesCountAggregateInputType = {
    UserId?: true
    RoleId?: true
    _all?: true
  }

  export type AspNetUserRolesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AspNetUserRoles to aggregate.
     */
    where?: AspNetUserRolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AspNetUserRoles to fetch.
     */
    orderBy?: AspNetUserRolesOrderByWithRelationInput | AspNetUserRolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AspNetUserRolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AspNetUserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AspNetUserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AspNetUserRoles
    **/
    _count?: true | AspNetUserRolesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AspNetUserRolesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AspNetUserRolesMaxAggregateInputType
  }

  export type GetAspNetUserRolesAggregateType<T extends AspNetUserRolesAggregateArgs> = {
        [P in keyof T & keyof AggregateAspNetUserRoles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAspNetUserRoles[P]>
      : GetScalarType<T[P], AggregateAspNetUserRoles[P]>
  }




  export type AspNetUserRolesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AspNetUserRolesWhereInput
    orderBy?: AspNetUserRolesOrderByWithAggregationInput | AspNetUserRolesOrderByWithAggregationInput[]
    by: AspNetUserRolesScalarFieldEnum[] | AspNetUserRolesScalarFieldEnum
    having?: AspNetUserRolesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AspNetUserRolesCountAggregateInputType | true
    _min?: AspNetUserRolesMinAggregateInputType
    _max?: AspNetUserRolesMaxAggregateInputType
  }

  export type AspNetUserRolesGroupByOutputType = {
    UserId: string
    RoleId: string
    _count: AspNetUserRolesCountAggregateOutputType | null
    _min: AspNetUserRolesMinAggregateOutputType | null
    _max: AspNetUserRolesMaxAggregateOutputType | null
  }

  type GetAspNetUserRolesGroupByPayload<T extends AspNetUserRolesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AspNetUserRolesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AspNetUserRolesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AspNetUserRolesGroupByOutputType[P]>
            : GetScalarType<T[P], AspNetUserRolesGroupByOutputType[P]>
        }
      >
    >


  export type AspNetUserRolesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    UserId?: boolean
    RoleId?: boolean
    AspNetRoles?: boolean | AspNetRolesDefaultArgs<ExtArgs>
    AspNetUsers?: boolean | AspNetUsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aspNetUserRoles"]>



  export type AspNetUserRolesSelectScalar = {
    UserId?: boolean
    RoleId?: boolean
  }

  export type AspNetUserRolesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"UserId" | "RoleId", ExtArgs["result"]["aspNetUserRoles"]>
  export type AspNetUserRolesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AspNetRoles?: boolean | AspNetRolesDefaultArgs<ExtArgs>
    AspNetUsers?: boolean | AspNetUsersDefaultArgs<ExtArgs>
  }

  export type $AspNetUserRolesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AspNetUserRoles"
    objects: {
      AspNetRoles: Prisma.$AspNetRolesPayload<ExtArgs>
      AspNetUsers: Prisma.$AspNetUsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      UserId: string
      RoleId: string
    }, ExtArgs["result"]["aspNetUserRoles"]>
    composites: {}
  }

  type AspNetUserRolesGetPayload<S extends boolean | null | undefined | AspNetUserRolesDefaultArgs> = $Result.GetResult<Prisma.$AspNetUserRolesPayload, S>

  type AspNetUserRolesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AspNetUserRolesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AspNetUserRolesCountAggregateInputType | true
    }

  export interface AspNetUserRolesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AspNetUserRoles'], meta: { name: 'AspNetUserRoles' } }
    /**
     * Find zero or one AspNetUserRoles that matches the filter.
     * @param {AspNetUserRolesFindUniqueArgs} args - Arguments to find a AspNetUserRoles
     * @example
     * // Get one AspNetUserRoles
     * const aspNetUserRoles = await prisma.aspNetUserRoles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AspNetUserRolesFindUniqueArgs>(args: SelectSubset<T, AspNetUserRolesFindUniqueArgs<ExtArgs>>): Prisma__AspNetUserRolesClient<$Result.GetResult<Prisma.$AspNetUserRolesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AspNetUserRoles that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AspNetUserRolesFindUniqueOrThrowArgs} args - Arguments to find a AspNetUserRoles
     * @example
     * // Get one AspNetUserRoles
     * const aspNetUserRoles = await prisma.aspNetUserRoles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AspNetUserRolesFindUniqueOrThrowArgs>(args: SelectSubset<T, AspNetUserRolesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AspNetUserRolesClient<$Result.GetResult<Prisma.$AspNetUserRolesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AspNetUserRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetUserRolesFindFirstArgs} args - Arguments to find a AspNetUserRoles
     * @example
     * // Get one AspNetUserRoles
     * const aspNetUserRoles = await prisma.aspNetUserRoles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AspNetUserRolesFindFirstArgs>(args?: SelectSubset<T, AspNetUserRolesFindFirstArgs<ExtArgs>>): Prisma__AspNetUserRolesClient<$Result.GetResult<Prisma.$AspNetUserRolesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AspNetUserRoles that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetUserRolesFindFirstOrThrowArgs} args - Arguments to find a AspNetUserRoles
     * @example
     * // Get one AspNetUserRoles
     * const aspNetUserRoles = await prisma.aspNetUserRoles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AspNetUserRolesFindFirstOrThrowArgs>(args?: SelectSubset<T, AspNetUserRolesFindFirstOrThrowArgs<ExtArgs>>): Prisma__AspNetUserRolesClient<$Result.GetResult<Prisma.$AspNetUserRolesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AspNetUserRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetUserRolesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AspNetUserRoles
     * const aspNetUserRoles = await prisma.aspNetUserRoles.findMany()
     * 
     * // Get first 10 AspNetUserRoles
     * const aspNetUserRoles = await prisma.aspNetUserRoles.findMany({ take: 10 })
     * 
     * // Only select the `UserId`
     * const aspNetUserRolesWithUserIdOnly = await prisma.aspNetUserRoles.findMany({ select: { UserId: true } })
     * 
     */
    findMany<T extends AspNetUserRolesFindManyArgs>(args?: SelectSubset<T, AspNetUserRolesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AspNetUserRolesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AspNetUserRoles.
     * @param {AspNetUserRolesCreateArgs} args - Arguments to create a AspNetUserRoles.
     * @example
     * // Create one AspNetUserRoles
     * const AspNetUserRoles = await prisma.aspNetUserRoles.create({
     *   data: {
     *     // ... data to create a AspNetUserRoles
     *   }
     * })
     * 
     */
    create<T extends AspNetUserRolesCreateArgs>(args: SelectSubset<T, AspNetUserRolesCreateArgs<ExtArgs>>): Prisma__AspNetUserRolesClient<$Result.GetResult<Prisma.$AspNetUserRolesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AspNetUserRoles.
     * @param {AspNetUserRolesCreateManyArgs} args - Arguments to create many AspNetUserRoles.
     * @example
     * // Create many AspNetUserRoles
     * const aspNetUserRoles = await prisma.aspNetUserRoles.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AspNetUserRolesCreateManyArgs>(args?: SelectSubset<T, AspNetUserRolesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AspNetUserRoles.
     * @param {AspNetUserRolesDeleteArgs} args - Arguments to delete one AspNetUserRoles.
     * @example
     * // Delete one AspNetUserRoles
     * const AspNetUserRoles = await prisma.aspNetUserRoles.delete({
     *   where: {
     *     // ... filter to delete one AspNetUserRoles
     *   }
     * })
     * 
     */
    delete<T extends AspNetUserRolesDeleteArgs>(args: SelectSubset<T, AspNetUserRolesDeleteArgs<ExtArgs>>): Prisma__AspNetUserRolesClient<$Result.GetResult<Prisma.$AspNetUserRolesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AspNetUserRoles.
     * @param {AspNetUserRolesUpdateArgs} args - Arguments to update one AspNetUserRoles.
     * @example
     * // Update one AspNetUserRoles
     * const aspNetUserRoles = await prisma.aspNetUserRoles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AspNetUserRolesUpdateArgs>(args: SelectSubset<T, AspNetUserRolesUpdateArgs<ExtArgs>>): Prisma__AspNetUserRolesClient<$Result.GetResult<Prisma.$AspNetUserRolesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AspNetUserRoles.
     * @param {AspNetUserRolesDeleteManyArgs} args - Arguments to filter AspNetUserRoles to delete.
     * @example
     * // Delete a few AspNetUserRoles
     * const { count } = await prisma.aspNetUserRoles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AspNetUserRolesDeleteManyArgs>(args?: SelectSubset<T, AspNetUserRolesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AspNetUserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetUserRolesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AspNetUserRoles
     * const aspNetUserRoles = await prisma.aspNetUserRoles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AspNetUserRolesUpdateManyArgs>(args: SelectSubset<T, AspNetUserRolesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AspNetUserRoles.
     * @param {AspNetUserRolesUpsertArgs} args - Arguments to update or create a AspNetUserRoles.
     * @example
     * // Update or create a AspNetUserRoles
     * const aspNetUserRoles = await prisma.aspNetUserRoles.upsert({
     *   create: {
     *     // ... data to create a AspNetUserRoles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AspNetUserRoles we want to update
     *   }
     * })
     */
    upsert<T extends AspNetUserRolesUpsertArgs>(args: SelectSubset<T, AspNetUserRolesUpsertArgs<ExtArgs>>): Prisma__AspNetUserRolesClient<$Result.GetResult<Prisma.$AspNetUserRolesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AspNetUserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetUserRolesCountArgs} args - Arguments to filter AspNetUserRoles to count.
     * @example
     * // Count the number of AspNetUserRoles
     * const count = await prisma.aspNetUserRoles.count({
     *   where: {
     *     // ... the filter for the AspNetUserRoles we want to count
     *   }
     * })
    **/
    count<T extends AspNetUserRolesCountArgs>(
      args?: Subset<T, AspNetUserRolesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AspNetUserRolesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AspNetUserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetUserRolesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AspNetUserRolesAggregateArgs>(args: Subset<T, AspNetUserRolesAggregateArgs>): Prisma.PrismaPromise<GetAspNetUserRolesAggregateType<T>>

    /**
     * Group by AspNetUserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetUserRolesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AspNetUserRolesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AspNetUserRolesGroupByArgs['orderBy'] }
        : { orderBy?: AspNetUserRolesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AspNetUserRolesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAspNetUserRolesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AspNetUserRoles model
   */
  readonly fields: AspNetUserRolesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AspNetUserRoles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AspNetUserRolesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    AspNetRoles<T extends AspNetRolesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AspNetRolesDefaultArgs<ExtArgs>>): Prisma__AspNetRolesClient<$Result.GetResult<Prisma.$AspNetRolesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    AspNetUsers<T extends AspNetUsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AspNetUsersDefaultArgs<ExtArgs>>): Prisma__AspNetUsersClient<$Result.GetResult<Prisma.$AspNetUsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AspNetUserRoles model
   */
  interface AspNetUserRolesFieldRefs {
    readonly UserId: FieldRef<"AspNetUserRoles", 'String'>
    readonly RoleId: FieldRef<"AspNetUserRoles", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AspNetUserRoles findUnique
   */
  export type AspNetUserRolesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserRoles
     */
    select?: AspNetUserRolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspNetUserRoles
     */
    omit?: AspNetUserRolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserRolesInclude<ExtArgs> | null
    /**
     * Filter, which AspNetUserRoles to fetch.
     */
    where: AspNetUserRolesWhereUniqueInput
  }

  /**
   * AspNetUserRoles findUniqueOrThrow
   */
  export type AspNetUserRolesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserRoles
     */
    select?: AspNetUserRolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspNetUserRoles
     */
    omit?: AspNetUserRolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserRolesInclude<ExtArgs> | null
    /**
     * Filter, which AspNetUserRoles to fetch.
     */
    where: AspNetUserRolesWhereUniqueInput
  }

  /**
   * AspNetUserRoles findFirst
   */
  export type AspNetUserRolesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserRoles
     */
    select?: AspNetUserRolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspNetUserRoles
     */
    omit?: AspNetUserRolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserRolesInclude<ExtArgs> | null
    /**
     * Filter, which AspNetUserRoles to fetch.
     */
    where?: AspNetUserRolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AspNetUserRoles to fetch.
     */
    orderBy?: AspNetUserRolesOrderByWithRelationInput | AspNetUserRolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AspNetUserRoles.
     */
    cursor?: AspNetUserRolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AspNetUserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AspNetUserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AspNetUserRoles.
     */
    distinct?: AspNetUserRolesScalarFieldEnum | AspNetUserRolesScalarFieldEnum[]
  }

  /**
   * AspNetUserRoles findFirstOrThrow
   */
  export type AspNetUserRolesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserRoles
     */
    select?: AspNetUserRolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspNetUserRoles
     */
    omit?: AspNetUserRolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserRolesInclude<ExtArgs> | null
    /**
     * Filter, which AspNetUserRoles to fetch.
     */
    where?: AspNetUserRolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AspNetUserRoles to fetch.
     */
    orderBy?: AspNetUserRolesOrderByWithRelationInput | AspNetUserRolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AspNetUserRoles.
     */
    cursor?: AspNetUserRolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AspNetUserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AspNetUserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AspNetUserRoles.
     */
    distinct?: AspNetUserRolesScalarFieldEnum | AspNetUserRolesScalarFieldEnum[]
  }

  /**
   * AspNetUserRoles findMany
   */
  export type AspNetUserRolesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserRoles
     */
    select?: AspNetUserRolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspNetUserRoles
     */
    omit?: AspNetUserRolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserRolesInclude<ExtArgs> | null
    /**
     * Filter, which AspNetUserRoles to fetch.
     */
    where?: AspNetUserRolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AspNetUserRoles to fetch.
     */
    orderBy?: AspNetUserRolesOrderByWithRelationInput | AspNetUserRolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AspNetUserRoles.
     */
    cursor?: AspNetUserRolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AspNetUserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AspNetUserRoles.
     */
    skip?: number
    distinct?: AspNetUserRolesScalarFieldEnum | AspNetUserRolesScalarFieldEnum[]
  }

  /**
   * AspNetUserRoles create
   */
  export type AspNetUserRolesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserRoles
     */
    select?: AspNetUserRolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspNetUserRoles
     */
    omit?: AspNetUserRolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserRolesInclude<ExtArgs> | null
    /**
     * The data needed to create a AspNetUserRoles.
     */
    data: XOR<AspNetUserRolesCreateInput, AspNetUserRolesUncheckedCreateInput>
  }

  /**
   * AspNetUserRoles createMany
   */
  export type AspNetUserRolesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AspNetUserRoles.
     */
    data: AspNetUserRolesCreateManyInput | AspNetUserRolesCreateManyInput[]
  }

  /**
   * AspNetUserRoles update
   */
  export type AspNetUserRolesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserRoles
     */
    select?: AspNetUserRolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspNetUserRoles
     */
    omit?: AspNetUserRolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserRolesInclude<ExtArgs> | null
    /**
     * The data needed to update a AspNetUserRoles.
     */
    data: XOR<AspNetUserRolesUpdateInput, AspNetUserRolesUncheckedUpdateInput>
    /**
     * Choose, which AspNetUserRoles to update.
     */
    where: AspNetUserRolesWhereUniqueInput
  }

  /**
   * AspNetUserRoles updateMany
   */
  export type AspNetUserRolesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AspNetUserRoles.
     */
    data: XOR<AspNetUserRolesUpdateManyMutationInput, AspNetUserRolesUncheckedUpdateManyInput>
    /**
     * Filter which AspNetUserRoles to update
     */
    where?: AspNetUserRolesWhereInput
    /**
     * Limit how many AspNetUserRoles to update.
     */
    limit?: number
  }

  /**
   * AspNetUserRoles upsert
   */
  export type AspNetUserRolesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserRoles
     */
    select?: AspNetUserRolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspNetUserRoles
     */
    omit?: AspNetUserRolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserRolesInclude<ExtArgs> | null
    /**
     * The filter to search for the AspNetUserRoles to update in case it exists.
     */
    where: AspNetUserRolesWhereUniqueInput
    /**
     * In case the AspNetUserRoles found by the `where` argument doesn't exist, create a new AspNetUserRoles with this data.
     */
    create: XOR<AspNetUserRolesCreateInput, AspNetUserRolesUncheckedCreateInput>
    /**
     * In case the AspNetUserRoles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AspNetUserRolesUpdateInput, AspNetUserRolesUncheckedUpdateInput>
  }

  /**
   * AspNetUserRoles delete
   */
  export type AspNetUserRolesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserRoles
     */
    select?: AspNetUserRolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspNetUserRoles
     */
    omit?: AspNetUserRolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserRolesInclude<ExtArgs> | null
    /**
     * Filter which AspNetUserRoles to delete.
     */
    where: AspNetUserRolesWhereUniqueInput
  }

  /**
   * AspNetUserRoles deleteMany
   */
  export type AspNetUserRolesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AspNetUserRoles to delete
     */
    where?: AspNetUserRolesWhereInput
    /**
     * Limit how many AspNetUserRoles to delete.
     */
    limit?: number
  }

  /**
   * AspNetUserRoles without action
   */
  export type AspNetUserRolesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserRoles
     */
    select?: AspNetUserRolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspNetUserRoles
     */
    omit?: AspNetUserRolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserRolesInclude<ExtArgs> | null
  }


  /**
   * Model AspNetUsers
   */

  export type AggregateAspNetUsers = {
    _count: AspNetUsersCountAggregateOutputType | null
    _avg: AspNetUsersAvgAggregateOutputType | null
    _sum: AspNetUsersSumAggregateOutputType | null
    _min: AspNetUsersMinAggregateOutputType | null
    _max: AspNetUsersMaxAggregateOutputType | null
  }

  export type AspNetUsersAvgAggregateOutputType = {
    AccessFailedCount: number | null
  }

  export type AspNetUsersSumAggregateOutputType = {
    AccessFailedCount: number | null
  }

  export type AspNetUsersMinAggregateOutputType = {
    Id: string | null
    UserName: string | null
    NormalizedUserName: string | null
    Email: string | null
    NormalizedEmail: string | null
    EmailConfirmed: boolean | null
    PasswordHash: string | null
    SecurityStamp: string | null
    ConcurrencyStamp: string | null
    PhoneNumber: string | null
    PhoneNumberConfirmed: boolean | null
    TwoFactorEnabled: boolean | null
    LockoutEnd: Date | null
    LockoutEnabled: boolean | null
    AccessFailedCount: number | null
    PasswordValidUntil: Date | null
    DeviceId: string | null
    FcmToken: string | null
    FullName: string | null
  }

  export type AspNetUsersMaxAggregateOutputType = {
    Id: string | null
    UserName: string | null
    NormalizedUserName: string | null
    Email: string | null
    NormalizedEmail: string | null
    EmailConfirmed: boolean | null
    PasswordHash: string | null
    SecurityStamp: string | null
    ConcurrencyStamp: string | null
    PhoneNumber: string | null
    PhoneNumberConfirmed: boolean | null
    TwoFactorEnabled: boolean | null
    LockoutEnd: Date | null
    LockoutEnabled: boolean | null
    AccessFailedCount: number | null
    PasswordValidUntil: Date | null
    DeviceId: string | null
    FcmToken: string | null
    FullName: string | null
  }

  export type AspNetUsersCountAggregateOutputType = {
    Id: number
    UserName: number
    NormalizedUserName: number
    Email: number
    NormalizedEmail: number
    EmailConfirmed: number
    PasswordHash: number
    SecurityStamp: number
    ConcurrencyStamp: number
    PhoneNumber: number
    PhoneNumberConfirmed: number
    TwoFactorEnabled: number
    LockoutEnd: number
    LockoutEnabled: number
    AccessFailedCount: number
    PasswordValidUntil: number
    DeviceId: number
    FcmToken: number
    FullName: number
    _all: number
  }


  export type AspNetUsersAvgAggregateInputType = {
    AccessFailedCount?: true
  }

  export type AspNetUsersSumAggregateInputType = {
    AccessFailedCount?: true
  }

  export type AspNetUsersMinAggregateInputType = {
    Id?: true
    UserName?: true
    NormalizedUserName?: true
    Email?: true
    NormalizedEmail?: true
    EmailConfirmed?: true
    PasswordHash?: true
    SecurityStamp?: true
    ConcurrencyStamp?: true
    PhoneNumber?: true
    PhoneNumberConfirmed?: true
    TwoFactorEnabled?: true
    LockoutEnd?: true
    LockoutEnabled?: true
    AccessFailedCount?: true
    PasswordValidUntil?: true
    DeviceId?: true
    FcmToken?: true
    FullName?: true
  }

  export type AspNetUsersMaxAggregateInputType = {
    Id?: true
    UserName?: true
    NormalizedUserName?: true
    Email?: true
    NormalizedEmail?: true
    EmailConfirmed?: true
    PasswordHash?: true
    SecurityStamp?: true
    ConcurrencyStamp?: true
    PhoneNumber?: true
    PhoneNumberConfirmed?: true
    TwoFactorEnabled?: true
    LockoutEnd?: true
    LockoutEnabled?: true
    AccessFailedCount?: true
    PasswordValidUntil?: true
    DeviceId?: true
    FcmToken?: true
    FullName?: true
  }

  export type AspNetUsersCountAggregateInputType = {
    Id?: true
    UserName?: true
    NormalizedUserName?: true
    Email?: true
    NormalizedEmail?: true
    EmailConfirmed?: true
    PasswordHash?: true
    SecurityStamp?: true
    ConcurrencyStamp?: true
    PhoneNumber?: true
    PhoneNumberConfirmed?: true
    TwoFactorEnabled?: true
    LockoutEnd?: true
    LockoutEnabled?: true
    AccessFailedCount?: true
    PasswordValidUntil?: true
    DeviceId?: true
    FcmToken?: true
    FullName?: true
    _all?: true
  }

  export type AspNetUsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AspNetUsers to aggregate.
     */
    where?: AspNetUsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AspNetUsers to fetch.
     */
    orderBy?: AspNetUsersOrderByWithRelationInput | AspNetUsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AspNetUsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AspNetUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AspNetUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AspNetUsers
    **/
    _count?: true | AspNetUsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AspNetUsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AspNetUsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AspNetUsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AspNetUsersMaxAggregateInputType
  }

  export type GetAspNetUsersAggregateType<T extends AspNetUsersAggregateArgs> = {
        [P in keyof T & keyof AggregateAspNetUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAspNetUsers[P]>
      : GetScalarType<T[P], AggregateAspNetUsers[P]>
  }




  export type AspNetUsersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AspNetUsersWhereInput
    orderBy?: AspNetUsersOrderByWithAggregationInput | AspNetUsersOrderByWithAggregationInput[]
    by: AspNetUsersScalarFieldEnum[] | AspNetUsersScalarFieldEnum
    having?: AspNetUsersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AspNetUsersCountAggregateInputType | true
    _avg?: AspNetUsersAvgAggregateInputType
    _sum?: AspNetUsersSumAggregateInputType
    _min?: AspNetUsersMinAggregateInputType
    _max?: AspNetUsersMaxAggregateInputType
  }

  export type AspNetUsersGroupByOutputType = {
    Id: string
    UserName: string | null
    NormalizedUserName: string | null
    Email: string | null
    NormalizedEmail: string | null
    EmailConfirmed: boolean
    PasswordHash: string | null
    SecurityStamp: string | null
    ConcurrencyStamp: string | null
    PhoneNumber: string | null
    PhoneNumberConfirmed: boolean
    TwoFactorEnabled: boolean
    LockoutEnd: Date | null
    LockoutEnabled: boolean
    AccessFailedCount: number
    PasswordValidUntil: Date
    DeviceId: string | null
    FcmToken: string | null
    FullName: string | null
    _count: AspNetUsersCountAggregateOutputType | null
    _avg: AspNetUsersAvgAggregateOutputType | null
    _sum: AspNetUsersSumAggregateOutputType | null
    _min: AspNetUsersMinAggregateOutputType | null
    _max: AspNetUsersMaxAggregateOutputType | null
  }

  type GetAspNetUsersGroupByPayload<T extends AspNetUsersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AspNetUsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AspNetUsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AspNetUsersGroupByOutputType[P]>
            : GetScalarType<T[P], AspNetUsersGroupByOutputType[P]>
        }
      >
    >


  export type AspNetUsersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    UserName?: boolean
    NormalizedUserName?: boolean
    Email?: boolean
    NormalizedEmail?: boolean
    EmailConfirmed?: boolean
    PasswordHash?: boolean
    SecurityStamp?: boolean
    ConcurrencyStamp?: boolean
    PhoneNumber?: boolean
    PhoneNumberConfirmed?: boolean
    TwoFactorEnabled?: boolean
    LockoutEnd?: boolean
    LockoutEnabled?: boolean
    AccessFailedCount?: boolean
    PasswordValidUntil?: boolean
    DeviceId?: boolean
    FcmToken?: boolean
    FullName?: boolean
    AspNetUserClaims?: boolean | AspNetUsers$AspNetUserClaimsArgs<ExtArgs>
    AspNetUserLogins?: boolean | AspNetUsers$AspNetUserLoginsArgs<ExtArgs>
    AspNetUserRoles?: boolean | AspNetUsers$AspNetUserRolesArgs<ExtArgs>
    AspNetUserTokens?: boolean | AspNetUsers$AspNetUserTokensArgs<ExtArgs>
    _count?: boolean | AspNetUsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aspNetUsers"]>



  export type AspNetUsersSelectScalar = {
    Id?: boolean
    UserName?: boolean
    NormalizedUserName?: boolean
    Email?: boolean
    NormalizedEmail?: boolean
    EmailConfirmed?: boolean
    PasswordHash?: boolean
    SecurityStamp?: boolean
    ConcurrencyStamp?: boolean
    PhoneNumber?: boolean
    PhoneNumberConfirmed?: boolean
    TwoFactorEnabled?: boolean
    LockoutEnd?: boolean
    LockoutEnabled?: boolean
    AccessFailedCount?: boolean
    PasswordValidUntil?: boolean
    DeviceId?: boolean
    FcmToken?: boolean
    FullName?: boolean
  }

  export type AspNetUsersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Id" | "UserName" | "NormalizedUserName" | "Email" | "NormalizedEmail" | "EmailConfirmed" | "PasswordHash" | "SecurityStamp" | "ConcurrencyStamp" | "PhoneNumber" | "PhoneNumberConfirmed" | "TwoFactorEnabled" | "LockoutEnd" | "LockoutEnabled" | "AccessFailedCount" | "PasswordValidUntil" | "DeviceId" | "FcmToken" | "FullName", ExtArgs["result"]["aspNetUsers"]>
  export type AspNetUsersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AspNetUserClaims?: boolean | AspNetUsers$AspNetUserClaimsArgs<ExtArgs>
    AspNetUserLogins?: boolean | AspNetUsers$AspNetUserLoginsArgs<ExtArgs>
    AspNetUserRoles?: boolean | AspNetUsers$AspNetUserRolesArgs<ExtArgs>
    AspNetUserTokens?: boolean | AspNetUsers$AspNetUserTokensArgs<ExtArgs>
    _count?: boolean | AspNetUsersCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AspNetUsersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AspNetUsers"
    objects: {
      AspNetUserClaims: Prisma.$AspNetUserClaimsPayload<ExtArgs>[]
      AspNetUserLogins: Prisma.$AspNetUserLoginsPayload<ExtArgs>[]
      AspNetUserRoles: Prisma.$AspNetUserRolesPayload<ExtArgs>[]
      AspNetUserTokens: Prisma.$AspNetUserTokensPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      Id: string
      UserName: string | null
      NormalizedUserName: string | null
      Email: string | null
      NormalizedEmail: string | null
      EmailConfirmed: boolean
      PasswordHash: string | null
      SecurityStamp: string | null
      ConcurrencyStamp: string | null
      PhoneNumber: string | null
      PhoneNumberConfirmed: boolean
      TwoFactorEnabled: boolean
      LockoutEnd: Date | null
      LockoutEnabled: boolean
      AccessFailedCount: number
      PasswordValidUntil: Date
      DeviceId: string | null
      FcmToken: string | null
      FullName: string | null
    }, ExtArgs["result"]["aspNetUsers"]>
    composites: {}
  }

  type AspNetUsersGetPayload<S extends boolean | null | undefined | AspNetUsersDefaultArgs> = $Result.GetResult<Prisma.$AspNetUsersPayload, S>

  type AspNetUsersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AspNetUsersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AspNetUsersCountAggregateInputType | true
    }

  export interface AspNetUsersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AspNetUsers'], meta: { name: 'AspNetUsers' } }
    /**
     * Find zero or one AspNetUsers that matches the filter.
     * @param {AspNetUsersFindUniqueArgs} args - Arguments to find a AspNetUsers
     * @example
     * // Get one AspNetUsers
     * const aspNetUsers = await prisma.aspNetUsers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AspNetUsersFindUniqueArgs>(args: SelectSubset<T, AspNetUsersFindUniqueArgs<ExtArgs>>): Prisma__AspNetUsersClient<$Result.GetResult<Prisma.$AspNetUsersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AspNetUsers that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AspNetUsersFindUniqueOrThrowArgs} args - Arguments to find a AspNetUsers
     * @example
     * // Get one AspNetUsers
     * const aspNetUsers = await prisma.aspNetUsers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AspNetUsersFindUniqueOrThrowArgs>(args: SelectSubset<T, AspNetUsersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AspNetUsersClient<$Result.GetResult<Prisma.$AspNetUsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AspNetUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetUsersFindFirstArgs} args - Arguments to find a AspNetUsers
     * @example
     * // Get one AspNetUsers
     * const aspNetUsers = await prisma.aspNetUsers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AspNetUsersFindFirstArgs>(args?: SelectSubset<T, AspNetUsersFindFirstArgs<ExtArgs>>): Prisma__AspNetUsersClient<$Result.GetResult<Prisma.$AspNetUsersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AspNetUsers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetUsersFindFirstOrThrowArgs} args - Arguments to find a AspNetUsers
     * @example
     * // Get one AspNetUsers
     * const aspNetUsers = await prisma.aspNetUsers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AspNetUsersFindFirstOrThrowArgs>(args?: SelectSubset<T, AspNetUsersFindFirstOrThrowArgs<ExtArgs>>): Prisma__AspNetUsersClient<$Result.GetResult<Prisma.$AspNetUsersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AspNetUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetUsersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AspNetUsers
     * const aspNetUsers = await prisma.aspNetUsers.findMany()
     * 
     * // Get first 10 AspNetUsers
     * const aspNetUsers = await prisma.aspNetUsers.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const aspNetUsersWithIdOnly = await prisma.aspNetUsers.findMany({ select: { Id: true } })
     * 
     */
    findMany<T extends AspNetUsersFindManyArgs>(args?: SelectSubset<T, AspNetUsersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AspNetUsersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AspNetUsers.
     * @param {AspNetUsersCreateArgs} args - Arguments to create a AspNetUsers.
     * @example
     * // Create one AspNetUsers
     * const AspNetUsers = await prisma.aspNetUsers.create({
     *   data: {
     *     // ... data to create a AspNetUsers
     *   }
     * })
     * 
     */
    create<T extends AspNetUsersCreateArgs>(args: SelectSubset<T, AspNetUsersCreateArgs<ExtArgs>>): Prisma__AspNetUsersClient<$Result.GetResult<Prisma.$AspNetUsersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AspNetUsers.
     * @param {AspNetUsersCreateManyArgs} args - Arguments to create many AspNetUsers.
     * @example
     * // Create many AspNetUsers
     * const aspNetUsers = await prisma.aspNetUsers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AspNetUsersCreateManyArgs>(args?: SelectSubset<T, AspNetUsersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AspNetUsers.
     * @param {AspNetUsersDeleteArgs} args - Arguments to delete one AspNetUsers.
     * @example
     * // Delete one AspNetUsers
     * const AspNetUsers = await prisma.aspNetUsers.delete({
     *   where: {
     *     // ... filter to delete one AspNetUsers
     *   }
     * })
     * 
     */
    delete<T extends AspNetUsersDeleteArgs>(args: SelectSubset<T, AspNetUsersDeleteArgs<ExtArgs>>): Prisma__AspNetUsersClient<$Result.GetResult<Prisma.$AspNetUsersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AspNetUsers.
     * @param {AspNetUsersUpdateArgs} args - Arguments to update one AspNetUsers.
     * @example
     * // Update one AspNetUsers
     * const aspNetUsers = await prisma.aspNetUsers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AspNetUsersUpdateArgs>(args: SelectSubset<T, AspNetUsersUpdateArgs<ExtArgs>>): Prisma__AspNetUsersClient<$Result.GetResult<Prisma.$AspNetUsersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AspNetUsers.
     * @param {AspNetUsersDeleteManyArgs} args - Arguments to filter AspNetUsers to delete.
     * @example
     * // Delete a few AspNetUsers
     * const { count } = await prisma.aspNetUsers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AspNetUsersDeleteManyArgs>(args?: SelectSubset<T, AspNetUsersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AspNetUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetUsersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AspNetUsers
     * const aspNetUsers = await prisma.aspNetUsers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AspNetUsersUpdateManyArgs>(args: SelectSubset<T, AspNetUsersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AspNetUsers.
     * @param {AspNetUsersUpsertArgs} args - Arguments to update or create a AspNetUsers.
     * @example
     * // Update or create a AspNetUsers
     * const aspNetUsers = await prisma.aspNetUsers.upsert({
     *   create: {
     *     // ... data to create a AspNetUsers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AspNetUsers we want to update
     *   }
     * })
     */
    upsert<T extends AspNetUsersUpsertArgs>(args: SelectSubset<T, AspNetUsersUpsertArgs<ExtArgs>>): Prisma__AspNetUsersClient<$Result.GetResult<Prisma.$AspNetUsersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AspNetUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetUsersCountArgs} args - Arguments to filter AspNetUsers to count.
     * @example
     * // Count the number of AspNetUsers
     * const count = await prisma.aspNetUsers.count({
     *   where: {
     *     // ... the filter for the AspNetUsers we want to count
     *   }
     * })
    **/
    count<T extends AspNetUsersCountArgs>(
      args?: Subset<T, AspNetUsersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AspNetUsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AspNetUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetUsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AspNetUsersAggregateArgs>(args: Subset<T, AspNetUsersAggregateArgs>): Prisma.PrismaPromise<GetAspNetUsersAggregateType<T>>

    /**
     * Group by AspNetUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetUsersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AspNetUsersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AspNetUsersGroupByArgs['orderBy'] }
        : { orderBy?: AspNetUsersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AspNetUsersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAspNetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AspNetUsers model
   */
  readonly fields: AspNetUsersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AspNetUsers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AspNetUsersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    AspNetUserClaims<T extends AspNetUsers$AspNetUserClaimsArgs<ExtArgs> = {}>(args?: Subset<T, AspNetUsers$AspNetUserClaimsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AspNetUserClaimsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    AspNetUserLogins<T extends AspNetUsers$AspNetUserLoginsArgs<ExtArgs> = {}>(args?: Subset<T, AspNetUsers$AspNetUserLoginsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AspNetUserLoginsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    AspNetUserRoles<T extends AspNetUsers$AspNetUserRolesArgs<ExtArgs> = {}>(args?: Subset<T, AspNetUsers$AspNetUserRolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AspNetUserRolesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    AspNetUserTokens<T extends AspNetUsers$AspNetUserTokensArgs<ExtArgs> = {}>(args?: Subset<T, AspNetUsers$AspNetUserTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AspNetUserTokensPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AspNetUsers model
   */
  interface AspNetUsersFieldRefs {
    readonly Id: FieldRef<"AspNetUsers", 'String'>
    readonly UserName: FieldRef<"AspNetUsers", 'String'>
    readonly NormalizedUserName: FieldRef<"AspNetUsers", 'String'>
    readonly Email: FieldRef<"AspNetUsers", 'String'>
    readonly NormalizedEmail: FieldRef<"AspNetUsers", 'String'>
    readonly EmailConfirmed: FieldRef<"AspNetUsers", 'Boolean'>
    readonly PasswordHash: FieldRef<"AspNetUsers", 'String'>
    readonly SecurityStamp: FieldRef<"AspNetUsers", 'String'>
    readonly ConcurrencyStamp: FieldRef<"AspNetUsers", 'String'>
    readonly PhoneNumber: FieldRef<"AspNetUsers", 'String'>
    readonly PhoneNumberConfirmed: FieldRef<"AspNetUsers", 'Boolean'>
    readonly TwoFactorEnabled: FieldRef<"AspNetUsers", 'Boolean'>
    readonly LockoutEnd: FieldRef<"AspNetUsers", 'DateTime'>
    readonly LockoutEnabled: FieldRef<"AspNetUsers", 'Boolean'>
    readonly AccessFailedCount: FieldRef<"AspNetUsers", 'Int'>
    readonly PasswordValidUntil: FieldRef<"AspNetUsers", 'DateTime'>
    readonly DeviceId: FieldRef<"AspNetUsers", 'String'>
    readonly FcmToken: FieldRef<"AspNetUsers", 'String'>
    readonly FullName: FieldRef<"AspNetUsers", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AspNetUsers findUnique
   */
  export type AspNetUsersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUsers
     */
    select?: AspNetUsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspNetUsers
     */
    omit?: AspNetUsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUsersInclude<ExtArgs> | null
    /**
     * Filter, which AspNetUsers to fetch.
     */
    where: AspNetUsersWhereUniqueInput
  }

  /**
   * AspNetUsers findUniqueOrThrow
   */
  export type AspNetUsersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUsers
     */
    select?: AspNetUsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspNetUsers
     */
    omit?: AspNetUsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUsersInclude<ExtArgs> | null
    /**
     * Filter, which AspNetUsers to fetch.
     */
    where: AspNetUsersWhereUniqueInput
  }

  /**
   * AspNetUsers findFirst
   */
  export type AspNetUsersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUsers
     */
    select?: AspNetUsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspNetUsers
     */
    omit?: AspNetUsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUsersInclude<ExtArgs> | null
    /**
     * Filter, which AspNetUsers to fetch.
     */
    where?: AspNetUsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AspNetUsers to fetch.
     */
    orderBy?: AspNetUsersOrderByWithRelationInput | AspNetUsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AspNetUsers.
     */
    cursor?: AspNetUsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AspNetUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AspNetUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AspNetUsers.
     */
    distinct?: AspNetUsersScalarFieldEnum | AspNetUsersScalarFieldEnum[]
  }

  /**
   * AspNetUsers findFirstOrThrow
   */
  export type AspNetUsersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUsers
     */
    select?: AspNetUsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspNetUsers
     */
    omit?: AspNetUsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUsersInclude<ExtArgs> | null
    /**
     * Filter, which AspNetUsers to fetch.
     */
    where?: AspNetUsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AspNetUsers to fetch.
     */
    orderBy?: AspNetUsersOrderByWithRelationInput | AspNetUsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AspNetUsers.
     */
    cursor?: AspNetUsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AspNetUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AspNetUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AspNetUsers.
     */
    distinct?: AspNetUsersScalarFieldEnum | AspNetUsersScalarFieldEnum[]
  }

  /**
   * AspNetUsers findMany
   */
  export type AspNetUsersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUsers
     */
    select?: AspNetUsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspNetUsers
     */
    omit?: AspNetUsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUsersInclude<ExtArgs> | null
    /**
     * Filter, which AspNetUsers to fetch.
     */
    where?: AspNetUsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AspNetUsers to fetch.
     */
    orderBy?: AspNetUsersOrderByWithRelationInput | AspNetUsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AspNetUsers.
     */
    cursor?: AspNetUsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AspNetUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AspNetUsers.
     */
    skip?: number
    distinct?: AspNetUsersScalarFieldEnum | AspNetUsersScalarFieldEnum[]
  }

  /**
   * AspNetUsers create
   */
  export type AspNetUsersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUsers
     */
    select?: AspNetUsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspNetUsers
     */
    omit?: AspNetUsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUsersInclude<ExtArgs> | null
    /**
     * The data needed to create a AspNetUsers.
     */
    data: XOR<AspNetUsersCreateInput, AspNetUsersUncheckedCreateInput>
  }

  /**
   * AspNetUsers createMany
   */
  export type AspNetUsersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AspNetUsers.
     */
    data: AspNetUsersCreateManyInput | AspNetUsersCreateManyInput[]
  }

  /**
   * AspNetUsers update
   */
  export type AspNetUsersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUsers
     */
    select?: AspNetUsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspNetUsers
     */
    omit?: AspNetUsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUsersInclude<ExtArgs> | null
    /**
     * The data needed to update a AspNetUsers.
     */
    data: XOR<AspNetUsersUpdateInput, AspNetUsersUncheckedUpdateInput>
    /**
     * Choose, which AspNetUsers to update.
     */
    where: AspNetUsersWhereUniqueInput
  }

  /**
   * AspNetUsers updateMany
   */
  export type AspNetUsersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AspNetUsers.
     */
    data: XOR<AspNetUsersUpdateManyMutationInput, AspNetUsersUncheckedUpdateManyInput>
    /**
     * Filter which AspNetUsers to update
     */
    where?: AspNetUsersWhereInput
    /**
     * Limit how many AspNetUsers to update.
     */
    limit?: number
  }

  /**
   * AspNetUsers upsert
   */
  export type AspNetUsersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUsers
     */
    select?: AspNetUsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspNetUsers
     */
    omit?: AspNetUsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUsersInclude<ExtArgs> | null
    /**
     * The filter to search for the AspNetUsers to update in case it exists.
     */
    where: AspNetUsersWhereUniqueInput
    /**
     * In case the AspNetUsers found by the `where` argument doesn't exist, create a new AspNetUsers with this data.
     */
    create: XOR<AspNetUsersCreateInput, AspNetUsersUncheckedCreateInput>
    /**
     * In case the AspNetUsers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AspNetUsersUpdateInput, AspNetUsersUncheckedUpdateInput>
  }

  /**
   * AspNetUsers delete
   */
  export type AspNetUsersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUsers
     */
    select?: AspNetUsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspNetUsers
     */
    omit?: AspNetUsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUsersInclude<ExtArgs> | null
    /**
     * Filter which AspNetUsers to delete.
     */
    where: AspNetUsersWhereUniqueInput
  }

  /**
   * AspNetUsers deleteMany
   */
  export type AspNetUsersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AspNetUsers to delete
     */
    where?: AspNetUsersWhereInput
    /**
     * Limit how many AspNetUsers to delete.
     */
    limit?: number
  }

  /**
   * AspNetUsers.AspNetUserClaims
   */
  export type AspNetUsers$AspNetUserClaimsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserClaims
     */
    select?: AspNetUserClaimsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspNetUserClaims
     */
    omit?: AspNetUserClaimsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserClaimsInclude<ExtArgs> | null
    where?: AspNetUserClaimsWhereInput
    orderBy?: AspNetUserClaimsOrderByWithRelationInput | AspNetUserClaimsOrderByWithRelationInput[]
    cursor?: AspNetUserClaimsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AspNetUserClaimsScalarFieldEnum | AspNetUserClaimsScalarFieldEnum[]
  }

  /**
   * AspNetUsers.AspNetUserLogins
   */
  export type AspNetUsers$AspNetUserLoginsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserLogins
     */
    select?: AspNetUserLoginsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspNetUserLogins
     */
    omit?: AspNetUserLoginsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserLoginsInclude<ExtArgs> | null
    where?: AspNetUserLoginsWhereInput
    orderBy?: AspNetUserLoginsOrderByWithRelationInput | AspNetUserLoginsOrderByWithRelationInput[]
    cursor?: AspNetUserLoginsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AspNetUserLoginsScalarFieldEnum | AspNetUserLoginsScalarFieldEnum[]
  }

  /**
   * AspNetUsers.AspNetUserRoles
   */
  export type AspNetUsers$AspNetUserRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserRoles
     */
    select?: AspNetUserRolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspNetUserRoles
     */
    omit?: AspNetUserRolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserRolesInclude<ExtArgs> | null
    where?: AspNetUserRolesWhereInput
    orderBy?: AspNetUserRolesOrderByWithRelationInput | AspNetUserRolesOrderByWithRelationInput[]
    cursor?: AspNetUserRolesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AspNetUserRolesScalarFieldEnum | AspNetUserRolesScalarFieldEnum[]
  }

  /**
   * AspNetUsers.AspNetUserTokens
   */
  export type AspNetUsers$AspNetUserTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserTokens
     */
    select?: AspNetUserTokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspNetUserTokens
     */
    omit?: AspNetUserTokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserTokensInclude<ExtArgs> | null
    where?: AspNetUserTokensWhereInput
    orderBy?: AspNetUserTokensOrderByWithRelationInput | AspNetUserTokensOrderByWithRelationInput[]
    cursor?: AspNetUserTokensWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AspNetUserTokensScalarFieldEnum | AspNetUserTokensScalarFieldEnum[]
  }

  /**
   * AspNetUsers without action
   */
  export type AspNetUsersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUsers
     */
    select?: AspNetUsersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspNetUsers
     */
    omit?: AspNetUsersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUsersInclude<ExtArgs> | null
  }


  /**
   * Model AspNetUserTokens
   */

  export type AggregateAspNetUserTokens = {
    _count: AspNetUserTokensCountAggregateOutputType | null
    _min: AspNetUserTokensMinAggregateOutputType | null
    _max: AspNetUserTokensMaxAggregateOutputType | null
  }

  export type AspNetUserTokensMinAggregateOutputType = {
    UserId: string | null
    LoginProvider: string | null
    Name: string | null
    Value: string | null
  }

  export type AspNetUserTokensMaxAggregateOutputType = {
    UserId: string | null
    LoginProvider: string | null
    Name: string | null
    Value: string | null
  }

  export type AspNetUserTokensCountAggregateOutputType = {
    UserId: number
    LoginProvider: number
    Name: number
    Value: number
    _all: number
  }


  export type AspNetUserTokensMinAggregateInputType = {
    UserId?: true
    LoginProvider?: true
    Name?: true
    Value?: true
  }

  export type AspNetUserTokensMaxAggregateInputType = {
    UserId?: true
    LoginProvider?: true
    Name?: true
    Value?: true
  }

  export type AspNetUserTokensCountAggregateInputType = {
    UserId?: true
    LoginProvider?: true
    Name?: true
    Value?: true
    _all?: true
  }

  export type AspNetUserTokensAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AspNetUserTokens to aggregate.
     */
    where?: AspNetUserTokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AspNetUserTokens to fetch.
     */
    orderBy?: AspNetUserTokensOrderByWithRelationInput | AspNetUserTokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AspNetUserTokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AspNetUserTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AspNetUserTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AspNetUserTokens
    **/
    _count?: true | AspNetUserTokensCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AspNetUserTokensMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AspNetUserTokensMaxAggregateInputType
  }

  export type GetAspNetUserTokensAggregateType<T extends AspNetUserTokensAggregateArgs> = {
        [P in keyof T & keyof AggregateAspNetUserTokens]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAspNetUserTokens[P]>
      : GetScalarType<T[P], AggregateAspNetUserTokens[P]>
  }




  export type AspNetUserTokensGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AspNetUserTokensWhereInput
    orderBy?: AspNetUserTokensOrderByWithAggregationInput | AspNetUserTokensOrderByWithAggregationInput[]
    by: AspNetUserTokensScalarFieldEnum[] | AspNetUserTokensScalarFieldEnum
    having?: AspNetUserTokensScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AspNetUserTokensCountAggregateInputType | true
    _min?: AspNetUserTokensMinAggregateInputType
    _max?: AspNetUserTokensMaxAggregateInputType
  }

  export type AspNetUserTokensGroupByOutputType = {
    UserId: string
    LoginProvider: string
    Name: string
    Value: string | null
    _count: AspNetUserTokensCountAggregateOutputType | null
    _min: AspNetUserTokensMinAggregateOutputType | null
    _max: AspNetUserTokensMaxAggregateOutputType | null
  }

  type GetAspNetUserTokensGroupByPayload<T extends AspNetUserTokensGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AspNetUserTokensGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AspNetUserTokensGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AspNetUserTokensGroupByOutputType[P]>
            : GetScalarType<T[P], AspNetUserTokensGroupByOutputType[P]>
        }
      >
    >


  export type AspNetUserTokensSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    UserId?: boolean
    LoginProvider?: boolean
    Name?: boolean
    Value?: boolean
    AspNetUsers?: boolean | AspNetUsersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aspNetUserTokens"]>



  export type AspNetUserTokensSelectScalar = {
    UserId?: boolean
    LoginProvider?: boolean
    Name?: boolean
    Value?: boolean
  }

  export type AspNetUserTokensOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"UserId" | "LoginProvider" | "Name" | "Value", ExtArgs["result"]["aspNetUserTokens"]>
  export type AspNetUserTokensInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AspNetUsers?: boolean | AspNetUsersDefaultArgs<ExtArgs>
  }

  export type $AspNetUserTokensPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AspNetUserTokens"
    objects: {
      AspNetUsers: Prisma.$AspNetUsersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      UserId: string
      LoginProvider: string
      Name: string
      Value: string | null
    }, ExtArgs["result"]["aspNetUserTokens"]>
    composites: {}
  }

  type AspNetUserTokensGetPayload<S extends boolean | null | undefined | AspNetUserTokensDefaultArgs> = $Result.GetResult<Prisma.$AspNetUserTokensPayload, S>

  type AspNetUserTokensCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AspNetUserTokensFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AspNetUserTokensCountAggregateInputType | true
    }

  export interface AspNetUserTokensDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AspNetUserTokens'], meta: { name: 'AspNetUserTokens' } }
    /**
     * Find zero or one AspNetUserTokens that matches the filter.
     * @param {AspNetUserTokensFindUniqueArgs} args - Arguments to find a AspNetUserTokens
     * @example
     * // Get one AspNetUserTokens
     * const aspNetUserTokens = await prisma.aspNetUserTokens.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AspNetUserTokensFindUniqueArgs>(args: SelectSubset<T, AspNetUserTokensFindUniqueArgs<ExtArgs>>): Prisma__AspNetUserTokensClient<$Result.GetResult<Prisma.$AspNetUserTokensPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AspNetUserTokens that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AspNetUserTokensFindUniqueOrThrowArgs} args - Arguments to find a AspNetUserTokens
     * @example
     * // Get one AspNetUserTokens
     * const aspNetUserTokens = await prisma.aspNetUserTokens.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AspNetUserTokensFindUniqueOrThrowArgs>(args: SelectSubset<T, AspNetUserTokensFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AspNetUserTokensClient<$Result.GetResult<Prisma.$AspNetUserTokensPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AspNetUserTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetUserTokensFindFirstArgs} args - Arguments to find a AspNetUserTokens
     * @example
     * // Get one AspNetUserTokens
     * const aspNetUserTokens = await prisma.aspNetUserTokens.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AspNetUserTokensFindFirstArgs>(args?: SelectSubset<T, AspNetUserTokensFindFirstArgs<ExtArgs>>): Prisma__AspNetUserTokensClient<$Result.GetResult<Prisma.$AspNetUserTokensPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AspNetUserTokens that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetUserTokensFindFirstOrThrowArgs} args - Arguments to find a AspNetUserTokens
     * @example
     * // Get one AspNetUserTokens
     * const aspNetUserTokens = await prisma.aspNetUserTokens.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AspNetUserTokensFindFirstOrThrowArgs>(args?: SelectSubset<T, AspNetUserTokensFindFirstOrThrowArgs<ExtArgs>>): Prisma__AspNetUserTokensClient<$Result.GetResult<Prisma.$AspNetUserTokensPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AspNetUserTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetUserTokensFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AspNetUserTokens
     * const aspNetUserTokens = await prisma.aspNetUserTokens.findMany()
     * 
     * // Get first 10 AspNetUserTokens
     * const aspNetUserTokens = await prisma.aspNetUserTokens.findMany({ take: 10 })
     * 
     * // Only select the `UserId`
     * const aspNetUserTokensWithUserIdOnly = await prisma.aspNetUserTokens.findMany({ select: { UserId: true } })
     * 
     */
    findMany<T extends AspNetUserTokensFindManyArgs>(args?: SelectSubset<T, AspNetUserTokensFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AspNetUserTokensPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AspNetUserTokens.
     * @param {AspNetUserTokensCreateArgs} args - Arguments to create a AspNetUserTokens.
     * @example
     * // Create one AspNetUserTokens
     * const AspNetUserTokens = await prisma.aspNetUserTokens.create({
     *   data: {
     *     // ... data to create a AspNetUserTokens
     *   }
     * })
     * 
     */
    create<T extends AspNetUserTokensCreateArgs>(args: SelectSubset<T, AspNetUserTokensCreateArgs<ExtArgs>>): Prisma__AspNetUserTokensClient<$Result.GetResult<Prisma.$AspNetUserTokensPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AspNetUserTokens.
     * @param {AspNetUserTokensCreateManyArgs} args - Arguments to create many AspNetUserTokens.
     * @example
     * // Create many AspNetUserTokens
     * const aspNetUserTokens = await prisma.aspNetUserTokens.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AspNetUserTokensCreateManyArgs>(args?: SelectSubset<T, AspNetUserTokensCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AspNetUserTokens.
     * @param {AspNetUserTokensDeleteArgs} args - Arguments to delete one AspNetUserTokens.
     * @example
     * // Delete one AspNetUserTokens
     * const AspNetUserTokens = await prisma.aspNetUserTokens.delete({
     *   where: {
     *     // ... filter to delete one AspNetUserTokens
     *   }
     * })
     * 
     */
    delete<T extends AspNetUserTokensDeleteArgs>(args: SelectSubset<T, AspNetUserTokensDeleteArgs<ExtArgs>>): Prisma__AspNetUserTokensClient<$Result.GetResult<Prisma.$AspNetUserTokensPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AspNetUserTokens.
     * @param {AspNetUserTokensUpdateArgs} args - Arguments to update one AspNetUserTokens.
     * @example
     * // Update one AspNetUserTokens
     * const aspNetUserTokens = await prisma.aspNetUserTokens.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AspNetUserTokensUpdateArgs>(args: SelectSubset<T, AspNetUserTokensUpdateArgs<ExtArgs>>): Prisma__AspNetUserTokensClient<$Result.GetResult<Prisma.$AspNetUserTokensPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AspNetUserTokens.
     * @param {AspNetUserTokensDeleteManyArgs} args - Arguments to filter AspNetUserTokens to delete.
     * @example
     * // Delete a few AspNetUserTokens
     * const { count } = await prisma.aspNetUserTokens.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AspNetUserTokensDeleteManyArgs>(args?: SelectSubset<T, AspNetUserTokensDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AspNetUserTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetUserTokensUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AspNetUserTokens
     * const aspNetUserTokens = await prisma.aspNetUserTokens.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AspNetUserTokensUpdateManyArgs>(args: SelectSubset<T, AspNetUserTokensUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AspNetUserTokens.
     * @param {AspNetUserTokensUpsertArgs} args - Arguments to update or create a AspNetUserTokens.
     * @example
     * // Update or create a AspNetUserTokens
     * const aspNetUserTokens = await prisma.aspNetUserTokens.upsert({
     *   create: {
     *     // ... data to create a AspNetUserTokens
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AspNetUserTokens we want to update
     *   }
     * })
     */
    upsert<T extends AspNetUserTokensUpsertArgs>(args: SelectSubset<T, AspNetUserTokensUpsertArgs<ExtArgs>>): Prisma__AspNetUserTokensClient<$Result.GetResult<Prisma.$AspNetUserTokensPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AspNetUserTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetUserTokensCountArgs} args - Arguments to filter AspNetUserTokens to count.
     * @example
     * // Count the number of AspNetUserTokens
     * const count = await prisma.aspNetUserTokens.count({
     *   where: {
     *     // ... the filter for the AspNetUserTokens we want to count
     *   }
     * })
    **/
    count<T extends AspNetUserTokensCountArgs>(
      args?: Subset<T, AspNetUserTokensCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AspNetUserTokensCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AspNetUserTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetUserTokensAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AspNetUserTokensAggregateArgs>(args: Subset<T, AspNetUserTokensAggregateArgs>): Prisma.PrismaPromise<GetAspNetUserTokensAggregateType<T>>

    /**
     * Group by AspNetUserTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AspNetUserTokensGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AspNetUserTokensGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AspNetUserTokensGroupByArgs['orderBy'] }
        : { orderBy?: AspNetUserTokensGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AspNetUserTokensGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAspNetUserTokensGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AspNetUserTokens model
   */
  readonly fields: AspNetUserTokensFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AspNetUserTokens.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AspNetUserTokensClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    AspNetUsers<T extends AspNetUsersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AspNetUsersDefaultArgs<ExtArgs>>): Prisma__AspNetUsersClient<$Result.GetResult<Prisma.$AspNetUsersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AspNetUserTokens model
   */
  interface AspNetUserTokensFieldRefs {
    readonly UserId: FieldRef<"AspNetUserTokens", 'String'>
    readonly LoginProvider: FieldRef<"AspNetUserTokens", 'String'>
    readonly Name: FieldRef<"AspNetUserTokens", 'String'>
    readonly Value: FieldRef<"AspNetUserTokens", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AspNetUserTokens findUnique
   */
  export type AspNetUserTokensFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserTokens
     */
    select?: AspNetUserTokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspNetUserTokens
     */
    omit?: AspNetUserTokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserTokensInclude<ExtArgs> | null
    /**
     * Filter, which AspNetUserTokens to fetch.
     */
    where: AspNetUserTokensWhereUniqueInput
  }

  /**
   * AspNetUserTokens findUniqueOrThrow
   */
  export type AspNetUserTokensFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserTokens
     */
    select?: AspNetUserTokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspNetUserTokens
     */
    omit?: AspNetUserTokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserTokensInclude<ExtArgs> | null
    /**
     * Filter, which AspNetUserTokens to fetch.
     */
    where: AspNetUserTokensWhereUniqueInput
  }

  /**
   * AspNetUserTokens findFirst
   */
  export type AspNetUserTokensFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserTokens
     */
    select?: AspNetUserTokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspNetUserTokens
     */
    omit?: AspNetUserTokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserTokensInclude<ExtArgs> | null
    /**
     * Filter, which AspNetUserTokens to fetch.
     */
    where?: AspNetUserTokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AspNetUserTokens to fetch.
     */
    orderBy?: AspNetUserTokensOrderByWithRelationInput | AspNetUserTokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AspNetUserTokens.
     */
    cursor?: AspNetUserTokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AspNetUserTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AspNetUserTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AspNetUserTokens.
     */
    distinct?: AspNetUserTokensScalarFieldEnum | AspNetUserTokensScalarFieldEnum[]
  }

  /**
   * AspNetUserTokens findFirstOrThrow
   */
  export type AspNetUserTokensFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserTokens
     */
    select?: AspNetUserTokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspNetUserTokens
     */
    omit?: AspNetUserTokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserTokensInclude<ExtArgs> | null
    /**
     * Filter, which AspNetUserTokens to fetch.
     */
    where?: AspNetUserTokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AspNetUserTokens to fetch.
     */
    orderBy?: AspNetUserTokensOrderByWithRelationInput | AspNetUserTokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AspNetUserTokens.
     */
    cursor?: AspNetUserTokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AspNetUserTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AspNetUserTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AspNetUserTokens.
     */
    distinct?: AspNetUserTokensScalarFieldEnum | AspNetUserTokensScalarFieldEnum[]
  }

  /**
   * AspNetUserTokens findMany
   */
  export type AspNetUserTokensFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserTokens
     */
    select?: AspNetUserTokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspNetUserTokens
     */
    omit?: AspNetUserTokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserTokensInclude<ExtArgs> | null
    /**
     * Filter, which AspNetUserTokens to fetch.
     */
    where?: AspNetUserTokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AspNetUserTokens to fetch.
     */
    orderBy?: AspNetUserTokensOrderByWithRelationInput | AspNetUserTokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AspNetUserTokens.
     */
    cursor?: AspNetUserTokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AspNetUserTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AspNetUserTokens.
     */
    skip?: number
    distinct?: AspNetUserTokensScalarFieldEnum | AspNetUserTokensScalarFieldEnum[]
  }

  /**
   * AspNetUserTokens create
   */
  export type AspNetUserTokensCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserTokens
     */
    select?: AspNetUserTokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspNetUserTokens
     */
    omit?: AspNetUserTokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserTokensInclude<ExtArgs> | null
    /**
     * The data needed to create a AspNetUserTokens.
     */
    data: XOR<AspNetUserTokensCreateInput, AspNetUserTokensUncheckedCreateInput>
  }

  /**
   * AspNetUserTokens createMany
   */
  export type AspNetUserTokensCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AspNetUserTokens.
     */
    data: AspNetUserTokensCreateManyInput | AspNetUserTokensCreateManyInput[]
  }

  /**
   * AspNetUserTokens update
   */
  export type AspNetUserTokensUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserTokens
     */
    select?: AspNetUserTokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspNetUserTokens
     */
    omit?: AspNetUserTokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserTokensInclude<ExtArgs> | null
    /**
     * The data needed to update a AspNetUserTokens.
     */
    data: XOR<AspNetUserTokensUpdateInput, AspNetUserTokensUncheckedUpdateInput>
    /**
     * Choose, which AspNetUserTokens to update.
     */
    where: AspNetUserTokensWhereUniqueInput
  }

  /**
   * AspNetUserTokens updateMany
   */
  export type AspNetUserTokensUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AspNetUserTokens.
     */
    data: XOR<AspNetUserTokensUpdateManyMutationInput, AspNetUserTokensUncheckedUpdateManyInput>
    /**
     * Filter which AspNetUserTokens to update
     */
    where?: AspNetUserTokensWhereInput
    /**
     * Limit how many AspNetUserTokens to update.
     */
    limit?: number
  }

  /**
   * AspNetUserTokens upsert
   */
  export type AspNetUserTokensUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserTokens
     */
    select?: AspNetUserTokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspNetUserTokens
     */
    omit?: AspNetUserTokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserTokensInclude<ExtArgs> | null
    /**
     * The filter to search for the AspNetUserTokens to update in case it exists.
     */
    where: AspNetUserTokensWhereUniqueInput
    /**
     * In case the AspNetUserTokens found by the `where` argument doesn't exist, create a new AspNetUserTokens with this data.
     */
    create: XOR<AspNetUserTokensCreateInput, AspNetUserTokensUncheckedCreateInput>
    /**
     * In case the AspNetUserTokens was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AspNetUserTokensUpdateInput, AspNetUserTokensUncheckedUpdateInput>
  }

  /**
   * AspNetUserTokens delete
   */
  export type AspNetUserTokensDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserTokens
     */
    select?: AspNetUserTokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspNetUserTokens
     */
    omit?: AspNetUserTokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserTokensInclude<ExtArgs> | null
    /**
     * Filter which AspNetUserTokens to delete.
     */
    where: AspNetUserTokensWhereUniqueInput
  }

  /**
   * AspNetUserTokens deleteMany
   */
  export type AspNetUserTokensDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AspNetUserTokens to delete
     */
    where?: AspNetUserTokensWhereInput
    /**
     * Limit how many AspNetUserTokens to delete.
     */
    limit?: number
  }

  /**
   * AspNetUserTokens without action
   */
  export type AspNetUserTokensDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AspNetUserTokens
     */
    select?: AspNetUserTokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AspNetUserTokens
     */
    omit?: AspNetUserTokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AspNetUserTokensInclude<ExtArgs> | null
  }


  /**
   * Model CardReplacementRequests
   */

  export type AggregateCardReplacementRequests = {
    _count: CardReplacementRequestsCountAggregateOutputType | null
    _min: CardReplacementRequestsMinAggregateOutputType | null
    _max: CardReplacementRequestsMaxAggregateOutputType | null
  }

  export type CardReplacementRequestsMinAggregateOutputType = {
    RequestID: string | null
    CreatedDate: Date | null
    UpdatedDate: Date | null
    PhoneNumber: string | null
    OldFourDigits: string | null
    NewFourDigits: string | null
    IsCompleted: boolean | null
    DeviceId: string | null
  }

  export type CardReplacementRequestsMaxAggregateOutputType = {
    RequestID: string | null
    CreatedDate: Date | null
    UpdatedDate: Date | null
    PhoneNumber: string | null
    OldFourDigits: string | null
    NewFourDigits: string | null
    IsCompleted: boolean | null
    DeviceId: string | null
  }

  export type CardReplacementRequestsCountAggregateOutputType = {
    RequestID: number
    CreatedDate: number
    UpdatedDate: number
    PhoneNumber: number
    OldFourDigits: number
    NewFourDigits: number
    IsCompleted: number
    DeviceId: number
    _all: number
  }


  export type CardReplacementRequestsMinAggregateInputType = {
    RequestID?: true
    CreatedDate?: true
    UpdatedDate?: true
    PhoneNumber?: true
    OldFourDigits?: true
    NewFourDigits?: true
    IsCompleted?: true
    DeviceId?: true
  }

  export type CardReplacementRequestsMaxAggregateInputType = {
    RequestID?: true
    CreatedDate?: true
    UpdatedDate?: true
    PhoneNumber?: true
    OldFourDigits?: true
    NewFourDigits?: true
    IsCompleted?: true
    DeviceId?: true
  }

  export type CardReplacementRequestsCountAggregateInputType = {
    RequestID?: true
    CreatedDate?: true
    UpdatedDate?: true
    PhoneNumber?: true
    OldFourDigits?: true
    NewFourDigits?: true
    IsCompleted?: true
    DeviceId?: true
    _all?: true
  }

  export type CardReplacementRequestsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CardReplacementRequests to aggregate.
     */
    where?: CardReplacementRequestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CardReplacementRequests to fetch.
     */
    orderBy?: CardReplacementRequestsOrderByWithRelationInput | CardReplacementRequestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CardReplacementRequestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CardReplacementRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CardReplacementRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CardReplacementRequests
    **/
    _count?: true | CardReplacementRequestsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CardReplacementRequestsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CardReplacementRequestsMaxAggregateInputType
  }

  export type GetCardReplacementRequestsAggregateType<T extends CardReplacementRequestsAggregateArgs> = {
        [P in keyof T & keyof AggregateCardReplacementRequests]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCardReplacementRequests[P]>
      : GetScalarType<T[P], AggregateCardReplacementRequests[P]>
  }




  export type CardReplacementRequestsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CardReplacementRequestsWhereInput
    orderBy?: CardReplacementRequestsOrderByWithAggregationInput | CardReplacementRequestsOrderByWithAggregationInput[]
    by: CardReplacementRequestsScalarFieldEnum[] | CardReplacementRequestsScalarFieldEnum
    having?: CardReplacementRequestsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CardReplacementRequestsCountAggregateInputType | true
    _min?: CardReplacementRequestsMinAggregateInputType
    _max?: CardReplacementRequestsMaxAggregateInputType
  }

  export type CardReplacementRequestsGroupByOutputType = {
    RequestID: string
    CreatedDate: Date
    UpdatedDate: Date
    PhoneNumber: string | null
    OldFourDigits: string | null
    NewFourDigits: string | null
    IsCompleted: boolean
    DeviceId: string | null
    _count: CardReplacementRequestsCountAggregateOutputType | null
    _min: CardReplacementRequestsMinAggregateOutputType | null
    _max: CardReplacementRequestsMaxAggregateOutputType | null
  }

  type GetCardReplacementRequestsGroupByPayload<T extends CardReplacementRequestsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CardReplacementRequestsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CardReplacementRequestsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CardReplacementRequestsGroupByOutputType[P]>
            : GetScalarType<T[P], CardReplacementRequestsGroupByOutputType[P]>
        }
      >
    >


  export type CardReplacementRequestsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    RequestID?: boolean
    CreatedDate?: boolean
    UpdatedDate?: boolean
    PhoneNumber?: boolean
    OldFourDigits?: boolean
    NewFourDigits?: boolean
    IsCompleted?: boolean
    DeviceId?: boolean
  }, ExtArgs["result"]["cardReplacementRequests"]>



  export type CardReplacementRequestsSelectScalar = {
    RequestID?: boolean
    CreatedDate?: boolean
    UpdatedDate?: boolean
    PhoneNumber?: boolean
    OldFourDigits?: boolean
    NewFourDigits?: boolean
    IsCompleted?: boolean
    DeviceId?: boolean
  }

  export type CardReplacementRequestsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"RequestID" | "CreatedDate" | "UpdatedDate" | "PhoneNumber" | "OldFourDigits" | "NewFourDigits" | "IsCompleted" | "DeviceId", ExtArgs["result"]["cardReplacementRequests"]>

  export type $CardReplacementRequestsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CardReplacementRequests"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      RequestID: string
      CreatedDate: Date
      UpdatedDate: Date
      PhoneNumber: string | null
      OldFourDigits: string | null
      NewFourDigits: string | null
      IsCompleted: boolean
      DeviceId: string | null
    }, ExtArgs["result"]["cardReplacementRequests"]>
    composites: {}
  }

  type CardReplacementRequestsGetPayload<S extends boolean | null | undefined | CardReplacementRequestsDefaultArgs> = $Result.GetResult<Prisma.$CardReplacementRequestsPayload, S>

  type CardReplacementRequestsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CardReplacementRequestsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CardReplacementRequestsCountAggregateInputType | true
    }

  export interface CardReplacementRequestsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CardReplacementRequests'], meta: { name: 'CardReplacementRequests' } }
    /**
     * Find zero or one CardReplacementRequests that matches the filter.
     * @param {CardReplacementRequestsFindUniqueArgs} args - Arguments to find a CardReplacementRequests
     * @example
     * // Get one CardReplacementRequests
     * const cardReplacementRequests = await prisma.cardReplacementRequests.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CardReplacementRequestsFindUniqueArgs>(args: SelectSubset<T, CardReplacementRequestsFindUniqueArgs<ExtArgs>>): Prisma__CardReplacementRequestsClient<$Result.GetResult<Prisma.$CardReplacementRequestsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CardReplacementRequests that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CardReplacementRequestsFindUniqueOrThrowArgs} args - Arguments to find a CardReplacementRequests
     * @example
     * // Get one CardReplacementRequests
     * const cardReplacementRequests = await prisma.cardReplacementRequests.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CardReplacementRequestsFindUniqueOrThrowArgs>(args: SelectSubset<T, CardReplacementRequestsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CardReplacementRequestsClient<$Result.GetResult<Prisma.$CardReplacementRequestsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CardReplacementRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardReplacementRequestsFindFirstArgs} args - Arguments to find a CardReplacementRequests
     * @example
     * // Get one CardReplacementRequests
     * const cardReplacementRequests = await prisma.cardReplacementRequests.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CardReplacementRequestsFindFirstArgs>(args?: SelectSubset<T, CardReplacementRequestsFindFirstArgs<ExtArgs>>): Prisma__CardReplacementRequestsClient<$Result.GetResult<Prisma.$CardReplacementRequestsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CardReplacementRequests that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardReplacementRequestsFindFirstOrThrowArgs} args - Arguments to find a CardReplacementRequests
     * @example
     * // Get one CardReplacementRequests
     * const cardReplacementRequests = await prisma.cardReplacementRequests.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CardReplacementRequestsFindFirstOrThrowArgs>(args?: SelectSubset<T, CardReplacementRequestsFindFirstOrThrowArgs<ExtArgs>>): Prisma__CardReplacementRequestsClient<$Result.GetResult<Prisma.$CardReplacementRequestsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CardReplacementRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardReplacementRequestsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CardReplacementRequests
     * const cardReplacementRequests = await prisma.cardReplacementRequests.findMany()
     * 
     * // Get first 10 CardReplacementRequests
     * const cardReplacementRequests = await prisma.cardReplacementRequests.findMany({ take: 10 })
     * 
     * // Only select the `RequestID`
     * const cardReplacementRequestsWithRequestIDOnly = await prisma.cardReplacementRequests.findMany({ select: { RequestID: true } })
     * 
     */
    findMany<T extends CardReplacementRequestsFindManyArgs>(args?: SelectSubset<T, CardReplacementRequestsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CardReplacementRequestsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CardReplacementRequests.
     * @param {CardReplacementRequestsCreateArgs} args - Arguments to create a CardReplacementRequests.
     * @example
     * // Create one CardReplacementRequests
     * const CardReplacementRequests = await prisma.cardReplacementRequests.create({
     *   data: {
     *     // ... data to create a CardReplacementRequests
     *   }
     * })
     * 
     */
    create<T extends CardReplacementRequestsCreateArgs>(args: SelectSubset<T, CardReplacementRequestsCreateArgs<ExtArgs>>): Prisma__CardReplacementRequestsClient<$Result.GetResult<Prisma.$CardReplacementRequestsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CardReplacementRequests.
     * @param {CardReplacementRequestsCreateManyArgs} args - Arguments to create many CardReplacementRequests.
     * @example
     * // Create many CardReplacementRequests
     * const cardReplacementRequests = await prisma.cardReplacementRequests.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CardReplacementRequestsCreateManyArgs>(args?: SelectSubset<T, CardReplacementRequestsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CardReplacementRequests.
     * @param {CardReplacementRequestsDeleteArgs} args - Arguments to delete one CardReplacementRequests.
     * @example
     * // Delete one CardReplacementRequests
     * const CardReplacementRequests = await prisma.cardReplacementRequests.delete({
     *   where: {
     *     // ... filter to delete one CardReplacementRequests
     *   }
     * })
     * 
     */
    delete<T extends CardReplacementRequestsDeleteArgs>(args: SelectSubset<T, CardReplacementRequestsDeleteArgs<ExtArgs>>): Prisma__CardReplacementRequestsClient<$Result.GetResult<Prisma.$CardReplacementRequestsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CardReplacementRequests.
     * @param {CardReplacementRequestsUpdateArgs} args - Arguments to update one CardReplacementRequests.
     * @example
     * // Update one CardReplacementRequests
     * const cardReplacementRequests = await prisma.cardReplacementRequests.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CardReplacementRequestsUpdateArgs>(args: SelectSubset<T, CardReplacementRequestsUpdateArgs<ExtArgs>>): Prisma__CardReplacementRequestsClient<$Result.GetResult<Prisma.$CardReplacementRequestsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CardReplacementRequests.
     * @param {CardReplacementRequestsDeleteManyArgs} args - Arguments to filter CardReplacementRequests to delete.
     * @example
     * // Delete a few CardReplacementRequests
     * const { count } = await prisma.cardReplacementRequests.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CardReplacementRequestsDeleteManyArgs>(args?: SelectSubset<T, CardReplacementRequestsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CardReplacementRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardReplacementRequestsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CardReplacementRequests
     * const cardReplacementRequests = await prisma.cardReplacementRequests.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CardReplacementRequestsUpdateManyArgs>(args: SelectSubset<T, CardReplacementRequestsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CardReplacementRequests.
     * @param {CardReplacementRequestsUpsertArgs} args - Arguments to update or create a CardReplacementRequests.
     * @example
     * // Update or create a CardReplacementRequests
     * const cardReplacementRequests = await prisma.cardReplacementRequests.upsert({
     *   create: {
     *     // ... data to create a CardReplacementRequests
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CardReplacementRequests we want to update
     *   }
     * })
     */
    upsert<T extends CardReplacementRequestsUpsertArgs>(args: SelectSubset<T, CardReplacementRequestsUpsertArgs<ExtArgs>>): Prisma__CardReplacementRequestsClient<$Result.GetResult<Prisma.$CardReplacementRequestsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CardReplacementRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardReplacementRequestsCountArgs} args - Arguments to filter CardReplacementRequests to count.
     * @example
     * // Count the number of CardReplacementRequests
     * const count = await prisma.cardReplacementRequests.count({
     *   where: {
     *     // ... the filter for the CardReplacementRequests we want to count
     *   }
     * })
    **/
    count<T extends CardReplacementRequestsCountArgs>(
      args?: Subset<T, CardReplacementRequestsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CardReplacementRequestsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CardReplacementRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardReplacementRequestsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CardReplacementRequestsAggregateArgs>(args: Subset<T, CardReplacementRequestsAggregateArgs>): Prisma.PrismaPromise<GetCardReplacementRequestsAggregateType<T>>

    /**
     * Group by CardReplacementRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CardReplacementRequestsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CardReplacementRequestsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CardReplacementRequestsGroupByArgs['orderBy'] }
        : { orderBy?: CardReplacementRequestsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CardReplacementRequestsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCardReplacementRequestsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CardReplacementRequests model
   */
  readonly fields: CardReplacementRequestsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CardReplacementRequests.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CardReplacementRequestsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CardReplacementRequests model
   */
  interface CardReplacementRequestsFieldRefs {
    readonly RequestID: FieldRef<"CardReplacementRequests", 'String'>
    readonly CreatedDate: FieldRef<"CardReplacementRequests", 'DateTime'>
    readonly UpdatedDate: FieldRef<"CardReplacementRequests", 'DateTime'>
    readonly PhoneNumber: FieldRef<"CardReplacementRequests", 'String'>
    readonly OldFourDigits: FieldRef<"CardReplacementRequests", 'String'>
    readonly NewFourDigits: FieldRef<"CardReplacementRequests", 'String'>
    readonly IsCompleted: FieldRef<"CardReplacementRequests", 'Boolean'>
    readonly DeviceId: FieldRef<"CardReplacementRequests", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CardReplacementRequests findUnique
   */
  export type CardReplacementRequestsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardReplacementRequests
     */
    select?: CardReplacementRequestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardReplacementRequests
     */
    omit?: CardReplacementRequestsOmit<ExtArgs> | null
    /**
     * Filter, which CardReplacementRequests to fetch.
     */
    where: CardReplacementRequestsWhereUniqueInput
  }

  /**
   * CardReplacementRequests findUniqueOrThrow
   */
  export type CardReplacementRequestsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardReplacementRequests
     */
    select?: CardReplacementRequestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardReplacementRequests
     */
    omit?: CardReplacementRequestsOmit<ExtArgs> | null
    /**
     * Filter, which CardReplacementRequests to fetch.
     */
    where: CardReplacementRequestsWhereUniqueInput
  }

  /**
   * CardReplacementRequests findFirst
   */
  export type CardReplacementRequestsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardReplacementRequests
     */
    select?: CardReplacementRequestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardReplacementRequests
     */
    omit?: CardReplacementRequestsOmit<ExtArgs> | null
    /**
     * Filter, which CardReplacementRequests to fetch.
     */
    where?: CardReplacementRequestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CardReplacementRequests to fetch.
     */
    orderBy?: CardReplacementRequestsOrderByWithRelationInput | CardReplacementRequestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CardReplacementRequests.
     */
    cursor?: CardReplacementRequestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CardReplacementRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CardReplacementRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CardReplacementRequests.
     */
    distinct?: CardReplacementRequestsScalarFieldEnum | CardReplacementRequestsScalarFieldEnum[]
  }

  /**
   * CardReplacementRequests findFirstOrThrow
   */
  export type CardReplacementRequestsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardReplacementRequests
     */
    select?: CardReplacementRequestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardReplacementRequests
     */
    omit?: CardReplacementRequestsOmit<ExtArgs> | null
    /**
     * Filter, which CardReplacementRequests to fetch.
     */
    where?: CardReplacementRequestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CardReplacementRequests to fetch.
     */
    orderBy?: CardReplacementRequestsOrderByWithRelationInput | CardReplacementRequestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CardReplacementRequests.
     */
    cursor?: CardReplacementRequestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CardReplacementRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CardReplacementRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CardReplacementRequests.
     */
    distinct?: CardReplacementRequestsScalarFieldEnum | CardReplacementRequestsScalarFieldEnum[]
  }

  /**
   * CardReplacementRequests findMany
   */
  export type CardReplacementRequestsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardReplacementRequests
     */
    select?: CardReplacementRequestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardReplacementRequests
     */
    omit?: CardReplacementRequestsOmit<ExtArgs> | null
    /**
     * Filter, which CardReplacementRequests to fetch.
     */
    where?: CardReplacementRequestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CardReplacementRequests to fetch.
     */
    orderBy?: CardReplacementRequestsOrderByWithRelationInput | CardReplacementRequestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CardReplacementRequests.
     */
    cursor?: CardReplacementRequestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CardReplacementRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CardReplacementRequests.
     */
    skip?: number
    distinct?: CardReplacementRequestsScalarFieldEnum | CardReplacementRequestsScalarFieldEnum[]
  }

  /**
   * CardReplacementRequests create
   */
  export type CardReplacementRequestsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardReplacementRequests
     */
    select?: CardReplacementRequestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardReplacementRequests
     */
    omit?: CardReplacementRequestsOmit<ExtArgs> | null
    /**
     * The data needed to create a CardReplacementRequests.
     */
    data: XOR<CardReplacementRequestsCreateInput, CardReplacementRequestsUncheckedCreateInput>
  }

  /**
   * CardReplacementRequests createMany
   */
  export type CardReplacementRequestsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CardReplacementRequests.
     */
    data: CardReplacementRequestsCreateManyInput | CardReplacementRequestsCreateManyInput[]
  }

  /**
   * CardReplacementRequests update
   */
  export type CardReplacementRequestsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardReplacementRequests
     */
    select?: CardReplacementRequestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardReplacementRequests
     */
    omit?: CardReplacementRequestsOmit<ExtArgs> | null
    /**
     * The data needed to update a CardReplacementRequests.
     */
    data: XOR<CardReplacementRequestsUpdateInput, CardReplacementRequestsUncheckedUpdateInput>
    /**
     * Choose, which CardReplacementRequests to update.
     */
    where: CardReplacementRequestsWhereUniqueInput
  }

  /**
   * CardReplacementRequests updateMany
   */
  export type CardReplacementRequestsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CardReplacementRequests.
     */
    data: XOR<CardReplacementRequestsUpdateManyMutationInput, CardReplacementRequestsUncheckedUpdateManyInput>
    /**
     * Filter which CardReplacementRequests to update
     */
    where?: CardReplacementRequestsWhereInput
    /**
     * Limit how many CardReplacementRequests to update.
     */
    limit?: number
  }

  /**
   * CardReplacementRequests upsert
   */
  export type CardReplacementRequestsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardReplacementRequests
     */
    select?: CardReplacementRequestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardReplacementRequests
     */
    omit?: CardReplacementRequestsOmit<ExtArgs> | null
    /**
     * The filter to search for the CardReplacementRequests to update in case it exists.
     */
    where: CardReplacementRequestsWhereUniqueInput
    /**
     * In case the CardReplacementRequests found by the `where` argument doesn't exist, create a new CardReplacementRequests with this data.
     */
    create: XOR<CardReplacementRequestsCreateInput, CardReplacementRequestsUncheckedCreateInput>
    /**
     * In case the CardReplacementRequests was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CardReplacementRequestsUpdateInput, CardReplacementRequestsUncheckedUpdateInput>
  }

  /**
   * CardReplacementRequests delete
   */
  export type CardReplacementRequestsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardReplacementRequests
     */
    select?: CardReplacementRequestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardReplacementRequests
     */
    omit?: CardReplacementRequestsOmit<ExtArgs> | null
    /**
     * Filter which CardReplacementRequests to delete.
     */
    where: CardReplacementRequestsWhereUniqueInput
  }

  /**
   * CardReplacementRequests deleteMany
   */
  export type CardReplacementRequestsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CardReplacementRequests to delete
     */
    where?: CardReplacementRequestsWhereInput
    /**
     * Limit how many CardReplacementRequests to delete.
     */
    limit?: number
  }

  /**
   * CardReplacementRequests without action
   */
  export type CardReplacementRequestsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CardReplacementRequests
     */
    select?: CardReplacementRequestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CardReplacementRequests
     */
    omit?: CardReplacementRequestsOmit<ExtArgs> | null
  }


  /**
   * Model DetractorsFeedback
   */

  export type AggregateDetractorsFeedback = {
    _count: DetractorsFeedbackCountAggregateOutputType | null
    _avg: DetractorsFeedbackAvgAggregateOutputType | null
    _sum: DetractorsFeedbackSumAggregateOutputType | null
    _min: DetractorsFeedbackMinAggregateOutputType | null
    _max: DetractorsFeedbackMaxAggregateOutputType | null
  }

  export type DetractorsFeedbackAvgAggregateOutputType = {
    Id: number | null
    Rating: number | null
  }

  export type DetractorsFeedbackSumAggregateOutputType = {
    Id: number | null
    Rating: number | null
  }

  export type DetractorsFeedbackMinAggregateOutputType = {
    Id: number | null
    Rating: number | null
    PhoneNumber: string | null
    Feedback: string | null
    AccomplishedDate: Date | null
  }

  export type DetractorsFeedbackMaxAggregateOutputType = {
    Id: number | null
    Rating: number | null
    PhoneNumber: string | null
    Feedback: string | null
    AccomplishedDate: Date | null
  }

  export type DetractorsFeedbackCountAggregateOutputType = {
    Id: number
    Rating: number
    PhoneNumber: number
    Feedback: number
    AccomplishedDate: number
    _all: number
  }


  export type DetractorsFeedbackAvgAggregateInputType = {
    Id?: true
    Rating?: true
  }

  export type DetractorsFeedbackSumAggregateInputType = {
    Id?: true
    Rating?: true
  }

  export type DetractorsFeedbackMinAggregateInputType = {
    Id?: true
    Rating?: true
    PhoneNumber?: true
    Feedback?: true
    AccomplishedDate?: true
  }

  export type DetractorsFeedbackMaxAggregateInputType = {
    Id?: true
    Rating?: true
    PhoneNumber?: true
    Feedback?: true
    AccomplishedDate?: true
  }

  export type DetractorsFeedbackCountAggregateInputType = {
    Id?: true
    Rating?: true
    PhoneNumber?: true
    Feedback?: true
    AccomplishedDate?: true
    _all?: true
  }

  export type DetractorsFeedbackAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DetractorsFeedback to aggregate.
     */
    where?: DetractorsFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DetractorsFeedbacks to fetch.
     */
    orderBy?: DetractorsFeedbackOrderByWithRelationInput | DetractorsFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DetractorsFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DetractorsFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DetractorsFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DetractorsFeedbacks
    **/
    _count?: true | DetractorsFeedbackCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DetractorsFeedbackAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DetractorsFeedbackSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DetractorsFeedbackMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DetractorsFeedbackMaxAggregateInputType
  }

  export type GetDetractorsFeedbackAggregateType<T extends DetractorsFeedbackAggregateArgs> = {
        [P in keyof T & keyof AggregateDetractorsFeedback]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDetractorsFeedback[P]>
      : GetScalarType<T[P], AggregateDetractorsFeedback[P]>
  }




  export type DetractorsFeedbackGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DetractorsFeedbackWhereInput
    orderBy?: DetractorsFeedbackOrderByWithAggregationInput | DetractorsFeedbackOrderByWithAggregationInput[]
    by: DetractorsFeedbackScalarFieldEnum[] | DetractorsFeedbackScalarFieldEnum
    having?: DetractorsFeedbackScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DetractorsFeedbackCountAggregateInputType | true
    _avg?: DetractorsFeedbackAvgAggregateInputType
    _sum?: DetractorsFeedbackSumAggregateInputType
    _min?: DetractorsFeedbackMinAggregateInputType
    _max?: DetractorsFeedbackMaxAggregateInputType
  }

  export type DetractorsFeedbackGroupByOutputType = {
    Id: number
    Rating: number
    PhoneNumber: string | null
    Feedback: string | null
    AccomplishedDate: Date
    _count: DetractorsFeedbackCountAggregateOutputType | null
    _avg: DetractorsFeedbackAvgAggregateOutputType | null
    _sum: DetractorsFeedbackSumAggregateOutputType | null
    _min: DetractorsFeedbackMinAggregateOutputType | null
    _max: DetractorsFeedbackMaxAggregateOutputType | null
  }

  type GetDetractorsFeedbackGroupByPayload<T extends DetractorsFeedbackGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DetractorsFeedbackGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DetractorsFeedbackGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DetractorsFeedbackGroupByOutputType[P]>
            : GetScalarType<T[P], DetractorsFeedbackGroupByOutputType[P]>
        }
      >
    >


  export type DetractorsFeedbackSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    Rating?: boolean
    PhoneNumber?: boolean
    Feedback?: boolean
    AccomplishedDate?: boolean
  }, ExtArgs["result"]["detractorsFeedback"]>



  export type DetractorsFeedbackSelectScalar = {
    Id?: boolean
    Rating?: boolean
    PhoneNumber?: boolean
    Feedback?: boolean
    AccomplishedDate?: boolean
  }

  export type DetractorsFeedbackOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Id" | "Rating" | "PhoneNumber" | "Feedback" | "AccomplishedDate", ExtArgs["result"]["detractorsFeedback"]>

  export type $DetractorsFeedbackPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DetractorsFeedback"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      Id: number
      Rating: number
      PhoneNumber: string | null
      Feedback: string | null
      AccomplishedDate: Date
    }, ExtArgs["result"]["detractorsFeedback"]>
    composites: {}
  }

  type DetractorsFeedbackGetPayload<S extends boolean | null | undefined | DetractorsFeedbackDefaultArgs> = $Result.GetResult<Prisma.$DetractorsFeedbackPayload, S>

  type DetractorsFeedbackCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DetractorsFeedbackFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DetractorsFeedbackCountAggregateInputType | true
    }

  export interface DetractorsFeedbackDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DetractorsFeedback'], meta: { name: 'DetractorsFeedback' } }
    /**
     * Find zero or one DetractorsFeedback that matches the filter.
     * @param {DetractorsFeedbackFindUniqueArgs} args - Arguments to find a DetractorsFeedback
     * @example
     * // Get one DetractorsFeedback
     * const detractorsFeedback = await prisma.detractorsFeedback.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DetractorsFeedbackFindUniqueArgs>(args: SelectSubset<T, DetractorsFeedbackFindUniqueArgs<ExtArgs>>): Prisma__DetractorsFeedbackClient<$Result.GetResult<Prisma.$DetractorsFeedbackPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DetractorsFeedback that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DetractorsFeedbackFindUniqueOrThrowArgs} args - Arguments to find a DetractorsFeedback
     * @example
     * // Get one DetractorsFeedback
     * const detractorsFeedback = await prisma.detractorsFeedback.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DetractorsFeedbackFindUniqueOrThrowArgs>(args: SelectSubset<T, DetractorsFeedbackFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DetractorsFeedbackClient<$Result.GetResult<Prisma.$DetractorsFeedbackPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DetractorsFeedback that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetractorsFeedbackFindFirstArgs} args - Arguments to find a DetractorsFeedback
     * @example
     * // Get one DetractorsFeedback
     * const detractorsFeedback = await prisma.detractorsFeedback.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DetractorsFeedbackFindFirstArgs>(args?: SelectSubset<T, DetractorsFeedbackFindFirstArgs<ExtArgs>>): Prisma__DetractorsFeedbackClient<$Result.GetResult<Prisma.$DetractorsFeedbackPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DetractorsFeedback that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetractorsFeedbackFindFirstOrThrowArgs} args - Arguments to find a DetractorsFeedback
     * @example
     * // Get one DetractorsFeedback
     * const detractorsFeedback = await prisma.detractorsFeedback.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DetractorsFeedbackFindFirstOrThrowArgs>(args?: SelectSubset<T, DetractorsFeedbackFindFirstOrThrowArgs<ExtArgs>>): Prisma__DetractorsFeedbackClient<$Result.GetResult<Prisma.$DetractorsFeedbackPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DetractorsFeedbacks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetractorsFeedbackFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DetractorsFeedbacks
     * const detractorsFeedbacks = await prisma.detractorsFeedback.findMany()
     * 
     * // Get first 10 DetractorsFeedbacks
     * const detractorsFeedbacks = await prisma.detractorsFeedback.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const detractorsFeedbackWithIdOnly = await prisma.detractorsFeedback.findMany({ select: { Id: true } })
     * 
     */
    findMany<T extends DetractorsFeedbackFindManyArgs>(args?: SelectSubset<T, DetractorsFeedbackFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DetractorsFeedbackPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DetractorsFeedback.
     * @param {DetractorsFeedbackCreateArgs} args - Arguments to create a DetractorsFeedback.
     * @example
     * // Create one DetractorsFeedback
     * const DetractorsFeedback = await prisma.detractorsFeedback.create({
     *   data: {
     *     // ... data to create a DetractorsFeedback
     *   }
     * })
     * 
     */
    create<T extends DetractorsFeedbackCreateArgs>(args: SelectSubset<T, DetractorsFeedbackCreateArgs<ExtArgs>>): Prisma__DetractorsFeedbackClient<$Result.GetResult<Prisma.$DetractorsFeedbackPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DetractorsFeedbacks.
     * @param {DetractorsFeedbackCreateManyArgs} args - Arguments to create many DetractorsFeedbacks.
     * @example
     * // Create many DetractorsFeedbacks
     * const detractorsFeedback = await prisma.detractorsFeedback.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DetractorsFeedbackCreateManyArgs>(args?: SelectSubset<T, DetractorsFeedbackCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DetractorsFeedback.
     * @param {DetractorsFeedbackDeleteArgs} args - Arguments to delete one DetractorsFeedback.
     * @example
     * // Delete one DetractorsFeedback
     * const DetractorsFeedback = await prisma.detractorsFeedback.delete({
     *   where: {
     *     // ... filter to delete one DetractorsFeedback
     *   }
     * })
     * 
     */
    delete<T extends DetractorsFeedbackDeleteArgs>(args: SelectSubset<T, DetractorsFeedbackDeleteArgs<ExtArgs>>): Prisma__DetractorsFeedbackClient<$Result.GetResult<Prisma.$DetractorsFeedbackPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DetractorsFeedback.
     * @param {DetractorsFeedbackUpdateArgs} args - Arguments to update one DetractorsFeedback.
     * @example
     * // Update one DetractorsFeedback
     * const detractorsFeedback = await prisma.detractorsFeedback.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DetractorsFeedbackUpdateArgs>(args: SelectSubset<T, DetractorsFeedbackUpdateArgs<ExtArgs>>): Prisma__DetractorsFeedbackClient<$Result.GetResult<Prisma.$DetractorsFeedbackPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DetractorsFeedbacks.
     * @param {DetractorsFeedbackDeleteManyArgs} args - Arguments to filter DetractorsFeedbacks to delete.
     * @example
     * // Delete a few DetractorsFeedbacks
     * const { count } = await prisma.detractorsFeedback.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DetractorsFeedbackDeleteManyArgs>(args?: SelectSubset<T, DetractorsFeedbackDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DetractorsFeedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetractorsFeedbackUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DetractorsFeedbacks
     * const detractorsFeedback = await prisma.detractorsFeedback.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DetractorsFeedbackUpdateManyArgs>(args: SelectSubset<T, DetractorsFeedbackUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DetractorsFeedback.
     * @param {DetractorsFeedbackUpsertArgs} args - Arguments to update or create a DetractorsFeedback.
     * @example
     * // Update or create a DetractorsFeedback
     * const detractorsFeedback = await prisma.detractorsFeedback.upsert({
     *   create: {
     *     // ... data to create a DetractorsFeedback
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DetractorsFeedback we want to update
     *   }
     * })
     */
    upsert<T extends DetractorsFeedbackUpsertArgs>(args: SelectSubset<T, DetractorsFeedbackUpsertArgs<ExtArgs>>): Prisma__DetractorsFeedbackClient<$Result.GetResult<Prisma.$DetractorsFeedbackPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DetractorsFeedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetractorsFeedbackCountArgs} args - Arguments to filter DetractorsFeedbacks to count.
     * @example
     * // Count the number of DetractorsFeedbacks
     * const count = await prisma.detractorsFeedback.count({
     *   where: {
     *     // ... the filter for the DetractorsFeedbacks we want to count
     *   }
     * })
    **/
    count<T extends DetractorsFeedbackCountArgs>(
      args?: Subset<T, DetractorsFeedbackCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DetractorsFeedbackCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DetractorsFeedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetractorsFeedbackAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DetractorsFeedbackAggregateArgs>(args: Subset<T, DetractorsFeedbackAggregateArgs>): Prisma.PrismaPromise<GetDetractorsFeedbackAggregateType<T>>

    /**
     * Group by DetractorsFeedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DetractorsFeedbackGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DetractorsFeedbackGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DetractorsFeedbackGroupByArgs['orderBy'] }
        : { orderBy?: DetractorsFeedbackGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DetractorsFeedbackGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDetractorsFeedbackGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DetractorsFeedback model
   */
  readonly fields: DetractorsFeedbackFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DetractorsFeedback.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DetractorsFeedbackClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DetractorsFeedback model
   */
  interface DetractorsFeedbackFieldRefs {
    readonly Id: FieldRef<"DetractorsFeedback", 'Int'>
    readonly Rating: FieldRef<"DetractorsFeedback", 'Int'>
    readonly PhoneNumber: FieldRef<"DetractorsFeedback", 'String'>
    readonly Feedback: FieldRef<"DetractorsFeedback", 'String'>
    readonly AccomplishedDate: FieldRef<"DetractorsFeedback", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DetractorsFeedback findUnique
   */
  export type DetractorsFeedbackFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetractorsFeedback
     */
    select?: DetractorsFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetractorsFeedback
     */
    omit?: DetractorsFeedbackOmit<ExtArgs> | null
    /**
     * Filter, which DetractorsFeedback to fetch.
     */
    where: DetractorsFeedbackWhereUniqueInput
  }

  /**
   * DetractorsFeedback findUniqueOrThrow
   */
  export type DetractorsFeedbackFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetractorsFeedback
     */
    select?: DetractorsFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetractorsFeedback
     */
    omit?: DetractorsFeedbackOmit<ExtArgs> | null
    /**
     * Filter, which DetractorsFeedback to fetch.
     */
    where: DetractorsFeedbackWhereUniqueInput
  }

  /**
   * DetractorsFeedback findFirst
   */
  export type DetractorsFeedbackFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetractorsFeedback
     */
    select?: DetractorsFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetractorsFeedback
     */
    omit?: DetractorsFeedbackOmit<ExtArgs> | null
    /**
     * Filter, which DetractorsFeedback to fetch.
     */
    where?: DetractorsFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DetractorsFeedbacks to fetch.
     */
    orderBy?: DetractorsFeedbackOrderByWithRelationInput | DetractorsFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DetractorsFeedbacks.
     */
    cursor?: DetractorsFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DetractorsFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DetractorsFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DetractorsFeedbacks.
     */
    distinct?: DetractorsFeedbackScalarFieldEnum | DetractorsFeedbackScalarFieldEnum[]
  }

  /**
   * DetractorsFeedback findFirstOrThrow
   */
  export type DetractorsFeedbackFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetractorsFeedback
     */
    select?: DetractorsFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetractorsFeedback
     */
    omit?: DetractorsFeedbackOmit<ExtArgs> | null
    /**
     * Filter, which DetractorsFeedback to fetch.
     */
    where?: DetractorsFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DetractorsFeedbacks to fetch.
     */
    orderBy?: DetractorsFeedbackOrderByWithRelationInput | DetractorsFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DetractorsFeedbacks.
     */
    cursor?: DetractorsFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DetractorsFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DetractorsFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DetractorsFeedbacks.
     */
    distinct?: DetractorsFeedbackScalarFieldEnum | DetractorsFeedbackScalarFieldEnum[]
  }

  /**
   * DetractorsFeedback findMany
   */
  export type DetractorsFeedbackFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetractorsFeedback
     */
    select?: DetractorsFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetractorsFeedback
     */
    omit?: DetractorsFeedbackOmit<ExtArgs> | null
    /**
     * Filter, which DetractorsFeedbacks to fetch.
     */
    where?: DetractorsFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DetractorsFeedbacks to fetch.
     */
    orderBy?: DetractorsFeedbackOrderByWithRelationInput | DetractorsFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DetractorsFeedbacks.
     */
    cursor?: DetractorsFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DetractorsFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DetractorsFeedbacks.
     */
    skip?: number
    distinct?: DetractorsFeedbackScalarFieldEnum | DetractorsFeedbackScalarFieldEnum[]
  }

  /**
   * DetractorsFeedback create
   */
  export type DetractorsFeedbackCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetractorsFeedback
     */
    select?: DetractorsFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetractorsFeedback
     */
    omit?: DetractorsFeedbackOmit<ExtArgs> | null
    /**
     * The data needed to create a DetractorsFeedback.
     */
    data: XOR<DetractorsFeedbackCreateInput, DetractorsFeedbackUncheckedCreateInput>
  }

  /**
   * DetractorsFeedback createMany
   */
  export type DetractorsFeedbackCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DetractorsFeedbacks.
     */
    data: DetractorsFeedbackCreateManyInput | DetractorsFeedbackCreateManyInput[]
  }

  /**
   * DetractorsFeedback update
   */
  export type DetractorsFeedbackUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetractorsFeedback
     */
    select?: DetractorsFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetractorsFeedback
     */
    omit?: DetractorsFeedbackOmit<ExtArgs> | null
    /**
     * The data needed to update a DetractorsFeedback.
     */
    data: XOR<DetractorsFeedbackUpdateInput, DetractorsFeedbackUncheckedUpdateInput>
    /**
     * Choose, which DetractorsFeedback to update.
     */
    where: DetractorsFeedbackWhereUniqueInput
  }

  /**
   * DetractorsFeedback updateMany
   */
  export type DetractorsFeedbackUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DetractorsFeedbacks.
     */
    data: XOR<DetractorsFeedbackUpdateManyMutationInput, DetractorsFeedbackUncheckedUpdateManyInput>
    /**
     * Filter which DetractorsFeedbacks to update
     */
    where?: DetractorsFeedbackWhereInput
    /**
     * Limit how many DetractorsFeedbacks to update.
     */
    limit?: number
  }

  /**
   * DetractorsFeedback upsert
   */
  export type DetractorsFeedbackUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetractorsFeedback
     */
    select?: DetractorsFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetractorsFeedback
     */
    omit?: DetractorsFeedbackOmit<ExtArgs> | null
    /**
     * The filter to search for the DetractorsFeedback to update in case it exists.
     */
    where: DetractorsFeedbackWhereUniqueInput
    /**
     * In case the DetractorsFeedback found by the `where` argument doesn't exist, create a new DetractorsFeedback with this data.
     */
    create: XOR<DetractorsFeedbackCreateInput, DetractorsFeedbackUncheckedCreateInput>
    /**
     * In case the DetractorsFeedback was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DetractorsFeedbackUpdateInput, DetractorsFeedbackUncheckedUpdateInput>
  }

  /**
   * DetractorsFeedback delete
   */
  export type DetractorsFeedbackDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetractorsFeedback
     */
    select?: DetractorsFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetractorsFeedback
     */
    omit?: DetractorsFeedbackOmit<ExtArgs> | null
    /**
     * Filter which DetractorsFeedback to delete.
     */
    where: DetractorsFeedbackWhereUniqueInput
  }

  /**
   * DetractorsFeedback deleteMany
   */
  export type DetractorsFeedbackDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DetractorsFeedbacks to delete
     */
    where?: DetractorsFeedbackWhereInput
    /**
     * Limit how many DetractorsFeedbacks to delete.
     */
    limit?: number
  }

  /**
   * DetractorsFeedback without action
   */
  export type DetractorsFeedbackDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DetractorsFeedback
     */
    select?: DetractorsFeedbackSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DetractorsFeedback
     */
    omit?: DetractorsFeedbackOmit<ExtArgs> | null
  }


  /**
   * Model DeviceAccessLog
   */

  export type AggregateDeviceAccessLog = {
    _count: DeviceAccessLogCountAggregateOutputType | null
    _avg: DeviceAccessLogAvgAggregateOutputType | null
    _sum: DeviceAccessLogSumAggregateOutputType | null
    _min: DeviceAccessLogMinAggregateOutputType | null
    _max: DeviceAccessLogMaxAggregateOutputType | null
  }

  export type DeviceAccessLogAvgAggregateOutputType = {
    Id: number | null
  }

  export type DeviceAccessLogSumAggregateOutputType = {
    Id: number | null
  }

  export type DeviceAccessLogMinAggregateOutputType = {
    Id: number | null
    AccessDateTime: Date | null
    DeviceId: string | null
    MobileNumber: string | null
    FullName: string | null
  }

  export type DeviceAccessLogMaxAggregateOutputType = {
    Id: number | null
    AccessDateTime: Date | null
    DeviceId: string | null
    MobileNumber: string | null
    FullName: string | null
  }

  export type DeviceAccessLogCountAggregateOutputType = {
    Id: number
    AccessDateTime: number
    DeviceId: number
    MobileNumber: number
    FullName: number
    _all: number
  }


  export type DeviceAccessLogAvgAggregateInputType = {
    Id?: true
  }

  export type DeviceAccessLogSumAggregateInputType = {
    Id?: true
  }

  export type DeviceAccessLogMinAggregateInputType = {
    Id?: true
    AccessDateTime?: true
    DeviceId?: true
    MobileNumber?: true
    FullName?: true
  }

  export type DeviceAccessLogMaxAggregateInputType = {
    Id?: true
    AccessDateTime?: true
    DeviceId?: true
    MobileNumber?: true
    FullName?: true
  }

  export type DeviceAccessLogCountAggregateInputType = {
    Id?: true
    AccessDateTime?: true
    DeviceId?: true
    MobileNumber?: true
    FullName?: true
    _all?: true
  }

  export type DeviceAccessLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceAccessLog to aggregate.
     */
    where?: DeviceAccessLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceAccessLogs to fetch.
     */
    orderBy?: DeviceAccessLogOrderByWithRelationInput | DeviceAccessLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeviceAccessLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceAccessLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceAccessLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeviceAccessLogs
    **/
    _count?: true | DeviceAccessLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeviceAccessLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeviceAccessLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeviceAccessLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeviceAccessLogMaxAggregateInputType
  }

  export type GetDeviceAccessLogAggregateType<T extends DeviceAccessLogAggregateArgs> = {
        [P in keyof T & keyof AggregateDeviceAccessLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeviceAccessLog[P]>
      : GetScalarType<T[P], AggregateDeviceAccessLog[P]>
  }




  export type DeviceAccessLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceAccessLogWhereInput
    orderBy?: DeviceAccessLogOrderByWithAggregationInput | DeviceAccessLogOrderByWithAggregationInput[]
    by: DeviceAccessLogScalarFieldEnum[] | DeviceAccessLogScalarFieldEnum
    having?: DeviceAccessLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeviceAccessLogCountAggregateInputType | true
    _avg?: DeviceAccessLogAvgAggregateInputType
    _sum?: DeviceAccessLogSumAggregateInputType
    _min?: DeviceAccessLogMinAggregateInputType
    _max?: DeviceAccessLogMaxAggregateInputType
  }

  export type DeviceAccessLogGroupByOutputType = {
    Id: number
    AccessDateTime: Date
    DeviceId: string | null
    MobileNumber: string | null
    FullName: string | null
    _count: DeviceAccessLogCountAggregateOutputType | null
    _avg: DeviceAccessLogAvgAggregateOutputType | null
    _sum: DeviceAccessLogSumAggregateOutputType | null
    _min: DeviceAccessLogMinAggregateOutputType | null
    _max: DeviceAccessLogMaxAggregateOutputType | null
  }

  type GetDeviceAccessLogGroupByPayload<T extends DeviceAccessLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeviceAccessLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeviceAccessLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeviceAccessLogGroupByOutputType[P]>
            : GetScalarType<T[P], DeviceAccessLogGroupByOutputType[P]>
        }
      >
    >


  export type DeviceAccessLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    AccessDateTime?: boolean
    DeviceId?: boolean
    MobileNumber?: boolean
    FullName?: boolean
  }, ExtArgs["result"]["deviceAccessLog"]>



  export type DeviceAccessLogSelectScalar = {
    Id?: boolean
    AccessDateTime?: boolean
    DeviceId?: boolean
    MobileNumber?: boolean
    FullName?: boolean
  }

  export type DeviceAccessLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Id" | "AccessDateTime" | "DeviceId" | "MobileNumber" | "FullName", ExtArgs["result"]["deviceAccessLog"]>

  export type $DeviceAccessLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeviceAccessLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      Id: number
      AccessDateTime: Date
      DeviceId: string | null
      MobileNumber: string | null
      FullName: string | null
    }, ExtArgs["result"]["deviceAccessLog"]>
    composites: {}
  }

  type DeviceAccessLogGetPayload<S extends boolean | null | undefined | DeviceAccessLogDefaultArgs> = $Result.GetResult<Prisma.$DeviceAccessLogPayload, S>

  type DeviceAccessLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeviceAccessLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeviceAccessLogCountAggregateInputType | true
    }

  export interface DeviceAccessLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeviceAccessLog'], meta: { name: 'DeviceAccessLog' } }
    /**
     * Find zero or one DeviceAccessLog that matches the filter.
     * @param {DeviceAccessLogFindUniqueArgs} args - Arguments to find a DeviceAccessLog
     * @example
     * // Get one DeviceAccessLog
     * const deviceAccessLog = await prisma.deviceAccessLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeviceAccessLogFindUniqueArgs>(args: SelectSubset<T, DeviceAccessLogFindUniqueArgs<ExtArgs>>): Prisma__DeviceAccessLogClient<$Result.GetResult<Prisma.$DeviceAccessLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DeviceAccessLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeviceAccessLogFindUniqueOrThrowArgs} args - Arguments to find a DeviceAccessLog
     * @example
     * // Get one DeviceAccessLog
     * const deviceAccessLog = await prisma.deviceAccessLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeviceAccessLogFindUniqueOrThrowArgs>(args: SelectSubset<T, DeviceAccessLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeviceAccessLogClient<$Result.GetResult<Prisma.$DeviceAccessLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeviceAccessLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceAccessLogFindFirstArgs} args - Arguments to find a DeviceAccessLog
     * @example
     * // Get one DeviceAccessLog
     * const deviceAccessLog = await prisma.deviceAccessLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeviceAccessLogFindFirstArgs>(args?: SelectSubset<T, DeviceAccessLogFindFirstArgs<ExtArgs>>): Prisma__DeviceAccessLogClient<$Result.GetResult<Prisma.$DeviceAccessLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeviceAccessLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceAccessLogFindFirstOrThrowArgs} args - Arguments to find a DeviceAccessLog
     * @example
     * // Get one DeviceAccessLog
     * const deviceAccessLog = await prisma.deviceAccessLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeviceAccessLogFindFirstOrThrowArgs>(args?: SelectSubset<T, DeviceAccessLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeviceAccessLogClient<$Result.GetResult<Prisma.$DeviceAccessLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DeviceAccessLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceAccessLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeviceAccessLogs
     * const deviceAccessLogs = await prisma.deviceAccessLog.findMany()
     * 
     * // Get first 10 DeviceAccessLogs
     * const deviceAccessLogs = await prisma.deviceAccessLog.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const deviceAccessLogWithIdOnly = await prisma.deviceAccessLog.findMany({ select: { Id: true } })
     * 
     */
    findMany<T extends DeviceAccessLogFindManyArgs>(args?: SelectSubset<T, DeviceAccessLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceAccessLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DeviceAccessLog.
     * @param {DeviceAccessLogCreateArgs} args - Arguments to create a DeviceAccessLog.
     * @example
     * // Create one DeviceAccessLog
     * const DeviceAccessLog = await prisma.deviceAccessLog.create({
     *   data: {
     *     // ... data to create a DeviceAccessLog
     *   }
     * })
     * 
     */
    create<T extends DeviceAccessLogCreateArgs>(args: SelectSubset<T, DeviceAccessLogCreateArgs<ExtArgs>>): Prisma__DeviceAccessLogClient<$Result.GetResult<Prisma.$DeviceAccessLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DeviceAccessLogs.
     * @param {DeviceAccessLogCreateManyArgs} args - Arguments to create many DeviceAccessLogs.
     * @example
     * // Create many DeviceAccessLogs
     * const deviceAccessLog = await prisma.deviceAccessLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeviceAccessLogCreateManyArgs>(args?: SelectSubset<T, DeviceAccessLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DeviceAccessLog.
     * @param {DeviceAccessLogDeleteArgs} args - Arguments to delete one DeviceAccessLog.
     * @example
     * // Delete one DeviceAccessLog
     * const DeviceAccessLog = await prisma.deviceAccessLog.delete({
     *   where: {
     *     // ... filter to delete one DeviceAccessLog
     *   }
     * })
     * 
     */
    delete<T extends DeviceAccessLogDeleteArgs>(args: SelectSubset<T, DeviceAccessLogDeleteArgs<ExtArgs>>): Prisma__DeviceAccessLogClient<$Result.GetResult<Prisma.$DeviceAccessLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DeviceAccessLog.
     * @param {DeviceAccessLogUpdateArgs} args - Arguments to update one DeviceAccessLog.
     * @example
     * // Update one DeviceAccessLog
     * const deviceAccessLog = await prisma.deviceAccessLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeviceAccessLogUpdateArgs>(args: SelectSubset<T, DeviceAccessLogUpdateArgs<ExtArgs>>): Prisma__DeviceAccessLogClient<$Result.GetResult<Prisma.$DeviceAccessLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DeviceAccessLogs.
     * @param {DeviceAccessLogDeleteManyArgs} args - Arguments to filter DeviceAccessLogs to delete.
     * @example
     * // Delete a few DeviceAccessLogs
     * const { count } = await prisma.deviceAccessLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeviceAccessLogDeleteManyArgs>(args?: SelectSubset<T, DeviceAccessLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeviceAccessLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceAccessLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeviceAccessLogs
     * const deviceAccessLog = await prisma.deviceAccessLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeviceAccessLogUpdateManyArgs>(args: SelectSubset<T, DeviceAccessLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DeviceAccessLog.
     * @param {DeviceAccessLogUpsertArgs} args - Arguments to update or create a DeviceAccessLog.
     * @example
     * // Update or create a DeviceAccessLog
     * const deviceAccessLog = await prisma.deviceAccessLog.upsert({
     *   create: {
     *     // ... data to create a DeviceAccessLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeviceAccessLog we want to update
     *   }
     * })
     */
    upsert<T extends DeviceAccessLogUpsertArgs>(args: SelectSubset<T, DeviceAccessLogUpsertArgs<ExtArgs>>): Prisma__DeviceAccessLogClient<$Result.GetResult<Prisma.$DeviceAccessLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DeviceAccessLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceAccessLogCountArgs} args - Arguments to filter DeviceAccessLogs to count.
     * @example
     * // Count the number of DeviceAccessLogs
     * const count = await prisma.deviceAccessLog.count({
     *   where: {
     *     // ... the filter for the DeviceAccessLogs we want to count
     *   }
     * })
    **/
    count<T extends DeviceAccessLogCountArgs>(
      args?: Subset<T, DeviceAccessLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeviceAccessLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeviceAccessLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceAccessLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeviceAccessLogAggregateArgs>(args: Subset<T, DeviceAccessLogAggregateArgs>): Prisma.PrismaPromise<GetDeviceAccessLogAggregateType<T>>

    /**
     * Group by DeviceAccessLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceAccessLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeviceAccessLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeviceAccessLogGroupByArgs['orderBy'] }
        : { orderBy?: DeviceAccessLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeviceAccessLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeviceAccessLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeviceAccessLog model
   */
  readonly fields: DeviceAccessLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeviceAccessLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeviceAccessLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeviceAccessLog model
   */
  interface DeviceAccessLogFieldRefs {
    readonly Id: FieldRef<"DeviceAccessLog", 'Int'>
    readonly AccessDateTime: FieldRef<"DeviceAccessLog", 'DateTime'>
    readonly DeviceId: FieldRef<"DeviceAccessLog", 'String'>
    readonly MobileNumber: FieldRef<"DeviceAccessLog", 'String'>
    readonly FullName: FieldRef<"DeviceAccessLog", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DeviceAccessLog findUnique
   */
  export type DeviceAccessLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceAccessLog
     */
    select?: DeviceAccessLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceAccessLog
     */
    omit?: DeviceAccessLogOmit<ExtArgs> | null
    /**
     * Filter, which DeviceAccessLog to fetch.
     */
    where: DeviceAccessLogWhereUniqueInput
  }

  /**
   * DeviceAccessLog findUniqueOrThrow
   */
  export type DeviceAccessLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceAccessLog
     */
    select?: DeviceAccessLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceAccessLog
     */
    omit?: DeviceAccessLogOmit<ExtArgs> | null
    /**
     * Filter, which DeviceAccessLog to fetch.
     */
    where: DeviceAccessLogWhereUniqueInput
  }

  /**
   * DeviceAccessLog findFirst
   */
  export type DeviceAccessLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceAccessLog
     */
    select?: DeviceAccessLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceAccessLog
     */
    omit?: DeviceAccessLogOmit<ExtArgs> | null
    /**
     * Filter, which DeviceAccessLog to fetch.
     */
    where?: DeviceAccessLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceAccessLogs to fetch.
     */
    orderBy?: DeviceAccessLogOrderByWithRelationInput | DeviceAccessLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceAccessLogs.
     */
    cursor?: DeviceAccessLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceAccessLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceAccessLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceAccessLogs.
     */
    distinct?: DeviceAccessLogScalarFieldEnum | DeviceAccessLogScalarFieldEnum[]
  }

  /**
   * DeviceAccessLog findFirstOrThrow
   */
  export type DeviceAccessLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceAccessLog
     */
    select?: DeviceAccessLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceAccessLog
     */
    omit?: DeviceAccessLogOmit<ExtArgs> | null
    /**
     * Filter, which DeviceAccessLog to fetch.
     */
    where?: DeviceAccessLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceAccessLogs to fetch.
     */
    orderBy?: DeviceAccessLogOrderByWithRelationInput | DeviceAccessLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceAccessLogs.
     */
    cursor?: DeviceAccessLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceAccessLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceAccessLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceAccessLogs.
     */
    distinct?: DeviceAccessLogScalarFieldEnum | DeviceAccessLogScalarFieldEnum[]
  }

  /**
   * DeviceAccessLog findMany
   */
  export type DeviceAccessLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceAccessLog
     */
    select?: DeviceAccessLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceAccessLog
     */
    omit?: DeviceAccessLogOmit<ExtArgs> | null
    /**
     * Filter, which DeviceAccessLogs to fetch.
     */
    where?: DeviceAccessLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceAccessLogs to fetch.
     */
    orderBy?: DeviceAccessLogOrderByWithRelationInput | DeviceAccessLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeviceAccessLogs.
     */
    cursor?: DeviceAccessLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceAccessLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceAccessLogs.
     */
    skip?: number
    distinct?: DeviceAccessLogScalarFieldEnum | DeviceAccessLogScalarFieldEnum[]
  }

  /**
   * DeviceAccessLog create
   */
  export type DeviceAccessLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceAccessLog
     */
    select?: DeviceAccessLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceAccessLog
     */
    omit?: DeviceAccessLogOmit<ExtArgs> | null
    /**
     * The data needed to create a DeviceAccessLog.
     */
    data: XOR<DeviceAccessLogCreateInput, DeviceAccessLogUncheckedCreateInput>
  }

  /**
   * DeviceAccessLog createMany
   */
  export type DeviceAccessLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeviceAccessLogs.
     */
    data: DeviceAccessLogCreateManyInput | DeviceAccessLogCreateManyInput[]
  }

  /**
   * DeviceAccessLog update
   */
  export type DeviceAccessLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceAccessLog
     */
    select?: DeviceAccessLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceAccessLog
     */
    omit?: DeviceAccessLogOmit<ExtArgs> | null
    /**
     * The data needed to update a DeviceAccessLog.
     */
    data: XOR<DeviceAccessLogUpdateInput, DeviceAccessLogUncheckedUpdateInput>
    /**
     * Choose, which DeviceAccessLog to update.
     */
    where: DeviceAccessLogWhereUniqueInput
  }

  /**
   * DeviceAccessLog updateMany
   */
  export type DeviceAccessLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeviceAccessLogs.
     */
    data: XOR<DeviceAccessLogUpdateManyMutationInput, DeviceAccessLogUncheckedUpdateManyInput>
    /**
     * Filter which DeviceAccessLogs to update
     */
    where?: DeviceAccessLogWhereInput
    /**
     * Limit how many DeviceAccessLogs to update.
     */
    limit?: number
  }

  /**
   * DeviceAccessLog upsert
   */
  export type DeviceAccessLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceAccessLog
     */
    select?: DeviceAccessLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceAccessLog
     */
    omit?: DeviceAccessLogOmit<ExtArgs> | null
    /**
     * The filter to search for the DeviceAccessLog to update in case it exists.
     */
    where: DeviceAccessLogWhereUniqueInput
    /**
     * In case the DeviceAccessLog found by the `where` argument doesn't exist, create a new DeviceAccessLog with this data.
     */
    create: XOR<DeviceAccessLogCreateInput, DeviceAccessLogUncheckedCreateInput>
    /**
     * In case the DeviceAccessLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeviceAccessLogUpdateInput, DeviceAccessLogUncheckedUpdateInput>
  }

  /**
   * DeviceAccessLog delete
   */
  export type DeviceAccessLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceAccessLog
     */
    select?: DeviceAccessLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceAccessLog
     */
    omit?: DeviceAccessLogOmit<ExtArgs> | null
    /**
     * Filter which DeviceAccessLog to delete.
     */
    where: DeviceAccessLogWhereUniqueInput
  }

  /**
   * DeviceAccessLog deleteMany
   */
  export type DeviceAccessLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceAccessLogs to delete
     */
    where?: DeviceAccessLogWhereInput
    /**
     * Limit how many DeviceAccessLogs to delete.
     */
    limit?: number
  }

  /**
   * DeviceAccessLog without action
   */
  export type DeviceAccessLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceAccessLog
     */
    select?: DeviceAccessLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceAccessLog
     */
    omit?: DeviceAccessLogOmit<ExtArgs> | null
  }


  /**
   * Model DeviceCodes
   */

  export type AggregateDeviceCodes = {
    _count: DeviceCodesCountAggregateOutputType | null
    _min: DeviceCodesMinAggregateOutputType | null
    _max: DeviceCodesMaxAggregateOutputType | null
  }

  export type DeviceCodesMinAggregateOutputType = {
    UserCode: string | null
    DeviceCode: string | null
    SubjectId: string | null
    ClientId: string | null
    CreationTime: Date | null
    Expiration: Date | null
    Data: string | null
  }

  export type DeviceCodesMaxAggregateOutputType = {
    UserCode: string | null
    DeviceCode: string | null
    SubjectId: string | null
    ClientId: string | null
    CreationTime: Date | null
    Expiration: Date | null
    Data: string | null
  }

  export type DeviceCodesCountAggregateOutputType = {
    UserCode: number
    DeviceCode: number
    SubjectId: number
    ClientId: number
    CreationTime: number
    Expiration: number
    Data: number
    _all: number
  }


  export type DeviceCodesMinAggregateInputType = {
    UserCode?: true
    DeviceCode?: true
    SubjectId?: true
    ClientId?: true
    CreationTime?: true
    Expiration?: true
    Data?: true
  }

  export type DeviceCodesMaxAggregateInputType = {
    UserCode?: true
    DeviceCode?: true
    SubjectId?: true
    ClientId?: true
    CreationTime?: true
    Expiration?: true
    Data?: true
  }

  export type DeviceCodesCountAggregateInputType = {
    UserCode?: true
    DeviceCode?: true
    SubjectId?: true
    ClientId?: true
    CreationTime?: true
    Expiration?: true
    Data?: true
    _all?: true
  }

  export type DeviceCodesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceCodes to aggregate.
     */
    where?: DeviceCodesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceCodes to fetch.
     */
    orderBy?: DeviceCodesOrderByWithRelationInput | DeviceCodesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeviceCodesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeviceCodes
    **/
    _count?: true | DeviceCodesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeviceCodesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeviceCodesMaxAggregateInputType
  }

  export type GetDeviceCodesAggregateType<T extends DeviceCodesAggregateArgs> = {
        [P in keyof T & keyof AggregateDeviceCodes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeviceCodes[P]>
      : GetScalarType<T[P], AggregateDeviceCodes[P]>
  }




  export type DeviceCodesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceCodesWhereInput
    orderBy?: DeviceCodesOrderByWithAggregationInput | DeviceCodesOrderByWithAggregationInput[]
    by: DeviceCodesScalarFieldEnum[] | DeviceCodesScalarFieldEnum
    having?: DeviceCodesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeviceCodesCountAggregateInputType | true
    _min?: DeviceCodesMinAggregateInputType
    _max?: DeviceCodesMaxAggregateInputType
  }

  export type DeviceCodesGroupByOutputType = {
    UserCode: string
    DeviceCode: string
    SubjectId: string | null
    ClientId: string
    CreationTime: Date
    Expiration: Date
    Data: string
    _count: DeviceCodesCountAggregateOutputType | null
    _min: DeviceCodesMinAggregateOutputType | null
    _max: DeviceCodesMaxAggregateOutputType | null
  }

  type GetDeviceCodesGroupByPayload<T extends DeviceCodesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeviceCodesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeviceCodesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeviceCodesGroupByOutputType[P]>
            : GetScalarType<T[P], DeviceCodesGroupByOutputType[P]>
        }
      >
    >


  export type DeviceCodesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    UserCode?: boolean
    DeviceCode?: boolean
    SubjectId?: boolean
    ClientId?: boolean
    CreationTime?: boolean
    Expiration?: boolean
    Data?: boolean
  }, ExtArgs["result"]["deviceCodes"]>



  export type DeviceCodesSelectScalar = {
    UserCode?: boolean
    DeviceCode?: boolean
    SubjectId?: boolean
    ClientId?: boolean
    CreationTime?: boolean
    Expiration?: boolean
    Data?: boolean
  }

  export type DeviceCodesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"UserCode" | "DeviceCode" | "SubjectId" | "ClientId" | "CreationTime" | "Expiration" | "Data", ExtArgs["result"]["deviceCodes"]>

  export type $DeviceCodesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeviceCodes"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      UserCode: string
      DeviceCode: string
      SubjectId: string | null
      ClientId: string
      CreationTime: Date
      Expiration: Date
      Data: string
    }, ExtArgs["result"]["deviceCodes"]>
    composites: {}
  }

  type DeviceCodesGetPayload<S extends boolean | null | undefined | DeviceCodesDefaultArgs> = $Result.GetResult<Prisma.$DeviceCodesPayload, S>

  type DeviceCodesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeviceCodesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeviceCodesCountAggregateInputType | true
    }

  export interface DeviceCodesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeviceCodes'], meta: { name: 'DeviceCodes' } }
    /**
     * Find zero or one DeviceCodes that matches the filter.
     * @param {DeviceCodesFindUniqueArgs} args - Arguments to find a DeviceCodes
     * @example
     * // Get one DeviceCodes
     * const deviceCodes = await prisma.deviceCodes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeviceCodesFindUniqueArgs>(args: SelectSubset<T, DeviceCodesFindUniqueArgs<ExtArgs>>): Prisma__DeviceCodesClient<$Result.GetResult<Prisma.$DeviceCodesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DeviceCodes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeviceCodesFindUniqueOrThrowArgs} args - Arguments to find a DeviceCodes
     * @example
     * // Get one DeviceCodes
     * const deviceCodes = await prisma.deviceCodes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeviceCodesFindUniqueOrThrowArgs>(args: SelectSubset<T, DeviceCodesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeviceCodesClient<$Result.GetResult<Prisma.$DeviceCodesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeviceCodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceCodesFindFirstArgs} args - Arguments to find a DeviceCodes
     * @example
     * // Get one DeviceCodes
     * const deviceCodes = await prisma.deviceCodes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeviceCodesFindFirstArgs>(args?: SelectSubset<T, DeviceCodesFindFirstArgs<ExtArgs>>): Prisma__DeviceCodesClient<$Result.GetResult<Prisma.$DeviceCodesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeviceCodes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceCodesFindFirstOrThrowArgs} args - Arguments to find a DeviceCodes
     * @example
     * // Get one DeviceCodes
     * const deviceCodes = await prisma.deviceCodes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeviceCodesFindFirstOrThrowArgs>(args?: SelectSubset<T, DeviceCodesFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeviceCodesClient<$Result.GetResult<Prisma.$DeviceCodesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DeviceCodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceCodesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeviceCodes
     * const deviceCodes = await prisma.deviceCodes.findMany()
     * 
     * // Get first 10 DeviceCodes
     * const deviceCodes = await prisma.deviceCodes.findMany({ take: 10 })
     * 
     * // Only select the `UserCode`
     * const deviceCodesWithUserCodeOnly = await prisma.deviceCodes.findMany({ select: { UserCode: true } })
     * 
     */
    findMany<T extends DeviceCodesFindManyArgs>(args?: SelectSubset<T, DeviceCodesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceCodesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DeviceCodes.
     * @param {DeviceCodesCreateArgs} args - Arguments to create a DeviceCodes.
     * @example
     * // Create one DeviceCodes
     * const DeviceCodes = await prisma.deviceCodes.create({
     *   data: {
     *     // ... data to create a DeviceCodes
     *   }
     * })
     * 
     */
    create<T extends DeviceCodesCreateArgs>(args: SelectSubset<T, DeviceCodesCreateArgs<ExtArgs>>): Prisma__DeviceCodesClient<$Result.GetResult<Prisma.$DeviceCodesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DeviceCodes.
     * @param {DeviceCodesCreateManyArgs} args - Arguments to create many DeviceCodes.
     * @example
     * // Create many DeviceCodes
     * const deviceCodes = await prisma.deviceCodes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeviceCodesCreateManyArgs>(args?: SelectSubset<T, DeviceCodesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DeviceCodes.
     * @param {DeviceCodesDeleteArgs} args - Arguments to delete one DeviceCodes.
     * @example
     * // Delete one DeviceCodes
     * const DeviceCodes = await prisma.deviceCodes.delete({
     *   where: {
     *     // ... filter to delete one DeviceCodes
     *   }
     * })
     * 
     */
    delete<T extends DeviceCodesDeleteArgs>(args: SelectSubset<T, DeviceCodesDeleteArgs<ExtArgs>>): Prisma__DeviceCodesClient<$Result.GetResult<Prisma.$DeviceCodesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DeviceCodes.
     * @param {DeviceCodesUpdateArgs} args - Arguments to update one DeviceCodes.
     * @example
     * // Update one DeviceCodes
     * const deviceCodes = await prisma.deviceCodes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeviceCodesUpdateArgs>(args: SelectSubset<T, DeviceCodesUpdateArgs<ExtArgs>>): Prisma__DeviceCodesClient<$Result.GetResult<Prisma.$DeviceCodesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DeviceCodes.
     * @param {DeviceCodesDeleteManyArgs} args - Arguments to filter DeviceCodes to delete.
     * @example
     * // Delete a few DeviceCodes
     * const { count } = await prisma.deviceCodes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeviceCodesDeleteManyArgs>(args?: SelectSubset<T, DeviceCodesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeviceCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceCodesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeviceCodes
     * const deviceCodes = await prisma.deviceCodes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeviceCodesUpdateManyArgs>(args: SelectSubset<T, DeviceCodesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DeviceCodes.
     * @param {DeviceCodesUpsertArgs} args - Arguments to update or create a DeviceCodes.
     * @example
     * // Update or create a DeviceCodes
     * const deviceCodes = await prisma.deviceCodes.upsert({
     *   create: {
     *     // ... data to create a DeviceCodes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeviceCodes we want to update
     *   }
     * })
     */
    upsert<T extends DeviceCodesUpsertArgs>(args: SelectSubset<T, DeviceCodesUpsertArgs<ExtArgs>>): Prisma__DeviceCodesClient<$Result.GetResult<Prisma.$DeviceCodesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DeviceCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceCodesCountArgs} args - Arguments to filter DeviceCodes to count.
     * @example
     * // Count the number of DeviceCodes
     * const count = await prisma.deviceCodes.count({
     *   where: {
     *     // ... the filter for the DeviceCodes we want to count
     *   }
     * })
    **/
    count<T extends DeviceCodesCountArgs>(
      args?: Subset<T, DeviceCodesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeviceCodesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeviceCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceCodesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeviceCodesAggregateArgs>(args: Subset<T, DeviceCodesAggregateArgs>): Prisma.PrismaPromise<GetDeviceCodesAggregateType<T>>

    /**
     * Group by DeviceCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceCodesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeviceCodesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeviceCodesGroupByArgs['orderBy'] }
        : { orderBy?: DeviceCodesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeviceCodesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeviceCodesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeviceCodes model
   */
  readonly fields: DeviceCodesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeviceCodes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeviceCodesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeviceCodes model
   */
  interface DeviceCodesFieldRefs {
    readonly UserCode: FieldRef<"DeviceCodes", 'String'>
    readonly DeviceCode: FieldRef<"DeviceCodes", 'String'>
    readonly SubjectId: FieldRef<"DeviceCodes", 'String'>
    readonly ClientId: FieldRef<"DeviceCodes", 'String'>
    readonly CreationTime: FieldRef<"DeviceCodes", 'DateTime'>
    readonly Expiration: FieldRef<"DeviceCodes", 'DateTime'>
    readonly Data: FieldRef<"DeviceCodes", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DeviceCodes findUnique
   */
  export type DeviceCodesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceCodes
     */
    select?: DeviceCodesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceCodes
     */
    omit?: DeviceCodesOmit<ExtArgs> | null
    /**
     * Filter, which DeviceCodes to fetch.
     */
    where: DeviceCodesWhereUniqueInput
  }

  /**
   * DeviceCodes findUniqueOrThrow
   */
  export type DeviceCodesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceCodes
     */
    select?: DeviceCodesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceCodes
     */
    omit?: DeviceCodesOmit<ExtArgs> | null
    /**
     * Filter, which DeviceCodes to fetch.
     */
    where: DeviceCodesWhereUniqueInput
  }

  /**
   * DeviceCodes findFirst
   */
  export type DeviceCodesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceCodes
     */
    select?: DeviceCodesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceCodes
     */
    omit?: DeviceCodesOmit<ExtArgs> | null
    /**
     * Filter, which DeviceCodes to fetch.
     */
    where?: DeviceCodesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceCodes to fetch.
     */
    orderBy?: DeviceCodesOrderByWithRelationInput | DeviceCodesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceCodes.
     */
    cursor?: DeviceCodesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceCodes.
     */
    distinct?: DeviceCodesScalarFieldEnum | DeviceCodesScalarFieldEnum[]
  }

  /**
   * DeviceCodes findFirstOrThrow
   */
  export type DeviceCodesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceCodes
     */
    select?: DeviceCodesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceCodes
     */
    omit?: DeviceCodesOmit<ExtArgs> | null
    /**
     * Filter, which DeviceCodes to fetch.
     */
    where?: DeviceCodesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceCodes to fetch.
     */
    orderBy?: DeviceCodesOrderByWithRelationInput | DeviceCodesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceCodes.
     */
    cursor?: DeviceCodesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceCodes.
     */
    distinct?: DeviceCodesScalarFieldEnum | DeviceCodesScalarFieldEnum[]
  }

  /**
   * DeviceCodes findMany
   */
  export type DeviceCodesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceCodes
     */
    select?: DeviceCodesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceCodes
     */
    omit?: DeviceCodesOmit<ExtArgs> | null
    /**
     * Filter, which DeviceCodes to fetch.
     */
    where?: DeviceCodesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceCodes to fetch.
     */
    orderBy?: DeviceCodesOrderByWithRelationInput | DeviceCodesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeviceCodes.
     */
    cursor?: DeviceCodesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceCodes.
     */
    skip?: number
    distinct?: DeviceCodesScalarFieldEnum | DeviceCodesScalarFieldEnum[]
  }

  /**
   * DeviceCodes create
   */
  export type DeviceCodesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceCodes
     */
    select?: DeviceCodesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceCodes
     */
    omit?: DeviceCodesOmit<ExtArgs> | null
    /**
     * The data needed to create a DeviceCodes.
     */
    data: XOR<DeviceCodesCreateInput, DeviceCodesUncheckedCreateInput>
  }

  /**
   * DeviceCodes createMany
   */
  export type DeviceCodesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeviceCodes.
     */
    data: DeviceCodesCreateManyInput | DeviceCodesCreateManyInput[]
  }

  /**
   * DeviceCodes update
   */
  export type DeviceCodesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceCodes
     */
    select?: DeviceCodesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceCodes
     */
    omit?: DeviceCodesOmit<ExtArgs> | null
    /**
     * The data needed to update a DeviceCodes.
     */
    data: XOR<DeviceCodesUpdateInput, DeviceCodesUncheckedUpdateInput>
    /**
     * Choose, which DeviceCodes to update.
     */
    where: DeviceCodesWhereUniqueInput
  }

  /**
   * DeviceCodes updateMany
   */
  export type DeviceCodesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeviceCodes.
     */
    data: XOR<DeviceCodesUpdateManyMutationInput, DeviceCodesUncheckedUpdateManyInput>
    /**
     * Filter which DeviceCodes to update
     */
    where?: DeviceCodesWhereInput
    /**
     * Limit how many DeviceCodes to update.
     */
    limit?: number
  }

  /**
   * DeviceCodes upsert
   */
  export type DeviceCodesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceCodes
     */
    select?: DeviceCodesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceCodes
     */
    omit?: DeviceCodesOmit<ExtArgs> | null
    /**
     * The filter to search for the DeviceCodes to update in case it exists.
     */
    where: DeviceCodesWhereUniqueInput
    /**
     * In case the DeviceCodes found by the `where` argument doesn't exist, create a new DeviceCodes with this data.
     */
    create: XOR<DeviceCodesCreateInput, DeviceCodesUncheckedCreateInput>
    /**
     * In case the DeviceCodes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeviceCodesUpdateInput, DeviceCodesUncheckedUpdateInput>
  }

  /**
   * DeviceCodes delete
   */
  export type DeviceCodesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceCodes
     */
    select?: DeviceCodesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceCodes
     */
    omit?: DeviceCodesOmit<ExtArgs> | null
    /**
     * Filter which DeviceCodes to delete.
     */
    where: DeviceCodesWhereUniqueInput
  }

  /**
   * DeviceCodes deleteMany
   */
  export type DeviceCodesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceCodes to delete
     */
    where?: DeviceCodesWhereInput
    /**
     * Limit how many DeviceCodes to delete.
     */
    limit?: number
  }

  /**
   * DeviceCodes without action
   */
  export type DeviceCodesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceCodes
     */
    select?: DeviceCodesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceCodes
     */
    omit?: DeviceCodesOmit<ExtArgs> | null
  }


  /**
   * Model EwPayActivatedCards
   */

  export type AggregateEwPayActivatedCards = {
    _count: EwPayActivatedCardsCountAggregateOutputType | null
    _avg: EwPayActivatedCardsAvgAggregateOutputType | null
    _sum: EwPayActivatedCardsSumAggregateOutputType | null
    _min: EwPayActivatedCardsMinAggregateOutputType | null
    _max: EwPayActivatedCardsMaxAggregateOutputType | null
  }

  export type EwPayActivatedCardsAvgAggregateOutputType = {
    Id: number | null
  }

  export type EwPayActivatedCardsSumAggregateOutputType = {
    Id: number | null
  }

  export type EwPayActivatedCardsMinAggregateOutputType = {
    Id: number | null
    UCRN: string | null
    DateActivated: Date | null
  }

  export type EwPayActivatedCardsMaxAggregateOutputType = {
    Id: number | null
    UCRN: string | null
    DateActivated: Date | null
  }

  export type EwPayActivatedCardsCountAggregateOutputType = {
    Id: number
    UCRN: number
    DateActivated: number
    _all: number
  }


  export type EwPayActivatedCardsAvgAggregateInputType = {
    Id?: true
  }

  export type EwPayActivatedCardsSumAggregateInputType = {
    Id?: true
  }

  export type EwPayActivatedCardsMinAggregateInputType = {
    Id?: true
    UCRN?: true
    DateActivated?: true
  }

  export type EwPayActivatedCardsMaxAggregateInputType = {
    Id?: true
    UCRN?: true
    DateActivated?: true
  }

  export type EwPayActivatedCardsCountAggregateInputType = {
    Id?: true
    UCRN?: true
    DateActivated?: true
    _all?: true
  }

  export type EwPayActivatedCardsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EwPayActivatedCards to aggregate.
     */
    where?: EwPayActivatedCardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EwPayActivatedCards to fetch.
     */
    orderBy?: EwPayActivatedCardsOrderByWithRelationInput | EwPayActivatedCardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EwPayActivatedCardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EwPayActivatedCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EwPayActivatedCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EwPayActivatedCards
    **/
    _count?: true | EwPayActivatedCardsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EwPayActivatedCardsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EwPayActivatedCardsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EwPayActivatedCardsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EwPayActivatedCardsMaxAggregateInputType
  }

  export type GetEwPayActivatedCardsAggregateType<T extends EwPayActivatedCardsAggregateArgs> = {
        [P in keyof T & keyof AggregateEwPayActivatedCards]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEwPayActivatedCards[P]>
      : GetScalarType<T[P], AggregateEwPayActivatedCards[P]>
  }




  export type EwPayActivatedCardsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EwPayActivatedCardsWhereInput
    orderBy?: EwPayActivatedCardsOrderByWithAggregationInput | EwPayActivatedCardsOrderByWithAggregationInput[]
    by: EwPayActivatedCardsScalarFieldEnum[] | EwPayActivatedCardsScalarFieldEnum
    having?: EwPayActivatedCardsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EwPayActivatedCardsCountAggregateInputType | true
    _avg?: EwPayActivatedCardsAvgAggregateInputType
    _sum?: EwPayActivatedCardsSumAggregateInputType
    _min?: EwPayActivatedCardsMinAggregateInputType
    _max?: EwPayActivatedCardsMaxAggregateInputType
  }

  export type EwPayActivatedCardsGroupByOutputType = {
    Id: number
    UCRN: string | null
    DateActivated: Date
    _count: EwPayActivatedCardsCountAggregateOutputType | null
    _avg: EwPayActivatedCardsAvgAggregateOutputType | null
    _sum: EwPayActivatedCardsSumAggregateOutputType | null
    _min: EwPayActivatedCardsMinAggregateOutputType | null
    _max: EwPayActivatedCardsMaxAggregateOutputType | null
  }

  type GetEwPayActivatedCardsGroupByPayload<T extends EwPayActivatedCardsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EwPayActivatedCardsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EwPayActivatedCardsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EwPayActivatedCardsGroupByOutputType[P]>
            : GetScalarType<T[P], EwPayActivatedCardsGroupByOutputType[P]>
        }
      >
    >


  export type EwPayActivatedCardsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    UCRN?: boolean
    DateActivated?: boolean
  }, ExtArgs["result"]["ewPayActivatedCards"]>



  export type EwPayActivatedCardsSelectScalar = {
    Id?: boolean
    UCRN?: boolean
    DateActivated?: boolean
  }

  export type EwPayActivatedCardsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Id" | "UCRN" | "DateActivated", ExtArgs["result"]["ewPayActivatedCards"]>

  export type $EwPayActivatedCardsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EwPayActivatedCards"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      Id: number
      UCRN: string | null
      DateActivated: Date
    }, ExtArgs["result"]["ewPayActivatedCards"]>
    composites: {}
  }

  type EwPayActivatedCardsGetPayload<S extends boolean | null | undefined | EwPayActivatedCardsDefaultArgs> = $Result.GetResult<Prisma.$EwPayActivatedCardsPayload, S>

  type EwPayActivatedCardsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EwPayActivatedCardsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EwPayActivatedCardsCountAggregateInputType | true
    }

  export interface EwPayActivatedCardsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EwPayActivatedCards'], meta: { name: 'EwPayActivatedCards' } }
    /**
     * Find zero or one EwPayActivatedCards that matches the filter.
     * @param {EwPayActivatedCardsFindUniqueArgs} args - Arguments to find a EwPayActivatedCards
     * @example
     * // Get one EwPayActivatedCards
     * const ewPayActivatedCards = await prisma.ewPayActivatedCards.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EwPayActivatedCardsFindUniqueArgs>(args: SelectSubset<T, EwPayActivatedCardsFindUniqueArgs<ExtArgs>>): Prisma__EwPayActivatedCardsClient<$Result.GetResult<Prisma.$EwPayActivatedCardsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EwPayActivatedCards that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EwPayActivatedCardsFindUniqueOrThrowArgs} args - Arguments to find a EwPayActivatedCards
     * @example
     * // Get one EwPayActivatedCards
     * const ewPayActivatedCards = await prisma.ewPayActivatedCards.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EwPayActivatedCardsFindUniqueOrThrowArgs>(args: SelectSubset<T, EwPayActivatedCardsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EwPayActivatedCardsClient<$Result.GetResult<Prisma.$EwPayActivatedCardsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EwPayActivatedCards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EwPayActivatedCardsFindFirstArgs} args - Arguments to find a EwPayActivatedCards
     * @example
     * // Get one EwPayActivatedCards
     * const ewPayActivatedCards = await prisma.ewPayActivatedCards.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EwPayActivatedCardsFindFirstArgs>(args?: SelectSubset<T, EwPayActivatedCardsFindFirstArgs<ExtArgs>>): Prisma__EwPayActivatedCardsClient<$Result.GetResult<Prisma.$EwPayActivatedCardsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EwPayActivatedCards that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EwPayActivatedCardsFindFirstOrThrowArgs} args - Arguments to find a EwPayActivatedCards
     * @example
     * // Get one EwPayActivatedCards
     * const ewPayActivatedCards = await prisma.ewPayActivatedCards.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EwPayActivatedCardsFindFirstOrThrowArgs>(args?: SelectSubset<T, EwPayActivatedCardsFindFirstOrThrowArgs<ExtArgs>>): Prisma__EwPayActivatedCardsClient<$Result.GetResult<Prisma.$EwPayActivatedCardsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EwPayActivatedCards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EwPayActivatedCardsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EwPayActivatedCards
     * const ewPayActivatedCards = await prisma.ewPayActivatedCards.findMany()
     * 
     * // Get first 10 EwPayActivatedCards
     * const ewPayActivatedCards = await prisma.ewPayActivatedCards.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const ewPayActivatedCardsWithIdOnly = await prisma.ewPayActivatedCards.findMany({ select: { Id: true } })
     * 
     */
    findMany<T extends EwPayActivatedCardsFindManyArgs>(args?: SelectSubset<T, EwPayActivatedCardsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EwPayActivatedCardsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EwPayActivatedCards.
     * @param {EwPayActivatedCardsCreateArgs} args - Arguments to create a EwPayActivatedCards.
     * @example
     * // Create one EwPayActivatedCards
     * const EwPayActivatedCards = await prisma.ewPayActivatedCards.create({
     *   data: {
     *     // ... data to create a EwPayActivatedCards
     *   }
     * })
     * 
     */
    create<T extends EwPayActivatedCardsCreateArgs>(args: SelectSubset<T, EwPayActivatedCardsCreateArgs<ExtArgs>>): Prisma__EwPayActivatedCardsClient<$Result.GetResult<Prisma.$EwPayActivatedCardsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EwPayActivatedCards.
     * @param {EwPayActivatedCardsCreateManyArgs} args - Arguments to create many EwPayActivatedCards.
     * @example
     * // Create many EwPayActivatedCards
     * const ewPayActivatedCards = await prisma.ewPayActivatedCards.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EwPayActivatedCardsCreateManyArgs>(args?: SelectSubset<T, EwPayActivatedCardsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EwPayActivatedCards.
     * @param {EwPayActivatedCardsDeleteArgs} args - Arguments to delete one EwPayActivatedCards.
     * @example
     * // Delete one EwPayActivatedCards
     * const EwPayActivatedCards = await prisma.ewPayActivatedCards.delete({
     *   where: {
     *     // ... filter to delete one EwPayActivatedCards
     *   }
     * })
     * 
     */
    delete<T extends EwPayActivatedCardsDeleteArgs>(args: SelectSubset<T, EwPayActivatedCardsDeleteArgs<ExtArgs>>): Prisma__EwPayActivatedCardsClient<$Result.GetResult<Prisma.$EwPayActivatedCardsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EwPayActivatedCards.
     * @param {EwPayActivatedCardsUpdateArgs} args - Arguments to update one EwPayActivatedCards.
     * @example
     * // Update one EwPayActivatedCards
     * const ewPayActivatedCards = await prisma.ewPayActivatedCards.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EwPayActivatedCardsUpdateArgs>(args: SelectSubset<T, EwPayActivatedCardsUpdateArgs<ExtArgs>>): Prisma__EwPayActivatedCardsClient<$Result.GetResult<Prisma.$EwPayActivatedCardsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EwPayActivatedCards.
     * @param {EwPayActivatedCardsDeleteManyArgs} args - Arguments to filter EwPayActivatedCards to delete.
     * @example
     * // Delete a few EwPayActivatedCards
     * const { count } = await prisma.ewPayActivatedCards.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EwPayActivatedCardsDeleteManyArgs>(args?: SelectSubset<T, EwPayActivatedCardsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EwPayActivatedCards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EwPayActivatedCardsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EwPayActivatedCards
     * const ewPayActivatedCards = await prisma.ewPayActivatedCards.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EwPayActivatedCardsUpdateManyArgs>(args: SelectSubset<T, EwPayActivatedCardsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EwPayActivatedCards.
     * @param {EwPayActivatedCardsUpsertArgs} args - Arguments to update or create a EwPayActivatedCards.
     * @example
     * // Update or create a EwPayActivatedCards
     * const ewPayActivatedCards = await prisma.ewPayActivatedCards.upsert({
     *   create: {
     *     // ... data to create a EwPayActivatedCards
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EwPayActivatedCards we want to update
     *   }
     * })
     */
    upsert<T extends EwPayActivatedCardsUpsertArgs>(args: SelectSubset<T, EwPayActivatedCardsUpsertArgs<ExtArgs>>): Prisma__EwPayActivatedCardsClient<$Result.GetResult<Prisma.$EwPayActivatedCardsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EwPayActivatedCards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EwPayActivatedCardsCountArgs} args - Arguments to filter EwPayActivatedCards to count.
     * @example
     * // Count the number of EwPayActivatedCards
     * const count = await prisma.ewPayActivatedCards.count({
     *   where: {
     *     // ... the filter for the EwPayActivatedCards we want to count
     *   }
     * })
    **/
    count<T extends EwPayActivatedCardsCountArgs>(
      args?: Subset<T, EwPayActivatedCardsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EwPayActivatedCardsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EwPayActivatedCards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EwPayActivatedCardsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EwPayActivatedCardsAggregateArgs>(args: Subset<T, EwPayActivatedCardsAggregateArgs>): Prisma.PrismaPromise<GetEwPayActivatedCardsAggregateType<T>>

    /**
     * Group by EwPayActivatedCards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EwPayActivatedCardsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EwPayActivatedCardsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EwPayActivatedCardsGroupByArgs['orderBy'] }
        : { orderBy?: EwPayActivatedCardsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EwPayActivatedCardsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEwPayActivatedCardsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EwPayActivatedCards model
   */
  readonly fields: EwPayActivatedCardsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EwPayActivatedCards.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EwPayActivatedCardsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EwPayActivatedCards model
   */
  interface EwPayActivatedCardsFieldRefs {
    readonly Id: FieldRef<"EwPayActivatedCards", 'Int'>
    readonly UCRN: FieldRef<"EwPayActivatedCards", 'String'>
    readonly DateActivated: FieldRef<"EwPayActivatedCards", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EwPayActivatedCards findUnique
   */
  export type EwPayActivatedCardsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwPayActivatedCards
     */
    select?: EwPayActivatedCardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EwPayActivatedCards
     */
    omit?: EwPayActivatedCardsOmit<ExtArgs> | null
    /**
     * Filter, which EwPayActivatedCards to fetch.
     */
    where: EwPayActivatedCardsWhereUniqueInput
  }

  /**
   * EwPayActivatedCards findUniqueOrThrow
   */
  export type EwPayActivatedCardsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwPayActivatedCards
     */
    select?: EwPayActivatedCardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EwPayActivatedCards
     */
    omit?: EwPayActivatedCardsOmit<ExtArgs> | null
    /**
     * Filter, which EwPayActivatedCards to fetch.
     */
    where: EwPayActivatedCardsWhereUniqueInput
  }

  /**
   * EwPayActivatedCards findFirst
   */
  export type EwPayActivatedCardsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwPayActivatedCards
     */
    select?: EwPayActivatedCardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EwPayActivatedCards
     */
    omit?: EwPayActivatedCardsOmit<ExtArgs> | null
    /**
     * Filter, which EwPayActivatedCards to fetch.
     */
    where?: EwPayActivatedCardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EwPayActivatedCards to fetch.
     */
    orderBy?: EwPayActivatedCardsOrderByWithRelationInput | EwPayActivatedCardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EwPayActivatedCards.
     */
    cursor?: EwPayActivatedCardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EwPayActivatedCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EwPayActivatedCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EwPayActivatedCards.
     */
    distinct?: EwPayActivatedCardsScalarFieldEnum | EwPayActivatedCardsScalarFieldEnum[]
  }

  /**
   * EwPayActivatedCards findFirstOrThrow
   */
  export type EwPayActivatedCardsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwPayActivatedCards
     */
    select?: EwPayActivatedCardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EwPayActivatedCards
     */
    omit?: EwPayActivatedCardsOmit<ExtArgs> | null
    /**
     * Filter, which EwPayActivatedCards to fetch.
     */
    where?: EwPayActivatedCardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EwPayActivatedCards to fetch.
     */
    orderBy?: EwPayActivatedCardsOrderByWithRelationInput | EwPayActivatedCardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EwPayActivatedCards.
     */
    cursor?: EwPayActivatedCardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EwPayActivatedCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EwPayActivatedCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EwPayActivatedCards.
     */
    distinct?: EwPayActivatedCardsScalarFieldEnum | EwPayActivatedCardsScalarFieldEnum[]
  }

  /**
   * EwPayActivatedCards findMany
   */
  export type EwPayActivatedCardsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwPayActivatedCards
     */
    select?: EwPayActivatedCardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EwPayActivatedCards
     */
    omit?: EwPayActivatedCardsOmit<ExtArgs> | null
    /**
     * Filter, which EwPayActivatedCards to fetch.
     */
    where?: EwPayActivatedCardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EwPayActivatedCards to fetch.
     */
    orderBy?: EwPayActivatedCardsOrderByWithRelationInput | EwPayActivatedCardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EwPayActivatedCards.
     */
    cursor?: EwPayActivatedCardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EwPayActivatedCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EwPayActivatedCards.
     */
    skip?: number
    distinct?: EwPayActivatedCardsScalarFieldEnum | EwPayActivatedCardsScalarFieldEnum[]
  }

  /**
   * EwPayActivatedCards create
   */
  export type EwPayActivatedCardsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwPayActivatedCards
     */
    select?: EwPayActivatedCardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EwPayActivatedCards
     */
    omit?: EwPayActivatedCardsOmit<ExtArgs> | null
    /**
     * The data needed to create a EwPayActivatedCards.
     */
    data: XOR<EwPayActivatedCardsCreateInput, EwPayActivatedCardsUncheckedCreateInput>
  }

  /**
   * EwPayActivatedCards createMany
   */
  export type EwPayActivatedCardsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EwPayActivatedCards.
     */
    data: EwPayActivatedCardsCreateManyInput | EwPayActivatedCardsCreateManyInput[]
  }

  /**
   * EwPayActivatedCards update
   */
  export type EwPayActivatedCardsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwPayActivatedCards
     */
    select?: EwPayActivatedCardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EwPayActivatedCards
     */
    omit?: EwPayActivatedCardsOmit<ExtArgs> | null
    /**
     * The data needed to update a EwPayActivatedCards.
     */
    data: XOR<EwPayActivatedCardsUpdateInput, EwPayActivatedCardsUncheckedUpdateInput>
    /**
     * Choose, which EwPayActivatedCards to update.
     */
    where: EwPayActivatedCardsWhereUniqueInput
  }

  /**
   * EwPayActivatedCards updateMany
   */
  export type EwPayActivatedCardsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EwPayActivatedCards.
     */
    data: XOR<EwPayActivatedCardsUpdateManyMutationInput, EwPayActivatedCardsUncheckedUpdateManyInput>
    /**
     * Filter which EwPayActivatedCards to update
     */
    where?: EwPayActivatedCardsWhereInput
    /**
     * Limit how many EwPayActivatedCards to update.
     */
    limit?: number
  }

  /**
   * EwPayActivatedCards upsert
   */
  export type EwPayActivatedCardsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwPayActivatedCards
     */
    select?: EwPayActivatedCardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EwPayActivatedCards
     */
    omit?: EwPayActivatedCardsOmit<ExtArgs> | null
    /**
     * The filter to search for the EwPayActivatedCards to update in case it exists.
     */
    where: EwPayActivatedCardsWhereUniqueInput
    /**
     * In case the EwPayActivatedCards found by the `where` argument doesn't exist, create a new EwPayActivatedCards with this data.
     */
    create: XOR<EwPayActivatedCardsCreateInput, EwPayActivatedCardsUncheckedCreateInput>
    /**
     * In case the EwPayActivatedCards was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EwPayActivatedCardsUpdateInput, EwPayActivatedCardsUncheckedUpdateInput>
  }

  /**
   * EwPayActivatedCards delete
   */
  export type EwPayActivatedCardsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwPayActivatedCards
     */
    select?: EwPayActivatedCardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EwPayActivatedCards
     */
    omit?: EwPayActivatedCardsOmit<ExtArgs> | null
    /**
     * Filter which EwPayActivatedCards to delete.
     */
    where: EwPayActivatedCardsWhereUniqueInput
  }

  /**
   * EwPayActivatedCards deleteMany
   */
  export type EwPayActivatedCardsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EwPayActivatedCards to delete
     */
    where?: EwPayActivatedCardsWhereInput
    /**
     * Limit how many EwPayActivatedCards to delete.
     */
    limit?: number
  }

  /**
   * EwPayActivatedCards without action
   */
  export type EwPayActivatedCardsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwPayActivatedCards
     */
    select?: EwPayActivatedCardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EwPayActivatedCards
     */
    omit?: EwPayActivatedCardsOmit<ExtArgs> | null
  }


  /**
   * Model EwPayIneligibleCards
   */

  export type AggregateEwPayIneligibleCards = {
    _count: EwPayIneligibleCardsCountAggregateOutputType | null
    _avg: EwPayIneligibleCardsAvgAggregateOutputType | null
    _sum: EwPayIneligibleCardsSumAggregateOutputType | null
    _min: EwPayIneligibleCardsMinAggregateOutputType | null
    _max: EwPayIneligibleCardsMaxAggregateOutputType | null
  }

  export type EwPayIneligibleCardsAvgAggregateOutputType = {
    Id: number | null
  }

  export type EwPayIneligibleCardsSumAggregateOutputType = {
    Id: number | null
  }

  export type EwPayIneligibleCardsMinAggregateOutputType = {
    Id: number | null
    UCRN: string | null
    IsReported: boolean | null
    IsActivated: boolean | null
    DateReported: Date | null
  }

  export type EwPayIneligibleCardsMaxAggregateOutputType = {
    Id: number | null
    UCRN: string | null
    IsReported: boolean | null
    IsActivated: boolean | null
    DateReported: Date | null
  }

  export type EwPayIneligibleCardsCountAggregateOutputType = {
    Id: number
    UCRN: number
    IsReported: number
    IsActivated: number
    DateReported: number
    _all: number
  }


  export type EwPayIneligibleCardsAvgAggregateInputType = {
    Id?: true
  }

  export type EwPayIneligibleCardsSumAggregateInputType = {
    Id?: true
  }

  export type EwPayIneligibleCardsMinAggregateInputType = {
    Id?: true
    UCRN?: true
    IsReported?: true
    IsActivated?: true
    DateReported?: true
  }

  export type EwPayIneligibleCardsMaxAggregateInputType = {
    Id?: true
    UCRN?: true
    IsReported?: true
    IsActivated?: true
    DateReported?: true
  }

  export type EwPayIneligibleCardsCountAggregateInputType = {
    Id?: true
    UCRN?: true
    IsReported?: true
    IsActivated?: true
    DateReported?: true
    _all?: true
  }

  export type EwPayIneligibleCardsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EwPayIneligibleCards to aggregate.
     */
    where?: EwPayIneligibleCardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EwPayIneligibleCards to fetch.
     */
    orderBy?: EwPayIneligibleCardsOrderByWithRelationInput | EwPayIneligibleCardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EwPayIneligibleCardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EwPayIneligibleCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EwPayIneligibleCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EwPayIneligibleCards
    **/
    _count?: true | EwPayIneligibleCardsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EwPayIneligibleCardsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EwPayIneligibleCardsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EwPayIneligibleCardsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EwPayIneligibleCardsMaxAggregateInputType
  }

  export type GetEwPayIneligibleCardsAggregateType<T extends EwPayIneligibleCardsAggregateArgs> = {
        [P in keyof T & keyof AggregateEwPayIneligibleCards]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEwPayIneligibleCards[P]>
      : GetScalarType<T[P], AggregateEwPayIneligibleCards[P]>
  }




  export type EwPayIneligibleCardsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EwPayIneligibleCardsWhereInput
    orderBy?: EwPayIneligibleCardsOrderByWithAggregationInput | EwPayIneligibleCardsOrderByWithAggregationInput[]
    by: EwPayIneligibleCardsScalarFieldEnum[] | EwPayIneligibleCardsScalarFieldEnum
    having?: EwPayIneligibleCardsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EwPayIneligibleCardsCountAggregateInputType | true
    _avg?: EwPayIneligibleCardsAvgAggregateInputType
    _sum?: EwPayIneligibleCardsSumAggregateInputType
    _min?: EwPayIneligibleCardsMinAggregateInputType
    _max?: EwPayIneligibleCardsMaxAggregateInputType
  }

  export type EwPayIneligibleCardsGroupByOutputType = {
    Id: number
    UCRN: string | null
    IsReported: boolean
    IsActivated: boolean
    DateReported: Date
    _count: EwPayIneligibleCardsCountAggregateOutputType | null
    _avg: EwPayIneligibleCardsAvgAggregateOutputType | null
    _sum: EwPayIneligibleCardsSumAggregateOutputType | null
    _min: EwPayIneligibleCardsMinAggregateOutputType | null
    _max: EwPayIneligibleCardsMaxAggregateOutputType | null
  }

  type GetEwPayIneligibleCardsGroupByPayload<T extends EwPayIneligibleCardsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EwPayIneligibleCardsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EwPayIneligibleCardsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EwPayIneligibleCardsGroupByOutputType[P]>
            : GetScalarType<T[P], EwPayIneligibleCardsGroupByOutputType[P]>
        }
      >
    >


  export type EwPayIneligibleCardsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    UCRN?: boolean
    IsReported?: boolean
    IsActivated?: boolean
    DateReported?: boolean
  }, ExtArgs["result"]["ewPayIneligibleCards"]>



  export type EwPayIneligibleCardsSelectScalar = {
    Id?: boolean
    UCRN?: boolean
    IsReported?: boolean
    IsActivated?: boolean
    DateReported?: boolean
  }

  export type EwPayIneligibleCardsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Id" | "UCRN" | "IsReported" | "IsActivated" | "DateReported", ExtArgs["result"]["ewPayIneligibleCards"]>

  export type $EwPayIneligibleCardsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EwPayIneligibleCards"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      Id: number
      UCRN: string | null
      IsReported: boolean
      IsActivated: boolean
      DateReported: Date
    }, ExtArgs["result"]["ewPayIneligibleCards"]>
    composites: {}
  }

  type EwPayIneligibleCardsGetPayload<S extends boolean | null | undefined | EwPayIneligibleCardsDefaultArgs> = $Result.GetResult<Prisma.$EwPayIneligibleCardsPayload, S>

  type EwPayIneligibleCardsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EwPayIneligibleCardsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EwPayIneligibleCardsCountAggregateInputType | true
    }

  export interface EwPayIneligibleCardsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EwPayIneligibleCards'], meta: { name: 'EwPayIneligibleCards' } }
    /**
     * Find zero or one EwPayIneligibleCards that matches the filter.
     * @param {EwPayIneligibleCardsFindUniqueArgs} args - Arguments to find a EwPayIneligibleCards
     * @example
     * // Get one EwPayIneligibleCards
     * const ewPayIneligibleCards = await prisma.ewPayIneligibleCards.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EwPayIneligibleCardsFindUniqueArgs>(args: SelectSubset<T, EwPayIneligibleCardsFindUniqueArgs<ExtArgs>>): Prisma__EwPayIneligibleCardsClient<$Result.GetResult<Prisma.$EwPayIneligibleCardsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EwPayIneligibleCards that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EwPayIneligibleCardsFindUniqueOrThrowArgs} args - Arguments to find a EwPayIneligibleCards
     * @example
     * // Get one EwPayIneligibleCards
     * const ewPayIneligibleCards = await prisma.ewPayIneligibleCards.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EwPayIneligibleCardsFindUniqueOrThrowArgs>(args: SelectSubset<T, EwPayIneligibleCardsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EwPayIneligibleCardsClient<$Result.GetResult<Prisma.$EwPayIneligibleCardsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EwPayIneligibleCards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EwPayIneligibleCardsFindFirstArgs} args - Arguments to find a EwPayIneligibleCards
     * @example
     * // Get one EwPayIneligibleCards
     * const ewPayIneligibleCards = await prisma.ewPayIneligibleCards.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EwPayIneligibleCardsFindFirstArgs>(args?: SelectSubset<T, EwPayIneligibleCardsFindFirstArgs<ExtArgs>>): Prisma__EwPayIneligibleCardsClient<$Result.GetResult<Prisma.$EwPayIneligibleCardsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EwPayIneligibleCards that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EwPayIneligibleCardsFindFirstOrThrowArgs} args - Arguments to find a EwPayIneligibleCards
     * @example
     * // Get one EwPayIneligibleCards
     * const ewPayIneligibleCards = await prisma.ewPayIneligibleCards.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EwPayIneligibleCardsFindFirstOrThrowArgs>(args?: SelectSubset<T, EwPayIneligibleCardsFindFirstOrThrowArgs<ExtArgs>>): Prisma__EwPayIneligibleCardsClient<$Result.GetResult<Prisma.$EwPayIneligibleCardsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EwPayIneligibleCards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EwPayIneligibleCardsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EwPayIneligibleCards
     * const ewPayIneligibleCards = await prisma.ewPayIneligibleCards.findMany()
     * 
     * // Get first 10 EwPayIneligibleCards
     * const ewPayIneligibleCards = await prisma.ewPayIneligibleCards.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const ewPayIneligibleCardsWithIdOnly = await prisma.ewPayIneligibleCards.findMany({ select: { Id: true } })
     * 
     */
    findMany<T extends EwPayIneligibleCardsFindManyArgs>(args?: SelectSubset<T, EwPayIneligibleCardsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EwPayIneligibleCardsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EwPayIneligibleCards.
     * @param {EwPayIneligibleCardsCreateArgs} args - Arguments to create a EwPayIneligibleCards.
     * @example
     * // Create one EwPayIneligibleCards
     * const EwPayIneligibleCards = await prisma.ewPayIneligibleCards.create({
     *   data: {
     *     // ... data to create a EwPayIneligibleCards
     *   }
     * })
     * 
     */
    create<T extends EwPayIneligibleCardsCreateArgs>(args: SelectSubset<T, EwPayIneligibleCardsCreateArgs<ExtArgs>>): Prisma__EwPayIneligibleCardsClient<$Result.GetResult<Prisma.$EwPayIneligibleCardsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EwPayIneligibleCards.
     * @param {EwPayIneligibleCardsCreateManyArgs} args - Arguments to create many EwPayIneligibleCards.
     * @example
     * // Create many EwPayIneligibleCards
     * const ewPayIneligibleCards = await prisma.ewPayIneligibleCards.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EwPayIneligibleCardsCreateManyArgs>(args?: SelectSubset<T, EwPayIneligibleCardsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EwPayIneligibleCards.
     * @param {EwPayIneligibleCardsDeleteArgs} args - Arguments to delete one EwPayIneligibleCards.
     * @example
     * // Delete one EwPayIneligibleCards
     * const EwPayIneligibleCards = await prisma.ewPayIneligibleCards.delete({
     *   where: {
     *     // ... filter to delete one EwPayIneligibleCards
     *   }
     * })
     * 
     */
    delete<T extends EwPayIneligibleCardsDeleteArgs>(args: SelectSubset<T, EwPayIneligibleCardsDeleteArgs<ExtArgs>>): Prisma__EwPayIneligibleCardsClient<$Result.GetResult<Prisma.$EwPayIneligibleCardsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EwPayIneligibleCards.
     * @param {EwPayIneligibleCardsUpdateArgs} args - Arguments to update one EwPayIneligibleCards.
     * @example
     * // Update one EwPayIneligibleCards
     * const ewPayIneligibleCards = await prisma.ewPayIneligibleCards.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EwPayIneligibleCardsUpdateArgs>(args: SelectSubset<T, EwPayIneligibleCardsUpdateArgs<ExtArgs>>): Prisma__EwPayIneligibleCardsClient<$Result.GetResult<Prisma.$EwPayIneligibleCardsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EwPayIneligibleCards.
     * @param {EwPayIneligibleCardsDeleteManyArgs} args - Arguments to filter EwPayIneligibleCards to delete.
     * @example
     * // Delete a few EwPayIneligibleCards
     * const { count } = await prisma.ewPayIneligibleCards.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EwPayIneligibleCardsDeleteManyArgs>(args?: SelectSubset<T, EwPayIneligibleCardsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EwPayIneligibleCards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EwPayIneligibleCardsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EwPayIneligibleCards
     * const ewPayIneligibleCards = await prisma.ewPayIneligibleCards.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EwPayIneligibleCardsUpdateManyArgs>(args: SelectSubset<T, EwPayIneligibleCardsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EwPayIneligibleCards.
     * @param {EwPayIneligibleCardsUpsertArgs} args - Arguments to update or create a EwPayIneligibleCards.
     * @example
     * // Update or create a EwPayIneligibleCards
     * const ewPayIneligibleCards = await prisma.ewPayIneligibleCards.upsert({
     *   create: {
     *     // ... data to create a EwPayIneligibleCards
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EwPayIneligibleCards we want to update
     *   }
     * })
     */
    upsert<T extends EwPayIneligibleCardsUpsertArgs>(args: SelectSubset<T, EwPayIneligibleCardsUpsertArgs<ExtArgs>>): Prisma__EwPayIneligibleCardsClient<$Result.GetResult<Prisma.$EwPayIneligibleCardsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EwPayIneligibleCards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EwPayIneligibleCardsCountArgs} args - Arguments to filter EwPayIneligibleCards to count.
     * @example
     * // Count the number of EwPayIneligibleCards
     * const count = await prisma.ewPayIneligibleCards.count({
     *   where: {
     *     // ... the filter for the EwPayIneligibleCards we want to count
     *   }
     * })
    **/
    count<T extends EwPayIneligibleCardsCountArgs>(
      args?: Subset<T, EwPayIneligibleCardsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EwPayIneligibleCardsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EwPayIneligibleCards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EwPayIneligibleCardsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EwPayIneligibleCardsAggregateArgs>(args: Subset<T, EwPayIneligibleCardsAggregateArgs>): Prisma.PrismaPromise<GetEwPayIneligibleCardsAggregateType<T>>

    /**
     * Group by EwPayIneligibleCards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EwPayIneligibleCardsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EwPayIneligibleCardsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EwPayIneligibleCardsGroupByArgs['orderBy'] }
        : { orderBy?: EwPayIneligibleCardsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EwPayIneligibleCardsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEwPayIneligibleCardsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EwPayIneligibleCards model
   */
  readonly fields: EwPayIneligibleCardsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EwPayIneligibleCards.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EwPayIneligibleCardsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EwPayIneligibleCards model
   */
  interface EwPayIneligibleCardsFieldRefs {
    readonly Id: FieldRef<"EwPayIneligibleCards", 'Int'>
    readonly UCRN: FieldRef<"EwPayIneligibleCards", 'String'>
    readonly IsReported: FieldRef<"EwPayIneligibleCards", 'Boolean'>
    readonly IsActivated: FieldRef<"EwPayIneligibleCards", 'Boolean'>
    readonly DateReported: FieldRef<"EwPayIneligibleCards", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EwPayIneligibleCards findUnique
   */
  export type EwPayIneligibleCardsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwPayIneligibleCards
     */
    select?: EwPayIneligibleCardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EwPayIneligibleCards
     */
    omit?: EwPayIneligibleCardsOmit<ExtArgs> | null
    /**
     * Filter, which EwPayIneligibleCards to fetch.
     */
    where: EwPayIneligibleCardsWhereUniqueInput
  }

  /**
   * EwPayIneligibleCards findUniqueOrThrow
   */
  export type EwPayIneligibleCardsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwPayIneligibleCards
     */
    select?: EwPayIneligibleCardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EwPayIneligibleCards
     */
    omit?: EwPayIneligibleCardsOmit<ExtArgs> | null
    /**
     * Filter, which EwPayIneligibleCards to fetch.
     */
    where: EwPayIneligibleCardsWhereUniqueInput
  }

  /**
   * EwPayIneligibleCards findFirst
   */
  export type EwPayIneligibleCardsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwPayIneligibleCards
     */
    select?: EwPayIneligibleCardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EwPayIneligibleCards
     */
    omit?: EwPayIneligibleCardsOmit<ExtArgs> | null
    /**
     * Filter, which EwPayIneligibleCards to fetch.
     */
    where?: EwPayIneligibleCardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EwPayIneligibleCards to fetch.
     */
    orderBy?: EwPayIneligibleCardsOrderByWithRelationInput | EwPayIneligibleCardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EwPayIneligibleCards.
     */
    cursor?: EwPayIneligibleCardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EwPayIneligibleCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EwPayIneligibleCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EwPayIneligibleCards.
     */
    distinct?: EwPayIneligibleCardsScalarFieldEnum | EwPayIneligibleCardsScalarFieldEnum[]
  }

  /**
   * EwPayIneligibleCards findFirstOrThrow
   */
  export type EwPayIneligibleCardsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwPayIneligibleCards
     */
    select?: EwPayIneligibleCardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EwPayIneligibleCards
     */
    omit?: EwPayIneligibleCardsOmit<ExtArgs> | null
    /**
     * Filter, which EwPayIneligibleCards to fetch.
     */
    where?: EwPayIneligibleCardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EwPayIneligibleCards to fetch.
     */
    orderBy?: EwPayIneligibleCardsOrderByWithRelationInput | EwPayIneligibleCardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EwPayIneligibleCards.
     */
    cursor?: EwPayIneligibleCardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EwPayIneligibleCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EwPayIneligibleCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EwPayIneligibleCards.
     */
    distinct?: EwPayIneligibleCardsScalarFieldEnum | EwPayIneligibleCardsScalarFieldEnum[]
  }

  /**
   * EwPayIneligibleCards findMany
   */
  export type EwPayIneligibleCardsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwPayIneligibleCards
     */
    select?: EwPayIneligibleCardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EwPayIneligibleCards
     */
    omit?: EwPayIneligibleCardsOmit<ExtArgs> | null
    /**
     * Filter, which EwPayIneligibleCards to fetch.
     */
    where?: EwPayIneligibleCardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EwPayIneligibleCards to fetch.
     */
    orderBy?: EwPayIneligibleCardsOrderByWithRelationInput | EwPayIneligibleCardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EwPayIneligibleCards.
     */
    cursor?: EwPayIneligibleCardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EwPayIneligibleCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EwPayIneligibleCards.
     */
    skip?: number
    distinct?: EwPayIneligibleCardsScalarFieldEnum | EwPayIneligibleCardsScalarFieldEnum[]
  }

  /**
   * EwPayIneligibleCards create
   */
  export type EwPayIneligibleCardsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwPayIneligibleCards
     */
    select?: EwPayIneligibleCardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EwPayIneligibleCards
     */
    omit?: EwPayIneligibleCardsOmit<ExtArgs> | null
    /**
     * The data needed to create a EwPayIneligibleCards.
     */
    data: XOR<EwPayIneligibleCardsCreateInput, EwPayIneligibleCardsUncheckedCreateInput>
  }

  /**
   * EwPayIneligibleCards createMany
   */
  export type EwPayIneligibleCardsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EwPayIneligibleCards.
     */
    data: EwPayIneligibleCardsCreateManyInput | EwPayIneligibleCardsCreateManyInput[]
  }

  /**
   * EwPayIneligibleCards update
   */
  export type EwPayIneligibleCardsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwPayIneligibleCards
     */
    select?: EwPayIneligibleCardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EwPayIneligibleCards
     */
    omit?: EwPayIneligibleCardsOmit<ExtArgs> | null
    /**
     * The data needed to update a EwPayIneligibleCards.
     */
    data: XOR<EwPayIneligibleCardsUpdateInput, EwPayIneligibleCardsUncheckedUpdateInput>
    /**
     * Choose, which EwPayIneligibleCards to update.
     */
    where: EwPayIneligibleCardsWhereUniqueInput
  }

  /**
   * EwPayIneligibleCards updateMany
   */
  export type EwPayIneligibleCardsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EwPayIneligibleCards.
     */
    data: XOR<EwPayIneligibleCardsUpdateManyMutationInput, EwPayIneligibleCardsUncheckedUpdateManyInput>
    /**
     * Filter which EwPayIneligibleCards to update
     */
    where?: EwPayIneligibleCardsWhereInput
    /**
     * Limit how many EwPayIneligibleCards to update.
     */
    limit?: number
  }

  /**
   * EwPayIneligibleCards upsert
   */
  export type EwPayIneligibleCardsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwPayIneligibleCards
     */
    select?: EwPayIneligibleCardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EwPayIneligibleCards
     */
    omit?: EwPayIneligibleCardsOmit<ExtArgs> | null
    /**
     * The filter to search for the EwPayIneligibleCards to update in case it exists.
     */
    where: EwPayIneligibleCardsWhereUniqueInput
    /**
     * In case the EwPayIneligibleCards found by the `where` argument doesn't exist, create a new EwPayIneligibleCards with this data.
     */
    create: XOR<EwPayIneligibleCardsCreateInput, EwPayIneligibleCardsUncheckedCreateInput>
    /**
     * In case the EwPayIneligibleCards was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EwPayIneligibleCardsUpdateInput, EwPayIneligibleCardsUncheckedUpdateInput>
  }

  /**
   * EwPayIneligibleCards delete
   */
  export type EwPayIneligibleCardsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwPayIneligibleCards
     */
    select?: EwPayIneligibleCardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EwPayIneligibleCards
     */
    omit?: EwPayIneligibleCardsOmit<ExtArgs> | null
    /**
     * Filter which EwPayIneligibleCards to delete.
     */
    where: EwPayIneligibleCardsWhereUniqueInput
  }

  /**
   * EwPayIneligibleCards deleteMany
   */
  export type EwPayIneligibleCardsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EwPayIneligibleCards to delete
     */
    where?: EwPayIneligibleCardsWhereInput
    /**
     * Limit how many EwPayIneligibleCards to delete.
     */
    limit?: number
  }

  /**
   * EwPayIneligibleCards without action
   */
  export type EwPayIneligibleCardsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EwPayIneligibleCards
     */
    select?: EwPayIneligibleCardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EwPayIneligibleCards
     */
    omit?: EwPayIneligibleCardsOmit<ExtArgs> | null
  }


  /**
   * Model InvalidDeviceAccess
   */

  export type AggregateInvalidDeviceAccess = {
    _count: InvalidDeviceAccessCountAggregateOutputType | null
    _avg: InvalidDeviceAccessAvgAggregateOutputType | null
    _sum: InvalidDeviceAccessSumAggregateOutputType | null
    _min: InvalidDeviceAccessMinAggregateOutputType | null
    _max: InvalidDeviceAccessMaxAggregateOutputType | null
  }

  export type InvalidDeviceAccessAvgAggregateOutputType = {
    Id: number | null
  }

  export type InvalidDeviceAccessSumAggregateOutputType = {
    Id: number | null
  }

  export type InvalidDeviceAccessMinAggregateOutputType = {
    Id: number | null
    AccessDateTime: Date | null
    DeviceId: string | null
    MobileNumber: string | null
    Reason: string | null
  }

  export type InvalidDeviceAccessMaxAggregateOutputType = {
    Id: number | null
    AccessDateTime: Date | null
    DeviceId: string | null
    MobileNumber: string | null
    Reason: string | null
  }

  export type InvalidDeviceAccessCountAggregateOutputType = {
    Id: number
    AccessDateTime: number
    DeviceId: number
    MobileNumber: number
    Reason: number
    _all: number
  }


  export type InvalidDeviceAccessAvgAggregateInputType = {
    Id?: true
  }

  export type InvalidDeviceAccessSumAggregateInputType = {
    Id?: true
  }

  export type InvalidDeviceAccessMinAggregateInputType = {
    Id?: true
    AccessDateTime?: true
    DeviceId?: true
    MobileNumber?: true
    Reason?: true
  }

  export type InvalidDeviceAccessMaxAggregateInputType = {
    Id?: true
    AccessDateTime?: true
    DeviceId?: true
    MobileNumber?: true
    Reason?: true
  }

  export type InvalidDeviceAccessCountAggregateInputType = {
    Id?: true
    AccessDateTime?: true
    DeviceId?: true
    MobileNumber?: true
    Reason?: true
    _all?: true
  }

  export type InvalidDeviceAccessAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvalidDeviceAccess to aggregate.
     */
    where?: InvalidDeviceAccessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvalidDeviceAccesses to fetch.
     */
    orderBy?: InvalidDeviceAccessOrderByWithRelationInput | InvalidDeviceAccessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvalidDeviceAccessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvalidDeviceAccesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvalidDeviceAccesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InvalidDeviceAccesses
    **/
    _count?: true | InvalidDeviceAccessCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvalidDeviceAccessAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvalidDeviceAccessSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvalidDeviceAccessMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvalidDeviceAccessMaxAggregateInputType
  }

  export type GetInvalidDeviceAccessAggregateType<T extends InvalidDeviceAccessAggregateArgs> = {
        [P in keyof T & keyof AggregateInvalidDeviceAccess]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvalidDeviceAccess[P]>
      : GetScalarType<T[P], AggregateInvalidDeviceAccess[P]>
  }




  export type InvalidDeviceAccessGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvalidDeviceAccessWhereInput
    orderBy?: InvalidDeviceAccessOrderByWithAggregationInput | InvalidDeviceAccessOrderByWithAggregationInput[]
    by: InvalidDeviceAccessScalarFieldEnum[] | InvalidDeviceAccessScalarFieldEnum
    having?: InvalidDeviceAccessScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvalidDeviceAccessCountAggregateInputType | true
    _avg?: InvalidDeviceAccessAvgAggregateInputType
    _sum?: InvalidDeviceAccessSumAggregateInputType
    _min?: InvalidDeviceAccessMinAggregateInputType
    _max?: InvalidDeviceAccessMaxAggregateInputType
  }

  export type InvalidDeviceAccessGroupByOutputType = {
    Id: number
    AccessDateTime: Date
    DeviceId: string | null
    MobileNumber: string | null
    Reason: string | null
    _count: InvalidDeviceAccessCountAggregateOutputType | null
    _avg: InvalidDeviceAccessAvgAggregateOutputType | null
    _sum: InvalidDeviceAccessSumAggregateOutputType | null
    _min: InvalidDeviceAccessMinAggregateOutputType | null
    _max: InvalidDeviceAccessMaxAggregateOutputType | null
  }

  type GetInvalidDeviceAccessGroupByPayload<T extends InvalidDeviceAccessGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvalidDeviceAccessGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvalidDeviceAccessGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvalidDeviceAccessGroupByOutputType[P]>
            : GetScalarType<T[P], InvalidDeviceAccessGroupByOutputType[P]>
        }
      >
    >


  export type InvalidDeviceAccessSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    AccessDateTime?: boolean
    DeviceId?: boolean
    MobileNumber?: boolean
    Reason?: boolean
  }, ExtArgs["result"]["invalidDeviceAccess"]>



  export type InvalidDeviceAccessSelectScalar = {
    Id?: boolean
    AccessDateTime?: boolean
    DeviceId?: boolean
    MobileNumber?: boolean
    Reason?: boolean
  }

  export type InvalidDeviceAccessOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Id" | "AccessDateTime" | "DeviceId" | "MobileNumber" | "Reason", ExtArgs["result"]["invalidDeviceAccess"]>

  export type $InvalidDeviceAccessPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InvalidDeviceAccess"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      Id: number
      AccessDateTime: Date
      DeviceId: string | null
      MobileNumber: string | null
      Reason: string | null
    }, ExtArgs["result"]["invalidDeviceAccess"]>
    composites: {}
  }

  type InvalidDeviceAccessGetPayload<S extends boolean | null | undefined | InvalidDeviceAccessDefaultArgs> = $Result.GetResult<Prisma.$InvalidDeviceAccessPayload, S>

  type InvalidDeviceAccessCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvalidDeviceAccessFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvalidDeviceAccessCountAggregateInputType | true
    }

  export interface InvalidDeviceAccessDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InvalidDeviceAccess'], meta: { name: 'InvalidDeviceAccess' } }
    /**
     * Find zero or one InvalidDeviceAccess that matches the filter.
     * @param {InvalidDeviceAccessFindUniqueArgs} args - Arguments to find a InvalidDeviceAccess
     * @example
     * // Get one InvalidDeviceAccess
     * const invalidDeviceAccess = await prisma.invalidDeviceAccess.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvalidDeviceAccessFindUniqueArgs>(args: SelectSubset<T, InvalidDeviceAccessFindUniqueArgs<ExtArgs>>): Prisma__InvalidDeviceAccessClient<$Result.GetResult<Prisma.$InvalidDeviceAccessPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InvalidDeviceAccess that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvalidDeviceAccessFindUniqueOrThrowArgs} args - Arguments to find a InvalidDeviceAccess
     * @example
     * // Get one InvalidDeviceAccess
     * const invalidDeviceAccess = await prisma.invalidDeviceAccess.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvalidDeviceAccessFindUniqueOrThrowArgs>(args: SelectSubset<T, InvalidDeviceAccessFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvalidDeviceAccessClient<$Result.GetResult<Prisma.$InvalidDeviceAccessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InvalidDeviceAccess that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvalidDeviceAccessFindFirstArgs} args - Arguments to find a InvalidDeviceAccess
     * @example
     * // Get one InvalidDeviceAccess
     * const invalidDeviceAccess = await prisma.invalidDeviceAccess.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvalidDeviceAccessFindFirstArgs>(args?: SelectSubset<T, InvalidDeviceAccessFindFirstArgs<ExtArgs>>): Prisma__InvalidDeviceAccessClient<$Result.GetResult<Prisma.$InvalidDeviceAccessPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InvalidDeviceAccess that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvalidDeviceAccessFindFirstOrThrowArgs} args - Arguments to find a InvalidDeviceAccess
     * @example
     * // Get one InvalidDeviceAccess
     * const invalidDeviceAccess = await prisma.invalidDeviceAccess.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvalidDeviceAccessFindFirstOrThrowArgs>(args?: SelectSubset<T, InvalidDeviceAccessFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvalidDeviceAccessClient<$Result.GetResult<Prisma.$InvalidDeviceAccessPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InvalidDeviceAccesses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvalidDeviceAccessFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvalidDeviceAccesses
     * const invalidDeviceAccesses = await prisma.invalidDeviceAccess.findMany()
     * 
     * // Get first 10 InvalidDeviceAccesses
     * const invalidDeviceAccesses = await prisma.invalidDeviceAccess.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const invalidDeviceAccessWithIdOnly = await prisma.invalidDeviceAccess.findMany({ select: { Id: true } })
     * 
     */
    findMany<T extends InvalidDeviceAccessFindManyArgs>(args?: SelectSubset<T, InvalidDeviceAccessFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvalidDeviceAccessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InvalidDeviceAccess.
     * @param {InvalidDeviceAccessCreateArgs} args - Arguments to create a InvalidDeviceAccess.
     * @example
     * // Create one InvalidDeviceAccess
     * const InvalidDeviceAccess = await prisma.invalidDeviceAccess.create({
     *   data: {
     *     // ... data to create a InvalidDeviceAccess
     *   }
     * })
     * 
     */
    create<T extends InvalidDeviceAccessCreateArgs>(args: SelectSubset<T, InvalidDeviceAccessCreateArgs<ExtArgs>>): Prisma__InvalidDeviceAccessClient<$Result.GetResult<Prisma.$InvalidDeviceAccessPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InvalidDeviceAccesses.
     * @param {InvalidDeviceAccessCreateManyArgs} args - Arguments to create many InvalidDeviceAccesses.
     * @example
     * // Create many InvalidDeviceAccesses
     * const invalidDeviceAccess = await prisma.invalidDeviceAccess.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvalidDeviceAccessCreateManyArgs>(args?: SelectSubset<T, InvalidDeviceAccessCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a InvalidDeviceAccess.
     * @param {InvalidDeviceAccessDeleteArgs} args - Arguments to delete one InvalidDeviceAccess.
     * @example
     * // Delete one InvalidDeviceAccess
     * const InvalidDeviceAccess = await prisma.invalidDeviceAccess.delete({
     *   where: {
     *     // ... filter to delete one InvalidDeviceAccess
     *   }
     * })
     * 
     */
    delete<T extends InvalidDeviceAccessDeleteArgs>(args: SelectSubset<T, InvalidDeviceAccessDeleteArgs<ExtArgs>>): Prisma__InvalidDeviceAccessClient<$Result.GetResult<Prisma.$InvalidDeviceAccessPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InvalidDeviceAccess.
     * @param {InvalidDeviceAccessUpdateArgs} args - Arguments to update one InvalidDeviceAccess.
     * @example
     * // Update one InvalidDeviceAccess
     * const invalidDeviceAccess = await prisma.invalidDeviceAccess.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvalidDeviceAccessUpdateArgs>(args: SelectSubset<T, InvalidDeviceAccessUpdateArgs<ExtArgs>>): Prisma__InvalidDeviceAccessClient<$Result.GetResult<Prisma.$InvalidDeviceAccessPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InvalidDeviceAccesses.
     * @param {InvalidDeviceAccessDeleteManyArgs} args - Arguments to filter InvalidDeviceAccesses to delete.
     * @example
     * // Delete a few InvalidDeviceAccesses
     * const { count } = await prisma.invalidDeviceAccess.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvalidDeviceAccessDeleteManyArgs>(args?: SelectSubset<T, InvalidDeviceAccessDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvalidDeviceAccesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvalidDeviceAccessUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvalidDeviceAccesses
     * const invalidDeviceAccess = await prisma.invalidDeviceAccess.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvalidDeviceAccessUpdateManyArgs>(args: SelectSubset<T, InvalidDeviceAccessUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InvalidDeviceAccess.
     * @param {InvalidDeviceAccessUpsertArgs} args - Arguments to update or create a InvalidDeviceAccess.
     * @example
     * // Update or create a InvalidDeviceAccess
     * const invalidDeviceAccess = await prisma.invalidDeviceAccess.upsert({
     *   create: {
     *     // ... data to create a InvalidDeviceAccess
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvalidDeviceAccess we want to update
     *   }
     * })
     */
    upsert<T extends InvalidDeviceAccessUpsertArgs>(args: SelectSubset<T, InvalidDeviceAccessUpsertArgs<ExtArgs>>): Prisma__InvalidDeviceAccessClient<$Result.GetResult<Prisma.$InvalidDeviceAccessPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InvalidDeviceAccesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvalidDeviceAccessCountArgs} args - Arguments to filter InvalidDeviceAccesses to count.
     * @example
     * // Count the number of InvalidDeviceAccesses
     * const count = await prisma.invalidDeviceAccess.count({
     *   where: {
     *     // ... the filter for the InvalidDeviceAccesses we want to count
     *   }
     * })
    **/
    count<T extends InvalidDeviceAccessCountArgs>(
      args?: Subset<T, InvalidDeviceAccessCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvalidDeviceAccessCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvalidDeviceAccess.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvalidDeviceAccessAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvalidDeviceAccessAggregateArgs>(args: Subset<T, InvalidDeviceAccessAggregateArgs>): Prisma.PrismaPromise<GetInvalidDeviceAccessAggregateType<T>>

    /**
     * Group by InvalidDeviceAccess.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvalidDeviceAccessGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvalidDeviceAccessGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvalidDeviceAccessGroupByArgs['orderBy'] }
        : { orderBy?: InvalidDeviceAccessGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvalidDeviceAccessGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvalidDeviceAccessGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InvalidDeviceAccess model
   */
  readonly fields: InvalidDeviceAccessFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InvalidDeviceAccess.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvalidDeviceAccessClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InvalidDeviceAccess model
   */
  interface InvalidDeviceAccessFieldRefs {
    readonly Id: FieldRef<"InvalidDeviceAccess", 'Int'>
    readonly AccessDateTime: FieldRef<"InvalidDeviceAccess", 'DateTime'>
    readonly DeviceId: FieldRef<"InvalidDeviceAccess", 'String'>
    readonly MobileNumber: FieldRef<"InvalidDeviceAccess", 'String'>
    readonly Reason: FieldRef<"InvalidDeviceAccess", 'String'>
  }
    

  // Custom InputTypes
  /**
   * InvalidDeviceAccess findUnique
   */
  export type InvalidDeviceAccessFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvalidDeviceAccess
     */
    select?: InvalidDeviceAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvalidDeviceAccess
     */
    omit?: InvalidDeviceAccessOmit<ExtArgs> | null
    /**
     * Filter, which InvalidDeviceAccess to fetch.
     */
    where: InvalidDeviceAccessWhereUniqueInput
  }

  /**
   * InvalidDeviceAccess findUniqueOrThrow
   */
  export type InvalidDeviceAccessFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvalidDeviceAccess
     */
    select?: InvalidDeviceAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvalidDeviceAccess
     */
    omit?: InvalidDeviceAccessOmit<ExtArgs> | null
    /**
     * Filter, which InvalidDeviceAccess to fetch.
     */
    where: InvalidDeviceAccessWhereUniqueInput
  }

  /**
   * InvalidDeviceAccess findFirst
   */
  export type InvalidDeviceAccessFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvalidDeviceAccess
     */
    select?: InvalidDeviceAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvalidDeviceAccess
     */
    omit?: InvalidDeviceAccessOmit<ExtArgs> | null
    /**
     * Filter, which InvalidDeviceAccess to fetch.
     */
    where?: InvalidDeviceAccessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvalidDeviceAccesses to fetch.
     */
    orderBy?: InvalidDeviceAccessOrderByWithRelationInput | InvalidDeviceAccessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvalidDeviceAccesses.
     */
    cursor?: InvalidDeviceAccessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvalidDeviceAccesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvalidDeviceAccesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvalidDeviceAccesses.
     */
    distinct?: InvalidDeviceAccessScalarFieldEnum | InvalidDeviceAccessScalarFieldEnum[]
  }

  /**
   * InvalidDeviceAccess findFirstOrThrow
   */
  export type InvalidDeviceAccessFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvalidDeviceAccess
     */
    select?: InvalidDeviceAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvalidDeviceAccess
     */
    omit?: InvalidDeviceAccessOmit<ExtArgs> | null
    /**
     * Filter, which InvalidDeviceAccess to fetch.
     */
    where?: InvalidDeviceAccessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvalidDeviceAccesses to fetch.
     */
    orderBy?: InvalidDeviceAccessOrderByWithRelationInput | InvalidDeviceAccessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvalidDeviceAccesses.
     */
    cursor?: InvalidDeviceAccessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvalidDeviceAccesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvalidDeviceAccesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvalidDeviceAccesses.
     */
    distinct?: InvalidDeviceAccessScalarFieldEnum | InvalidDeviceAccessScalarFieldEnum[]
  }

  /**
   * InvalidDeviceAccess findMany
   */
  export type InvalidDeviceAccessFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvalidDeviceAccess
     */
    select?: InvalidDeviceAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvalidDeviceAccess
     */
    omit?: InvalidDeviceAccessOmit<ExtArgs> | null
    /**
     * Filter, which InvalidDeviceAccesses to fetch.
     */
    where?: InvalidDeviceAccessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvalidDeviceAccesses to fetch.
     */
    orderBy?: InvalidDeviceAccessOrderByWithRelationInput | InvalidDeviceAccessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InvalidDeviceAccesses.
     */
    cursor?: InvalidDeviceAccessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvalidDeviceAccesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvalidDeviceAccesses.
     */
    skip?: number
    distinct?: InvalidDeviceAccessScalarFieldEnum | InvalidDeviceAccessScalarFieldEnum[]
  }

  /**
   * InvalidDeviceAccess create
   */
  export type InvalidDeviceAccessCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvalidDeviceAccess
     */
    select?: InvalidDeviceAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvalidDeviceAccess
     */
    omit?: InvalidDeviceAccessOmit<ExtArgs> | null
    /**
     * The data needed to create a InvalidDeviceAccess.
     */
    data: XOR<InvalidDeviceAccessCreateInput, InvalidDeviceAccessUncheckedCreateInput>
  }

  /**
   * InvalidDeviceAccess createMany
   */
  export type InvalidDeviceAccessCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InvalidDeviceAccesses.
     */
    data: InvalidDeviceAccessCreateManyInput | InvalidDeviceAccessCreateManyInput[]
  }

  /**
   * InvalidDeviceAccess update
   */
  export type InvalidDeviceAccessUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvalidDeviceAccess
     */
    select?: InvalidDeviceAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvalidDeviceAccess
     */
    omit?: InvalidDeviceAccessOmit<ExtArgs> | null
    /**
     * The data needed to update a InvalidDeviceAccess.
     */
    data: XOR<InvalidDeviceAccessUpdateInput, InvalidDeviceAccessUncheckedUpdateInput>
    /**
     * Choose, which InvalidDeviceAccess to update.
     */
    where: InvalidDeviceAccessWhereUniqueInput
  }

  /**
   * InvalidDeviceAccess updateMany
   */
  export type InvalidDeviceAccessUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InvalidDeviceAccesses.
     */
    data: XOR<InvalidDeviceAccessUpdateManyMutationInput, InvalidDeviceAccessUncheckedUpdateManyInput>
    /**
     * Filter which InvalidDeviceAccesses to update
     */
    where?: InvalidDeviceAccessWhereInput
    /**
     * Limit how many InvalidDeviceAccesses to update.
     */
    limit?: number
  }

  /**
   * InvalidDeviceAccess upsert
   */
  export type InvalidDeviceAccessUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvalidDeviceAccess
     */
    select?: InvalidDeviceAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvalidDeviceAccess
     */
    omit?: InvalidDeviceAccessOmit<ExtArgs> | null
    /**
     * The filter to search for the InvalidDeviceAccess to update in case it exists.
     */
    where: InvalidDeviceAccessWhereUniqueInput
    /**
     * In case the InvalidDeviceAccess found by the `where` argument doesn't exist, create a new InvalidDeviceAccess with this data.
     */
    create: XOR<InvalidDeviceAccessCreateInput, InvalidDeviceAccessUncheckedCreateInput>
    /**
     * In case the InvalidDeviceAccess was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvalidDeviceAccessUpdateInput, InvalidDeviceAccessUncheckedUpdateInput>
  }

  /**
   * InvalidDeviceAccess delete
   */
  export type InvalidDeviceAccessDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvalidDeviceAccess
     */
    select?: InvalidDeviceAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvalidDeviceAccess
     */
    omit?: InvalidDeviceAccessOmit<ExtArgs> | null
    /**
     * Filter which InvalidDeviceAccess to delete.
     */
    where: InvalidDeviceAccessWhereUniqueInput
  }

  /**
   * InvalidDeviceAccess deleteMany
   */
  export type InvalidDeviceAccessDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvalidDeviceAccesses to delete
     */
    where?: InvalidDeviceAccessWhereInput
    /**
     * Limit how many InvalidDeviceAccesses to delete.
     */
    limit?: number
  }

  /**
   * InvalidDeviceAccess without action
   */
  export type InvalidDeviceAccessDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvalidDeviceAccess
     */
    select?: InvalidDeviceAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvalidDeviceAccess
     */
    omit?: InvalidDeviceAccessOmit<ExtArgs> | null
  }


  /**
   * Model MastercardProvisionedTokens
   */

  export type AggregateMastercardProvisionedTokens = {
    _count: MastercardProvisionedTokensCountAggregateOutputType | null
    _min: MastercardProvisionedTokensMinAggregateOutputType | null
    _max: MastercardProvisionedTokensMaxAggregateOutputType | null
  }

  export type MastercardProvisionedTokensMinAggregateOutputType = {
    TokenUniqueReferenceId: string | null
    PhoneNumber: string | null
    DeviceId: string | null
    PaymentAccountReference: string | null
  }

  export type MastercardProvisionedTokensMaxAggregateOutputType = {
    TokenUniqueReferenceId: string | null
    PhoneNumber: string | null
    DeviceId: string | null
    PaymentAccountReference: string | null
  }

  export type MastercardProvisionedTokensCountAggregateOutputType = {
    TokenUniqueReferenceId: number
    PhoneNumber: number
    DeviceId: number
    PaymentAccountReference: number
    _all: number
  }


  export type MastercardProvisionedTokensMinAggregateInputType = {
    TokenUniqueReferenceId?: true
    PhoneNumber?: true
    DeviceId?: true
    PaymentAccountReference?: true
  }

  export type MastercardProvisionedTokensMaxAggregateInputType = {
    TokenUniqueReferenceId?: true
    PhoneNumber?: true
    DeviceId?: true
    PaymentAccountReference?: true
  }

  export type MastercardProvisionedTokensCountAggregateInputType = {
    TokenUniqueReferenceId?: true
    PhoneNumber?: true
    DeviceId?: true
    PaymentAccountReference?: true
    _all?: true
  }

  export type MastercardProvisionedTokensAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MastercardProvisionedTokens to aggregate.
     */
    where?: MastercardProvisionedTokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MastercardProvisionedTokens to fetch.
     */
    orderBy?: MastercardProvisionedTokensOrderByWithRelationInput | MastercardProvisionedTokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MastercardProvisionedTokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MastercardProvisionedTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MastercardProvisionedTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MastercardProvisionedTokens
    **/
    _count?: true | MastercardProvisionedTokensCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MastercardProvisionedTokensMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MastercardProvisionedTokensMaxAggregateInputType
  }

  export type GetMastercardProvisionedTokensAggregateType<T extends MastercardProvisionedTokensAggregateArgs> = {
        [P in keyof T & keyof AggregateMastercardProvisionedTokens]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMastercardProvisionedTokens[P]>
      : GetScalarType<T[P], AggregateMastercardProvisionedTokens[P]>
  }




  export type MastercardProvisionedTokensGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MastercardProvisionedTokensWhereInput
    orderBy?: MastercardProvisionedTokensOrderByWithAggregationInput | MastercardProvisionedTokensOrderByWithAggregationInput[]
    by: MastercardProvisionedTokensScalarFieldEnum[] | MastercardProvisionedTokensScalarFieldEnum
    having?: MastercardProvisionedTokensScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MastercardProvisionedTokensCountAggregateInputType | true
    _min?: MastercardProvisionedTokensMinAggregateInputType
    _max?: MastercardProvisionedTokensMaxAggregateInputType
  }

  export type MastercardProvisionedTokensGroupByOutputType = {
    TokenUniqueReferenceId: string
    PhoneNumber: string
    DeviceId: string | null
    PaymentAccountReference: string | null
    _count: MastercardProvisionedTokensCountAggregateOutputType | null
    _min: MastercardProvisionedTokensMinAggregateOutputType | null
    _max: MastercardProvisionedTokensMaxAggregateOutputType | null
  }

  type GetMastercardProvisionedTokensGroupByPayload<T extends MastercardProvisionedTokensGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MastercardProvisionedTokensGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MastercardProvisionedTokensGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MastercardProvisionedTokensGroupByOutputType[P]>
            : GetScalarType<T[P], MastercardProvisionedTokensGroupByOutputType[P]>
        }
      >
    >


  export type MastercardProvisionedTokensSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    TokenUniqueReferenceId?: boolean
    PhoneNumber?: boolean
    DeviceId?: boolean
    PaymentAccountReference?: boolean
  }, ExtArgs["result"]["mastercardProvisionedTokens"]>



  export type MastercardProvisionedTokensSelectScalar = {
    TokenUniqueReferenceId?: boolean
    PhoneNumber?: boolean
    DeviceId?: boolean
    PaymentAccountReference?: boolean
  }

  export type MastercardProvisionedTokensOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"TokenUniqueReferenceId" | "PhoneNumber" | "DeviceId" | "PaymentAccountReference", ExtArgs["result"]["mastercardProvisionedTokens"]>

  export type $MastercardProvisionedTokensPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MastercardProvisionedTokens"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      TokenUniqueReferenceId: string
      PhoneNumber: string
      DeviceId: string | null
      PaymentAccountReference: string | null
    }, ExtArgs["result"]["mastercardProvisionedTokens"]>
    composites: {}
  }

  type MastercardProvisionedTokensGetPayload<S extends boolean | null | undefined | MastercardProvisionedTokensDefaultArgs> = $Result.GetResult<Prisma.$MastercardProvisionedTokensPayload, S>

  type MastercardProvisionedTokensCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MastercardProvisionedTokensFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MastercardProvisionedTokensCountAggregateInputType | true
    }

  export interface MastercardProvisionedTokensDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MastercardProvisionedTokens'], meta: { name: 'MastercardProvisionedTokens' } }
    /**
     * Find zero or one MastercardProvisionedTokens that matches the filter.
     * @param {MastercardProvisionedTokensFindUniqueArgs} args - Arguments to find a MastercardProvisionedTokens
     * @example
     * // Get one MastercardProvisionedTokens
     * const mastercardProvisionedTokens = await prisma.mastercardProvisionedTokens.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MastercardProvisionedTokensFindUniqueArgs>(args: SelectSubset<T, MastercardProvisionedTokensFindUniqueArgs<ExtArgs>>): Prisma__MastercardProvisionedTokensClient<$Result.GetResult<Prisma.$MastercardProvisionedTokensPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MastercardProvisionedTokens that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MastercardProvisionedTokensFindUniqueOrThrowArgs} args - Arguments to find a MastercardProvisionedTokens
     * @example
     * // Get one MastercardProvisionedTokens
     * const mastercardProvisionedTokens = await prisma.mastercardProvisionedTokens.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MastercardProvisionedTokensFindUniqueOrThrowArgs>(args: SelectSubset<T, MastercardProvisionedTokensFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MastercardProvisionedTokensClient<$Result.GetResult<Prisma.$MastercardProvisionedTokensPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MastercardProvisionedTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MastercardProvisionedTokensFindFirstArgs} args - Arguments to find a MastercardProvisionedTokens
     * @example
     * // Get one MastercardProvisionedTokens
     * const mastercardProvisionedTokens = await prisma.mastercardProvisionedTokens.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MastercardProvisionedTokensFindFirstArgs>(args?: SelectSubset<T, MastercardProvisionedTokensFindFirstArgs<ExtArgs>>): Prisma__MastercardProvisionedTokensClient<$Result.GetResult<Prisma.$MastercardProvisionedTokensPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MastercardProvisionedTokens that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MastercardProvisionedTokensFindFirstOrThrowArgs} args - Arguments to find a MastercardProvisionedTokens
     * @example
     * // Get one MastercardProvisionedTokens
     * const mastercardProvisionedTokens = await prisma.mastercardProvisionedTokens.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MastercardProvisionedTokensFindFirstOrThrowArgs>(args?: SelectSubset<T, MastercardProvisionedTokensFindFirstOrThrowArgs<ExtArgs>>): Prisma__MastercardProvisionedTokensClient<$Result.GetResult<Prisma.$MastercardProvisionedTokensPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MastercardProvisionedTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MastercardProvisionedTokensFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MastercardProvisionedTokens
     * const mastercardProvisionedTokens = await prisma.mastercardProvisionedTokens.findMany()
     * 
     * // Get first 10 MastercardProvisionedTokens
     * const mastercardProvisionedTokens = await prisma.mastercardProvisionedTokens.findMany({ take: 10 })
     * 
     * // Only select the `TokenUniqueReferenceId`
     * const mastercardProvisionedTokensWithTokenUniqueReferenceIdOnly = await prisma.mastercardProvisionedTokens.findMany({ select: { TokenUniqueReferenceId: true } })
     * 
     */
    findMany<T extends MastercardProvisionedTokensFindManyArgs>(args?: SelectSubset<T, MastercardProvisionedTokensFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MastercardProvisionedTokensPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MastercardProvisionedTokens.
     * @param {MastercardProvisionedTokensCreateArgs} args - Arguments to create a MastercardProvisionedTokens.
     * @example
     * // Create one MastercardProvisionedTokens
     * const MastercardProvisionedTokens = await prisma.mastercardProvisionedTokens.create({
     *   data: {
     *     // ... data to create a MastercardProvisionedTokens
     *   }
     * })
     * 
     */
    create<T extends MastercardProvisionedTokensCreateArgs>(args: SelectSubset<T, MastercardProvisionedTokensCreateArgs<ExtArgs>>): Prisma__MastercardProvisionedTokensClient<$Result.GetResult<Prisma.$MastercardProvisionedTokensPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MastercardProvisionedTokens.
     * @param {MastercardProvisionedTokensCreateManyArgs} args - Arguments to create many MastercardProvisionedTokens.
     * @example
     * // Create many MastercardProvisionedTokens
     * const mastercardProvisionedTokens = await prisma.mastercardProvisionedTokens.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MastercardProvisionedTokensCreateManyArgs>(args?: SelectSubset<T, MastercardProvisionedTokensCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MastercardProvisionedTokens.
     * @param {MastercardProvisionedTokensDeleteArgs} args - Arguments to delete one MastercardProvisionedTokens.
     * @example
     * // Delete one MastercardProvisionedTokens
     * const MastercardProvisionedTokens = await prisma.mastercardProvisionedTokens.delete({
     *   where: {
     *     // ... filter to delete one MastercardProvisionedTokens
     *   }
     * })
     * 
     */
    delete<T extends MastercardProvisionedTokensDeleteArgs>(args: SelectSubset<T, MastercardProvisionedTokensDeleteArgs<ExtArgs>>): Prisma__MastercardProvisionedTokensClient<$Result.GetResult<Prisma.$MastercardProvisionedTokensPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MastercardProvisionedTokens.
     * @param {MastercardProvisionedTokensUpdateArgs} args - Arguments to update one MastercardProvisionedTokens.
     * @example
     * // Update one MastercardProvisionedTokens
     * const mastercardProvisionedTokens = await prisma.mastercardProvisionedTokens.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MastercardProvisionedTokensUpdateArgs>(args: SelectSubset<T, MastercardProvisionedTokensUpdateArgs<ExtArgs>>): Prisma__MastercardProvisionedTokensClient<$Result.GetResult<Prisma.$MastercardProvisionedTokensPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MastercardProvisionedTokens.
     * @param {MastercardProvisionedTokensDeleteManyArgs} args - Arguments to filter MastercardProvisionedTokens to delete.
     * @example
     * // Delete a few MastercardProvisionedTokens
     * const { count } = await prisma.mastercardProvisionedTokens.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MastercardProvisionedTokensDeleteManyArgs>(args?: SelectSubset<T, MastercardProvisionedTokensDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MastercardProvisionedTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MastercardProvisionedTokensUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MastercardProvisionedTokens
     * const mastercardProvisionedTokens = await prisma.mastercardProvisionedTokens.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MastercardProvisionedTokensUpdateManyArgs>(args: SelectSubset<T, MastercardProvisionedTokensUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MastercardProvisionedTokens.
     * @param {MastercardProvisionedTokensUpsertArgs} args - Arguments to update or create a MastercardProvisionedTokens.
     * @example
     * // Update or create a MastercardProvisionedTokens
     * const mastercardProvisionedTokens = await prisma.mastercardProvisionedTokens.upsert({
     *   create: {
     *     // ... data to create a MastercardProvisionedTokens
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MastercardProvisionedTokens we want to update
     *   }
     * })
     */
    upsert<T extends MastercardProvisionedTokensUpsertArgs>(args: SelectSubset<T, MastercardProvisionedTokensUpsertArgs<ExtArgs>>): Prisma__MastercardProvisionedTokensClient<$Result.GetResult<Prisma.$MastercardProvisionedTokensPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MastercardProvisionedTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MastercardProvisionedTokensCountArgs} args - Arguments to filter MastercardProvisionedTokens to count.
     * @example
     * // Count the number of MastercardProvisionedTokens
     * const count = await prisma.mastercardProvisionedTokens.count({
     *   where: {
     *     // ... the filter for the MastercardProvisionedTokens we want to count
     *   }
     * })
    **/
    count<T extends MastercardProvisionedTokensCountArgs>(
      args?: Subset<T, MastercardProvisionedTokensCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MastercardProvisionedTokensCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MastercardProvisionedTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MastercardProvisionedTokensAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MastercardProvisionedTokensAggregateArgs>(args: Subset<T, MastercardProvisionedTokensAggregateArgs>): Prisma.PrismaPromise<GetMastercardProvisionedTokensAggregateType<T>>

    /**
     * Group by MastercardProvisionedTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MastercardProvisionedTokensGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MastercardProvisionedTokensGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MastercardProvisionedTokensGroupByArgs['orderBy'] }
        : { orderBy?: MastercardProvisionedTokensGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MastercardProvisionedTokensGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMastercardProvisionedTokensGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MastercardProvisionedTokens model
   */
  readonly fields: MastercardProvisionedTokensFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MastercardProvisionedTokens.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MastercardProvisionedTokensClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MastercardProvisionedTokens model
   */
  interface MastercardProvisionedTokensFieldRefs {
    readonly TokenUniqueReferenceId: FieldRef<"MastercardProvisionedTokens", 'String'>
    readonly PhoneNumber: FieldRef<"MastercardProvisionedTokens", 'String'>
    readonly DeviceId: FieldRef<"MastercardProvisionedTokens", 'String'>
    readonly PaymentAccountReference: FieldRef<"MastercardProvisionedTokens", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MastercardProvisionedTokens findUnique
   */
  export type MastercardProvisionedTokensFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MastercardProvisionedTokens
     */
    select?: MastercardProvisionedTokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MastercardProvisionedTokens
     */
    omit?: MastercardProvisionedTokensOmit<ExtArgs> | null
    /**
     * Filter, which MastercardProvisionedTokens to fetch.
     */
    where: MastercardProvisionedTokensWhereUniqueInput
  }

  /**
   * MastercardProvisionedTokens findUniqueOrThrow
   */
  export type MastercardProvisionedTokensFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MastercardProvisionedTokens
     */
    select?: MastercardProvisionedTokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MastercardProvisionedTokens
     */
    omit?: MastercardProvisionedTokensOmit<ExtArgs> | null
    /**
     * Filter, which MastercardProvisionedTokens to fetch.
     */
    where: MastercardProvisionedTokensWhereUniqueInput
  }

  /**
   * MastercardProvisionedTokens findFirst
   */
  export type MastercardProvisionedTokensFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MastercardProvisionedTokens
     */
    select?: MastercardProvisionedTokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MastercardProvisionedTokens
     */
    omit?: MastercardProvisionedTokensOmit<ExtArgs> | null
    /**
     * Filter, which MastercardProvisionedTokens to fetch.
     */
    where?: MastercardProvisionedTokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MastercardProvisionedTokens to fetch.
     */
    orderBy?: MastercardProvisionedTokensOrderByWithRelationInput | MastercardProvisionedTokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MastercardProvisionedTokens.
     */
    cursor?: MastercardProvisionedTokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MastercardProvisionedTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MastercardProvisionedTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MastercardProvisionedTokens.
     */
    distinct?: MastercardProvisionedTokensScalarFieldEnum | MastercardProvisionedTokensScalarFieldEnum[]
  }

  /**
   * MastercardProvisionedTokens findFirstOrThrow
   */
  export type MastercardProvisionedTokensFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MastercardProvisionedTokens
     */
    select?: MastercardProvisionedTokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MastercardProvisionedTokens
     */
    omit?: MastercardProvisionedTokensOmit<ExtArgs> | null
    /**
     * Filter, which MastercardProvisionedTokens to fetch.
     */
    where?: MastercardProvisionedTokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MastercardProvisionedTokens to fetch.
     */
    orderBy?: MastercardProvisionedTokensOrderByWithRelationInput | MastercardProvisionedTokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MastercardProvisionedTokens.
     */
    cursor?: MastercardProvisionedTokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MastercardProvisionedTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MastercardProvisionedTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MastercardProvisionedTokens.
     */
    distinct?: MastercardProvisionedTokensScalarFieldEnum | MastercardProvisionedTokensScalarFieldEnum[]
  }

  /**
   * MastercardProvisionedTokens findMany
   */
  export type MastercardProvisionedTokensFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MastercardProvisionedTokens
     */
    select?: MastercardProvisionedTokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MastercardProvisionedTokens
     */
    omit?: MastercardProvisionedTokensOmit<ExtArgs> | null
    /**
     * Filter, which MastercardProvisionedTokens to fetch.
     */
    where?: MastercardProvisionedTokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MastercardProvisionedTokens to fetch.
     */
    orderBy?: MastercardProvisionedTokensOrderByWithRelationInput | MastercardProvisionedTokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MastercardProvisionedTokens.
     */
    cursor?: MastercardProvisionedTokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MastercardProvisionedTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MastercardProvisionedTokens.
     */
    skip?: number
    distinct?: MastercardProvisionedTokensScalarFieldEnum | MastercardProvisionedTokensScalarFieldEnum[]
  }

  /**
   * MastercardProvisionedTokens create
   */
  export type MastercardProvisionedTokensCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MastercardProvisionedTokens
     */
    select?: MastercardProvisionedTokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MastercardProvisionedTokens
     */
    omit?: MastercardProvisionedTokensOmit<ExtArgs> | null
    /**
     * The data needed to create a MastercardProvisionedTokens.
     */
    data: XOR<MastercardProvisionedTokensCreateInput, MastercardProvisionedTokensUncheckedCreateInput>
  }

  /**
   * MastercardProvisionedTokens createMany
   */
  export type MastercardProvisionedTokensCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MastercardProvisionedTokens.
     */
    data: MastercardProvisionedTokensCreateManyInput | MastercardProvisionedTokensCreateManyInput[]
  }

  /**
   * MastercardProvisionedTokens update
   */
  export type MastercardProvisionedTokensUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MastercardProvisionedTokens
     */
    select?: MastercardProvisionedTokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MastercardProvisionedTokens
     */
    omit?: MastercardProvisionedTokensOmit<ExtArgs> | null
    /**
     * The data needed to update a MastercardProvisionedTokens.
     */
    data: XOR<MastercardProvisionedTokensUpdateInput, MastercardProvisionedTokensUncheckedUpdateInput>
    /**
     * Choose, which MastercardProvisionedTokens to update.
     */
    where: MastercardProvisionedTokensWhereUniqueInput
  }

  /**
   * MastercardProvisionedTokens updateMany
   */
  export type MastercardProvisionedTokensUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MastercardProvisionedTokens.
     */
    data: XOR<MastercardProvisionedTokensUpdateManyMutationInput, MastercardProvisionedTokensUncheckedUpdateManyInput>
    /**
     * Filter which MastercardProvisionedTokens to update
     */
    where?: MastercardProvisionedTokensWhereInput
    /**
     * Limit how many MastercardProvisionedTokens to update.
     */
    limit?: number
  }

  /**
   * MastercardProvisionedTokens upsert
   */
  export type MastercardProvisionedTokensUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MastercardProvisionedTokens
     */
    select?: MastercardProvisionedTokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MastercardProvisionedTokens
     */
    omit?: MastercardProvisionedTokensOmit<ExtArgs> | null
    /**
     * The filter to search for the MastercardProvisionedTokens to update in case it exists.
     */
    where: MastercardProvisionedTokensWhereUniqueInput
    /**
     * In case the MastercardProvisionedTokens found by the `where` argument doesn't exist, create a new MastercardProvisionedTokens with this data.
     */
    create: XOR<MastercardProvisionedTokensCreateInput, MastercardProvisionedTokensUncheckedCreateInput>
    /**
     * In case the MastercardProvisionedTokens was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MastercardProvisionedTokensUpdateInput, MastercardProvisionedTokensUncheckedUpdateInput>
  }

  /**
   * MastercardProvisionedTokens delete
   */
  export type MastercardProvisionedTokensDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MastercardProvisionedTokens
     */
    select?: MastercardProvisionedTokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MastercardProvisionedTokens
     */
    omit?: MastercardProvisionedTokensOmit<ExtArgs> | null
    /**
     * Filter which MastercardProvisionedTokens to delete.
     */
    where: MastercardProvisionedTokensWhereUniqueInput
  }

  /**
   * MastercardProvisionedTokens deleteMany
   */
  export type MastercardProvisionedTokensDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MastercardProvisionedTokens to delete
     */
    where?: MastercardProvisionedTokensWhereInput
    /**
     * Limit how many MastercardProvisionedTokens to delete.
     */
    limit?: number
  }

  /**
   * MastercardProvisionedTokens without action
   */
  export type MastercardProvisionedTokensDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MastercardProvisionedTokens
     */
    select?: MastercardProvisionedTokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MastercardProvisionedTokens
     */
    omit?: MastercardProvisionedTokensOmit<ExtArgs> | null
  }


  /**
   * Model PersistedGrants
   */

  export type AggregatePersistedGrants = {
    _count: PersistedGrantsCountAggregateOutputType | null
    _min: PersistedGrantsMinAggregateOutputType | null
    _max: PersistedGrantsMaxAggregateOutputType | null
  }

  export type PersistedGrantsMinAggregateOutputType = {
    Key: string | null
    Type: string | null
    SubjectId: string | null
    ClientId: string | null
    CreationTime: Date | null
    Expiration: Date | null
    Data: string | null
  }

  export type PersistedGrantsMaxAggregateOutputType = {
    Key: string | null
    Type: string | null
    SubjectId: string | null
    ClientId: string | null
    CreationTime: Date | null
    Expiration: Date | null
    Data: string | null
  }

  export type PersistedGrantsCountAggregateOutputType = {
    Key: number
    Type: number
    SubjectId: number
    ClientId: number
    CreationTime: number
    Expiration: number
    Data: number
    _all: number
  }


  export type PersistedGrantsMinAggregateInputType = {
    Key?: true
    Type?: true
    SubjectId?: true
    ClientId?: true
    CreationTime?: true
    Expiration?: true
    Data?: true
  }

  export type PersistedGrantsMaxAggregateInputType = {
    Key?: true
    Type?: true
    SubjectId?: true
    ClientId?: true
    CreationTime?: true
    Expiration?: true
    Data?: true
  }

  export type PersistedGrantsCountAggregateInputType = {
    Key?: true
    Type?: true
    SubjectId?: true
    ClientId?: true
    CreationTime?: true
    Expiration?: true
    Data?: true
    _all?: true
  }

  export type PersistedGrantsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PersistedGrants to aggregate.
     */
    where?: PersistedGrantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersistedGrants to fetch.
     */
    orderBy?: PersistedGrantsOrderByWithRelationInput | PersistedGrantsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PersistedGrantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersistedGrants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersistedGrants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PersistedGrants
    **/
    _count?: true | PersistedGrantsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PersistedGrantsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PersistedGrantsMaxAggregateInputType
  }

  export type GetPersistedGrantsAggregateType<T extends PersistedGrantsAggregateArgs> = {
        [P in keyof T & keyof AggregatePersistedGrants]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePersistedGrants[P]>
      : GetScalarType<T[P], AggregatePersistedGrants[P]>
  }




  export type PersistedGrantsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersistedGrantsWhereInput
    orderBy?: PersistedGrantsOrderByWithAggregationInput | PersistedGrantsOrderByWithAggregationInput[]
    by: PersistedGrantsScalarFieldEnum[] | PersistedGrantsScalarFieldEnum
    having?: PersistedGrantsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PersistedGrantsCountAggregateInputType | true
    _min?: PersistedGrantsMinAggregateInputType
    _max?: PersistedGrantsMaxAggregateInputType
  }

  export type PersistedGrantsGroupByOutputType = {
    Key: string
    Type: string
    SubjectId: string | null
    ClientId: string
    CreationTime: Date
    Expiration: Date | null
    Data: string
    _count: PersistedGrantsCountAggregateOutputType | null
    _min: PersistedGrantsMinAggregateOutputType | null
    _max: PersistedGrantsMaxAggregateOutputType | null
  }

  type GetPersistedGrantsGroupByPayload<T extends PersistedGrantsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PersistedGrantsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PersistedGrantsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PersistedGrantsGroupByOutputType[P]>
            : GetScalarType<T[P], PersistedGrantsGroupByOutputType[P]>
        }
      >
    >


  export type PersistedGrantsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Key?: boolean
    Type?: boolean
    SubjectId?: boolean
    ClientId?: boolean
    CreationTime?: boolean
    Expiration?: boolean
    Data?: boolean
  }, ExtArgs["result"]["persistedGrants"]>



  export type PersistedGrantsSelectScalar = {
    Key?: boolean
    Type?: boolean
    SubjectId?: boolean
    ClientId?: boolean
    CreationTime?: boolean
    Expiration?: boolean
    Data?: boolean
  }

  export type PersistedGrantsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Key" | "Type" | "SubjectId" | "ClientId" | "CreationTime" | "Expiration" | "Data", ExtArgs["result"]["persistedGrants"]>

  export type $PersistedGrantsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PersistedGrants"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      Key: string
      Type: string
      SubjectId: string | null
      ClientId: string
      CreationTime: Date
      Expiration: Date | null
      Data: string
    }, ExtArgs["result"]["persistedGrants"]>
    composites: {}
  }

  type PersistedGrantsGetPayload<S extends boolean | null | undefined | PersistedGrantsDefaultArgs> = $Result.GetResult<Prisma.$PersistedGrantsPayload, S>

  type PersistedGrantsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PersistedGrantsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PersistedGrantsCountAggregateInputType | true
    }

  export interface PersistedGrantsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PersistedGrants'], meta: { name: 'PersistedGrants' } }
    /**
     * Find zero or one PersistedGrants that matches the filter.
     * @param {PersistedGrantsFindUniqueArgs} args - Arguments to find a PersistedGrants
     * @example
     * // Get one PersistedGrants
     * const persistedGrants = await prisma.persistedGrants.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PersistedGrantsFindUniqueArgs>(args: SelectSubset<T, PersistedGrantsFindUniqueArgs<ExtArgs>>): Prisma__PersistedGrantsClient<$Result.GetResult<Prisma.$PersistedGrantsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PersistedGrants that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PersistedGrantsFindUniqueOrThrowArgs} args - Arguments to find a PersistedGrants
     * @example
     * // Get one PersistedGrants
     * const persistedGrants = await prisma.persistedGrants.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PersistedGrantsFindUniqueOrThrowArgs>(args: SelectSubset<T, PersistedGrantsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PersistedGrantsClient<$Result.GetResult<Prisma.$PersistedGrantsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PersistedGrants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersistedGrantsFindFirstArgs} args - Arguments to find a PersistedGrants
     * @example
     * // Get one PersistedGrants
     * const persistedGrants = await prisma.persistedGrants.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PersistedGrantsFindFirstArgs>(args?: SelectSubset<T, PersistedGrantsFindFirstArgs<ExtArgs>>): Prisma__PersistedGrantsClient<$Result.GetResult<Prisma.$PersistedGrantsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PersistedGrants that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersistedGrantsFindFirstOrThrowArgs} args - Arguments to find a PersistedGrants
     * @example
     * // Get one PersistedGrants
     * const persistedGrants = await prisma.persistedGrants.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PersistedGrantsFindFirstOrThrowArgs>(args?: SelectSubset<T, PersistedGrantsFindFirstOrThrowArgs<ExtArgs>>): Prisma__PersistedGrantsClient<$Result.GetResult<Prisma.$PersistedGrantsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PersistedGrants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersistedGrantsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PersistedGrants
     * const persistedGrants = await prisma.persistedGrants.findMany()
     * 
     * // Get first 10 PersistedGrants
     * const persistedGrants = await prisma.persistedGrants.findMany({ take: 10 })
     * 
     * // Only select the `Key`
     * const persistedGrantsWithKeyOnly = await prisma.persistedGrants.findMany({ select: { Key: true } })
     * 
     */
    findMany<T extends PersistedGrantsFindManyArgs>(args?: SelectSubset<T, PersistedGrantsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersistedGrantsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PersistedGrants.
     * @param {PersistedGrantsCreateArgs} args - Arguments to create a PersistedGrants.
     * @example
     * // Create one PersistedGrants
     * const PersistedGrants = await prisma.persistedGrants.create({
     *   data: {
     *     // ... data to create a PersistedGrants
     *   }
     * })
     * 
     */
    create<T extends PersistedGrantsCreateArgs>(args: SelectSubset<T, PersistedGrantsCreateArgs<ExtArgs>>): Prisma__PersistedGrantsClient<$Result.GetResult<Prisma.$PersistedGrantsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PersistedGrants.
     * @param {PersistedGrantsCreateManyArgs} args - Arguments to create many PersistedGrants.
     * @example
     * // Create many PersistedGrants
     * const persistedGrants = await prisma.persistedGrants.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PersistedGrantsCreateManyArgs>(args?: SelectSubset<T, PersistedGrantsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PersistedGrants.
     * @param {PersistedGrantsDeleteArgs} args - Arguments to delete one PersistedGrants.
     * @example
     * // Delete one PersistedGrants
     * const PersistedGrants = await prisma.persistedGrants.delete({
     *   where: {
     *     // ... filter to delete one PersistedGrants
     *   }
     * })
     * 
     */
    delete<T extends PersistedGrantsDeleteArgs>(args: SelectSubset<T, PersistedGrantsDeleteArgs<ExtArgs>>): Prisma__PersistedGrantsClient<$Result.GetResult<Prisma.$PersistedGrantsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PersistedGrants.
     * @param {PersistedGrantsUpdateArgs} args - Arguments to update one PersistedGrants.
     * @example
     * // Update one PersistedGrants
     * const persistedGrants = await prisma.persistedGrants.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PersistedGrantsUpdateArgs>(args: SelectSubset<T, PersistedGrantsUpdateArgs<ExtArgs>>): Prisma__PersistedGrantsClient<$Result.GetResult<Prisma.$PersistedGrantsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PersistedGrants.
     * @param {PersistedGrantsDeleteManyArgs} args - Arguments to filter PersistedGrants to delete.
     * @example
     * // Delete a few PersistedGrants
     * const { count } = await prisma.persistedGrants.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PersistedGrantsDeleteManyArgs>(args?: SelectSubset<T, PersistedGrantsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PersistedGrants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersistedGrantsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PersistedGrants
     * const persistedGrants = await prisma.persistedGrants.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PersistedGrantsUpdateManyArgs>(args: SelectSubset<T, PersistedGrantsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PersistedGrants.
     * @param {PersistedGrantsUpsertArgs} args - Arguments to update or create a PersistedGrants.
     * @example
     * // Update or create a PersistedGrants
     * const persistedGrants = await prisma.persistedGrants.upsert({
     *   create: {
     *     // ... data to create a PersistedGrants
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PersistedGrants we want to update
     *   }
     * })
     */
    upsert<T extends PersistedGrantsUpsertArgs>(args: SelectSubset<T, PersistedGrantsUpsertArgs<ExtArgs>>): Prisma__PersistedGrantsClient<$Result.GetResult<Prisma.$PersistedGrantsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PersistedGrants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersistedGrantsCountArgs} args - Arguments to filter PersistedGrants to count.
     * @example
     * // Count the number of PersistedGrants
     * const count = await prisma.persistedGrants.count({
     *   where: {
     *     // ... the filter for the PersistedGrants we want to count
     *   }
     * })
    **/
    count<T extends PersistedGrantsCountArgs>(
      args?: Subset<T, PersistedGrantsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PersistedGrantsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PersistedGrants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersistedGrantsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PersistedGrantsAggregateArgs>(args: Subset<T, PersistedGrantsAggregateArgs>): Prisma.PrismaPromise<GetPersistedGrantsAggregateType<T>>

    /**
     * Group by PersistedGrants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersistedGrantsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PersistedGrantsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PersistedGrantsGroupByArgs['orderBy'] }
        : { orderBy?: PersistedGrantsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PersistedGrantsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPersistedGrantsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PersistedGrants model
   */
  readonly fields: PersistedGrantsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PersistedGrants.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PersistedGrantsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PersistedGrants model
   */
  interface PersistedGrantsFieldRefs {
    readonly Key: FieldRef<"PersistedGrants", 'String'>
    readonly Type: FieldRef<"PersistedGrants", 'String'>
    readonly SubjectId: FieldRef<"PersistedGrants", 'String'>
    readonly ClientId: FieldRef<"PersistedGrants", 'String'>
    readonly CreationTime: FieldRef<"PersistedGrants", 'DateTime'>
    readonly Expiration: FieldRef<"PersistedGrants", 'DateTime'>
    readonly Data: FieldRef<"PersistedGrants", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PersistedGrants findUnique
   */
  export type PersistedGrantsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersistedGrants
     */
    select?: PersistedGrantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersistedGrants
     */
    omit?: PersistedGrantsOmit<ExtArgs> | null
    /**
     * Filter, which PersistedGrants to fetch.
     */
    where: PersistedGrantsWhereUniqueInput
  }

  /**
   * PersistedGrants findUniqueOrThrow
   */
  export type PersistedGrantsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersistedGrants
     */
    select?: PersistedGrantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersistedGrants
     */
    omit?: PersistedGrantsOmit<ExtArgs> | null
    /**
     * Filter, which PersistedGrants to fetch.
     */
    where: PersistedGrantsWhereUniqueInput
  }

  /**
   * PersistedGrants findFirst
   */
  export type PersistedGrantsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersistedGrants
     */
    select?: PersistedGrantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersistedGrants
     */
    omit?: PersistedGrantsOmit<ExtArgs> | null
    /**
     * Filter, which PersistedGrants to fetch.
     */
    where?: PersistedGrantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersistedGrants to fetch.
     */
    orderBy?: PersistedGrantsOrderByWithRelationInput | PersistedGrantsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PersistedGrants.
     */
    cursor?: PersistedGrantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersistedGrants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersistedGrants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PersistedGrants.
     */
    distinct?: PersistedGrantsScalarFieldEnum | PersistedGrantsScalarFieldEnum[]
  }

  /**
   * PersistedGrants findFirstOrThrow
   */
  export type PersistedGrantsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersistedGrants
     */
    select?: PersistedGrantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersistedGrants
     */
    omit?: PersistedGrantsOmit<ExtArgs> | null
    /**
     * Filter, which PersistedGrants to fetch.
     */
    where?: PersistedGrantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersistedGrants to fetch.
     */
    orderBy?: PersistedGrantsOrderByWithRelationInput | PersistedGrantsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PersistedGrants.
     */
    cursor?: PersistedGrantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersistedGrants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersistedGrants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PersistedGrants.
     */
    distinct?: PersistedGrantsScalarFieldEnum | PersistedGrantsScalarFieldEnum[]
  }

  /**
   * PersistedGrants findMany
   */
  export type PersistedGrantsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersistedGrants
     */
    select?: PersistedGrantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersistedGrants
     */
    omit?: PersistedGrantsOmit<ExtArgs> | null
    /**
     * Filter, which PersistedGrants to fetch.
     */
    where?: PersistedGrantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersistedGrants to fetch.
     */
    orderBy?: PersistedGrantsOrderByWithRelationInput | PersistedGrantsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PersistedGrants.
     */
    cursor?: PersistedGrantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersistedGrants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersistedGrants.
     */
    skip?: number
    distinct?: PersistedGrantsScalarFieldEnum | PersistedGrantsScalarFieldEnum[]
  }

  /**
   * PersistedGrants create
   */
  export type PersistedGrantsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersistedGrants
     */
    select?: PersistedGrantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersistedGrants
     */
    omit?: PersistedGrantsOmit<ExtArgs> | null
    /**
     * The data needed to create a PersistedGrants.
     */
    data: XOR<PersistedGrantsCreateInput, PersistedGrantsUncheckedCreateInput>
  }

  /**
   * PersistedGrants createMany
   */
  export type PersistedGrantsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PersistedGrants.
     */
    data: PersistedGrantsCreateManyInput | PersistedGrantsCreateManyInput[]
  }

  /**
   * PersistedGrants update
   */
  export type PersistedGrantsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersistedGrants
     */
    select?: PersistedGrantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersistedGrants
     */
    omit?: PersistedGrantsOmit<ExtArgs> | null
    /**
     * The data needed to update a PersistedGrants.
     */
    data: XOR<PersistedGrantsUpdateInput, PersistedGrantsUncheckedUpdateInput>
    /**
     * Choose, which PersistedGrants to update.
     */
    where: PersistedGrantsWhereUniqueInput
  }

  /**
   * PersistedGrants updateMany
   */
  export type PersistedGrantsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PersistedGrants.
     */
    data: XOR<PersistedGrantsUpdateManyMutationInput, PersistedGrantsUncheckedUpdateManyInput>
    /**
     * Filter which PersistedGrants to update
     */
    where?: PersistedGrantsWhereInput
    /**
     * Limit how many PersistedGrants to update.
     */
    limit?: number
  }

  /**
   * PersistedGrants upsert
   */
  export type PersistedGrantsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersistedGrants
     */
    select?: PersistedGrantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersistedGrants
     */
    omit?: PersistedGrantsOmit<ExtArgs> | null
    /**
     * The filter to search for the PersistedGrants to update in case it exists.
     */
    where: PersistedGrantsWhereUniqueInput
    /**
     * In case the PersistedGrants found by the `where` argument doesn't exist, create a new PersistedGrants with this data.
     */
    create: XOR<PersistedGrantsCreateInput, PersistedGrantsUncheckedCreateInput>
    /**
     * In case the PersistedGrants was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PersistedGrantsUpdateInput, PersistedGrantsUncheckedUpdateInput>
  }

  /**
   * PersistedGrants delete
   */
  export type PersistedGrantsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersistedGrants
     */
    select?: PersistedGrantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersistedGrants
     */
    omit?: PersistedGrantsOmit<ExtArgs> | null
    /**
     * Filter which PersistedGrants to delete.
     */
    where: PersistedGrantsWhereUniqueInput
  }

  /**
   * PersistedGrants deleteMany
   */
  export type PersistedGrantsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PersistedGrants to delete
     */
    where?: PersistedGrantsWhereInput
    /**
     * Limit how many PersistedGrants to delete.
     */
    limit?: number
  }

  /**
   * PersistedGrants without action
   */
  export type PersistedGrantsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersistedGrants
     */
    select?: PersistedGrantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersistedGrants
     */
    omit?: PersistedGrantsOmit<ExtArgs> | null
  }


  /**
   * Model ProvisionedTokenIds
   */

  export type AggregateProvisionedTokenIds = {
    _count: ProvisionedTokenIdsCountAggregateOutputType | null
    _avg: ProvisionedTokenIdsAvgAggregateOutputType | null
    _sum: ProvisionedTokenIdsSumAggregateOutputType | null
    _min: ProvisionedTokenIdsMinAggregateOutputType | null
    _max: ProvisionedTokenIdsMaxAggregateOutputType | null
  }

  export type ProvisionedTokenIdsAvgAggregateOutputType = {
    Id: number | null
  }

  export type ProvisionedTokenIdsSumAggregateOutputType = {
    Id: number | null
  }

  export type ProvisionedTokenIdsMinAggregateOutputType = {
    Id: number | null
    ProvisionedTokenId: string | null
    PanEnrollmentId: string | null
    TokenReferenceId: string | null
  }

  export type ProvisionedTokenIdsMaxAggregateOutputType = {
    Id: number | null
    ProvisionedTokenId: string | null
    PanEnrollmentId: string | null
    TokenReferenceId: string | null
  }

  export type ProvisionedTokenIdsCountAggregateOutputType = {
    Id: number
    ProvisionedTokenId: number
    PanEnrollmentId: number
    TokenReferenceId: number
    _all: number
  }


  export type ProvisionedTokenIdsAvgAggregateInputType = {
    Id?: true
  }

  export type ProvisionedTokenIdsSumAggregateInputType = {
    Id?: true
  }

  export type ProvisionedTokenIdsMinAggregateInputType = {
    Id?: true
    ProvisionedTokenId?: true
    PanEnrollmentId?: true
    TokenReferenceId?: true
  }

  export type ProvisionedTokenIdsMaxAggregateInputType = {
    Id?: true
    ProvisionedTokenId?: true
    PanEnrollmentId?: true
    TokenReferenceId?: true
  }

  export type ProvisionedTokenIdsCountAggregateInputType = {
    Id?: true
    ProvisionedTokenId?: true
    PanEnrollmentId?: true
    TokenReferenceId?: true
    _all?: true
  }

  export type ProvisionedTokenIdsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProvisionedTokenIds to aggregate.
     */
    where?: ProvisionedTokenIdsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProvisionedTokenIds to fetch.
     */
    orderBy?: ProvisionedTokenIdsOrderByWithRelationInput | ProvisionedTokenIdsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProvisionedTokenIdsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProvisionedTokenIds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProvisionedTokenIds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProvisionedTokenIds
    **/
    _count?: true | ProvisionedTokenIdsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProvisionedTokenIdsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProvisionedTokenIdsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProvisionedTokenIdsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProvisionedTokenIdsMaxAggregateInputType
  }

  export type GetProvisionedTokenIdsAggregateType<T extends ProvisionedTokenIdsAggregateArgs> = {
        [P in keyof T & keyof AggregateProvisionedTokenIds]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProvisionedTokenIds[P]>
      : GetScalarType<T[P], AggregateProvisionedTokenIds[P]>
  }




  export type ProvisionedTokenIdsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProvisionedTokenIdsWhereInput
    orderBy?: ProvisionedTokenIdsOrderByWithAggregationInput | ProvisionedTokenIdsOrderByWithAggregationInput[]
    by: ProvisionedTokenIdsScalarFieldEnum[] | ProvisionedTokenIdsScalarFieldEnum
    having?: ProvisionedTokenIdsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProvisionedTokenIdsCountAggregateInputType | true
    _avg?: ProvisionedTokenIdsAvgAggregateInputType
    _sum?: ProvisionedTokenIdsSumAggregateInputType
    _min?: ProvisionedTokenIdsMinAggregateInputType
    _max?: ProvisionedTokenIdsMaxAggregateInputType
  }

  export type ProvisionedTokenIdsGroupByOutputType = {
    Id: number
    ProvisionedTokenId: string | null
    PanEnrollmentId: string | null
    TokenReferenceId: string | null
    _count: ProvisionedTokenIdsCountAggregateOutputType | null
    _avg: ProvisionedTokenIdsAvgAggregateOutputType | null
    _sum: ProvisionedTokenIdsSumAggregateOutputType | null
    _min: ProvisionedTokenIdsMinAggregateOutputType | null
    _max: ProvisionedTokenIdsMaxAggregateOutputType | null
  }

  type GetProvisionedTokenIdsGroupByPayload<T extends ProvisionedTokenIdsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProvisionedTokenIdsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProvisionedTokenIdsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProvisionedTokenIdsGroupByOutputType[P]>
            : GetScalarType<T[P], ProvisionedTokenIdsGroupByOutputType[P]>
        }
      >
    >


  export type ProvisionedTokenIdsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    ProvisionedTokenId?: boolean
    PanEnrollmentId?: boolean
    TokenReferenceId?: boolean
  }, ExtArgs["result"]["provisionedTokenIds"]>



  export type ProvisionedTokenIdsSelectScalar = {
    Id?: boolean
    ProvisionedTokenId?: boolean
    PanEnrollmentId?: boolean
    TokenReferenceId?: boolean
  }

  export type ProvisionedTokenIdsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Id" | "ProvisionedTokenId" | "PanEnrollmentId" | "TokenReferenceId", ExtArgs["result"]["provisionedTokenIds"]>

  export type $ProvisionedTokenIdsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProvisionedTokenIds"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      Id: number
      ProvisionedTokenId: string | null
      PanEnrollmentId: string | null
      TokenReferenceId: string | null
    }, ExtArgs["result"]["provisionedTokenIds"]>
    composites: {}
  }

  type ProvisionedTokenIdsGetPayload<S extends boolean | null | undefined | ProvisionedTokenIdsDefaultArgs> = $Result.GetResult<Prisma.$ProvisionedTokenIdsPayload, S>

  type ProvisionedTokenIdsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProvisionedTokenIdsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProvisionedTokenIdsCountAggregateInputType | true
    }

  export interface ProvisionedTokenIdsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProvisionedTokenIds'], meta: { name: 'ProvisionedTokenIds' } }
    /**
     * Find zero or one ProvisionedTokenIds that matches the filter.
     * @param {ProvisionedTokenIdsFindUniqueArgs} args - Arguments to find a ProvisionedTokenIds
     * @example
     * // Get one ProvisionedTokenIds
     * const provisionedTokenIds = await prisma.provisionedTokenIds.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProvisionedTokenIdsFindUniqueArgs>(args: SelectSubset<T, ProvisionedTokenIdsFindUniqueArgs<ExtArgs>>): Prisma__ProvisionedTokenIdsClient<$Result.GetResult<Prisma.$ProvisionedTokenIdsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProvisionedTokenIds that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProvisionedTokenIdsFindUniqueOrThrowArgs} args - Arguments to find a ProvisionedTokenIds
     * @example
     * // Get one ProvisionedTokenIds
     * const provisionedTokenIds = await prisma.provisionedTokenIds.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProvisionedTokenIdsFindUniqueOrThrowArgs>(args: SelectSubset<T, ProvisionedTokenIdsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProvisionedTokenIdsClient<$Result.GetResult<Prisma.$ProvisionedTokenIdsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProvisionedTokenIds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvisionedTokenIdsFindFirstArgs} args - Arguments to find a ProvisionedTokenIds
     * @example
     * // Get one ProvisionedTokenIds
     * const provisionedTokenIds = await prisma.provisionedTokenIds.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProvisionedTokenIdsFindFirstArgs>(args?: SelectSubset<T, ProvisionedTokenIdsFindFirstArgs<ExtArgs>>): Prisma__ProvisionedTokenIdsClient<$Result.GetResult<Prisma.$ProvisionedTokenIdsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProvisionedTokenIds that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvisionedTokenIdsFindFirstOrThrowArgs} args - Arguments to find a ProvisionedTokenIds
     * @example
     * // Get one ProvisionedTokenIds
     * const provisionedTokenIds = await prisma.provisionedTokenIds.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProvisionedTokenIdsFindFirstOrThrowArgs>(args?: SelectSubset<T, ProvisionedTokenIdsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProvisionedTokenIdsClient<$Result.GetResult<Prisma.$ProvisionedTokenIdsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProvisionedTokenIds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvisionedTokenIdsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProvisionedTokenIds
     * const provisionedTokenIds = await prisma.provisionedTokenIds.findMany()
     * 
     * // Get first 10 ProvisionedTokenIds
     * const provisionedTokenIds = await prisma.provisionedTokenIds.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const provisionedTokenIdsWithIdOnly = await prisma.provisionedTokenIds.findMany({ select: { Id: true } })
     * 
     */
    findMany<T extends ProvisionedTokenIdsFindManyArgs>(args?: SelectSubset<T, ProvisionedTokenIdsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProvisionedTokenIdsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProvisionedTokenIds.
     * @param {ProvisionedTokenIdsCreateArgs} args - Arguments to create a ProvisionedTokenIds.
     * @example
     * // Create one ProvisionedTokenIds
     * const ProvisionedTokenIds = await prisma.provisionedTokenIds.create({
     *   data: {
     *     // ... data to create a ProvisionedTokenIds
     *   }
     * })
     * 
     */
    create<T extends ProvisionedTokenIdsCreateArgs>(args: SelectSubset<T, ProvisionedTokenIdsCreateArgs<ExtArgs>>): Prisma__ProvisionedTokenIdsClient<$Result.GetResult<Prisma.$ProvisionedTokenIdsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProvisionedTokenIds.
     * @param {ProvisionedTokenIdsCreateManyArgs} args - Arguments to create many ProvisionedTokenIds.
     * @example
     * // Create many ProvisionedTokenIds
     * const provisionedTokenIds = await prisma.provisionedTokenIds.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProvisionedTokenIdsCreateManyArgs>(args?: SelectSubset<T, ProvisionedTokenIdsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProvisionedTokenIds.
     * @param {ProvisionedTokenIdsDeleteArgs} args - Arguments to delete one ProvisionedTokenIds.
     * @example
     * // Delete one ProvisionedTokenIds
     * const ProvisionedTokenIds = await prisma.provisionedTokenIds.delete({
     *   where: {
     *     // ... filter to delete one ProvisionedTokenIds
     *   }
     * })
     * 
     */
    delete<T extends ProvisionedTokenIdsDeleteArgs>(args: SelectSubset<T, ProvisionedTokenIdsDeleteArgs<ExtArgs>>): Prisma__ProvisionedTokenIdsClient<$Result.GetResult<Prisma.$ProvisionedTokenIdsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProvisionedTokenIds.
     * @param {ProvisionedTokenIdsUpdateArgs} args - Arguments to update one ProvisionedTokenIds.
     * @example
     * // Update one ProvisionedTokenIds
     * const provisionedTokenIds = await prisma.provisionedTokenIds.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProvisionedTokenIdsUpdateArgs>(args: SelectSubset<T, ProvisionedTokenIdsUpdateArgs<ExtArgs>>): Prisma__ProvisionedTokenIdsClient<$Result.GetResult<Prisma.$ProvisionedTokenIdsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProvisionedTokenIds.
     * @param {ProvisionedTokenIdsDeleteManyArgs} args - Arguments to filter ProvisionedTokenIds to delete.
     * @example
     * // Delete a few ProvisionedTokenIds
     * const { count } = await prisma.provisionedTokenIds.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProvisionedTokenIdsDeleteManyArgs>(args?: SelectSubset<T, ProvisionedTokenIdsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProvisionedTokenIds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvisionedTokenIdsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProvisionedTokenIds
     * const provisionedTokenIds = await prisma.provisionedTokenIds.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProvisionedTokenIdsUpdateManyArgs>(args: SelectSubset<T, ProvisionedTokenIdsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProvisionedTokenIds.
     * @param {ProvisionedTokenIdsUpsertArgs} args - Arguments to update or create a ProvisionedTokenIds.
     * @example
     * // Update or create a ProvisionedTokenIds
     * const provisionedTokenIds = await prisma.provisionedTokenIds.upsert({
     *   create: {
     *     // ... data to create a ProvisionedTokenIds
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProvisionedTokenIds we want to update
     *   }
     * })
     */
    upsert<T extends ProvisionedTokenIdsUpsertArgs>(args: SelectSubset<T, ProvisionedTokenIdsUpsertArgs<ExtArgs>>): Prisma__ProvisionedTokenIdsClient<$Result.GetResult<Prisma.$ProvisionedTokenIdsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProvisionedTokenIds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvisionedTokenIdsCountArgs} args - Arguments to filter ProvisionedTokenIds to count.
     * @example
     * // Count the number of ProvisionedTokenIds
     * const count = await prisma.provisionedTokenIds.count({
     *   where: {
     *     // ... the filter for the ProvisionedTokenIds we want to count
     *   }
     * })
    **/
    count<T extends ProvisionedTokenIdsCountArgs>(
      args?: Subset<T, ProvisionedTokenIdsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProvisionedTokenIdsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProvisionedTokenIds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvisionedTokenIdsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProvisionedTokenIdsAggregateArgs>(args: Subset<T, ProvisionedTokenIdsAggregateArgs>): Prisma.PrismaPromise<GetProvisionedTokenIdsAggregateType<T>>

    /**
     * Group by ProvisionedTokenIds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvisionedTokenIdsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProvisionedTokenIdsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProvisionedTokenIdsGroupByArgs['orderBy'] }
        : { orderBy?: ProvisionedTokenIdsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProvisionedTokenIdsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProvisionedTokenIdsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProvisionedTokenIds model
   */
  readonly fields: ProvisionedTokenIdsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProvisionedTokenIds.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProvisionedTokenIdsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProvisionedTokenIds model
   */
  interface ProvisionedTokenIdsFieldRefs {
    readonly Id: FieldRef<"ProvisionedTokenIds", 'Int'>
    readonly ProvisionedTokenId: FieldRef<"ProvisionedTokenIds", 'String'>
    readonly PanEnrollmentId: FieldRef<"ProvisionedTokenIds", 'String'>
    readonly TokenReferenceId: FieldRef<"ProvisionedTokenIds", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ProvisionedTokenIds findUnique
   */
  export type ProvisionedTokenIdsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProvisionedTokenIds
     */
    select?: ProvisionedTokenIdsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProvisionedTokenIds
     */
    omit?: ProvisionedTokenIdsOmit<ExtArgs> | null
    /**
     * Filter, which ProvisionedTokenIds to fetch.
     */
    where: ProvisionedTokenIdsWhereUniqueInput
  }

  /**
   * ProvisionedTokenIds findUniqueOrThrow
   */
  export type ProvisionedTokenIdsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProvisionedTokenIds
     */
    select?: ProvisionedTokenIdsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProvisionedTokenIds
     */
    omit?: ProvisionedTokenIdsOmit<ExtArgs> | null
    /**
     * Filter, which ProvisionedTokenIds to fetch.
     */
    where: ProvisionedTokenIdsWhereUniqueInput
  }

  /**
   * ProvisionedTokenIds findFirst
   */
  export type ProvisionedTokenIdsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProvisionedTokenIds
     */
    select?: ProvisionedTokenIdsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProvisionedTokenIds
     */
    omit?: ProvisionedTokenIdsOmit<ExtArgs> | null
    /**
     * Filter, which ProvisionedTokenIds to fetch.
     */
    where?: ProvisionedTokenIdsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProvisionedTokenIds to fetch.
     */
    orderBy?: ProvisionedTokenIdsOrderByWithRelationInput | ProvisionedTokenIdsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProvisionedTokenIds.
     */
    cursor?: ProvisionedTokenIdsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProvisionedTokenIds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProvisionedTokenIds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProvisionedTokenIds.
     */
    distinct?: ProvisionedTokenIdsScalarFieldEnum | ProvisionedTokenIdsScalarFieldEnum[]
  }

  /**
   * ProvisionedTokenIds findFirstOrThrow
   */
  export type ProvisionedTokenIdsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProvisionedTokenIds
     */
    select?: ProvisionedTokenIdsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProvisionedTokenIds
     */
    omit?: ProvisionedTokenIdsOmit<ExtArgs> | null
    /**
     * Filter, which ProvisionedTokenIds to fetch.
     */
    where?: ProvisionedTokenIdsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProvisionedTokenIds to fetch.
     */
    orderBy?: ProvisionedTokenIdsOrderByWithRelationInput | ProvisionedTokenIdsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProvisionedTokenIds.
     */
    cursor?: ProvisionedTokenIdsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProvisionedTokenIds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProvisionedTokenIds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProvisionedTokenIds.
     */
    distinct?: ProvisionedTokenIdsScalarFieldEnum | ProvisionedTokenIdsScalarFieldEnum[]
  }

  /**
   * ProvisionedTokenIds findMany
   */
  export type ProvisionedTokenIdsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProvisionedTokenIds
     */
    select?: ProvisionedTokenIdsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProvisionedTokenIds
     */
    omit?: ProvisionedTokenIdsOmit<ExtArgs> | null
    /**
     * Filter, which ProvisionedTokenIds to fetch.
     */
    where?: ProvisionedTokenIdsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProvisionedTokenIds to fetch.
     */
    orderBy?: ProvisionedTokenIdsOrderByWithRelationInput | ProvisionedTokenIdsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProvisionedTokenIds.
     */
    cursor?: ProvisionedTokenIdsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProvisionedTokenIds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProvisionedTokenIds.
     */
    skip?: number
    distinct?: ProvisionedTokenIdsScalarFieldEnum | ProvisionedTokenIdsScalarFieldEnum[]
  }

  /**
   * ProvisionedTokenIds create
   */
  export type ProvisionedTokenIdsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProvisionedTokenIds
     */
    select?: ProvisionedTokenIdsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProvisionedTokenIds
     */
    omit?: ProvisionedTokenIdsOmit<ExtArgs> | null
    /**
     * The data needed to create a ProvisionedTokenIds.
     */
    data?: XOR<ProvisionedTokenIdsCreateInput, ProvisionedTokenIdsUncheckedCreateInput>
  }

  /**
   * ProvisionedTokenIds createMany
   */
  export type ProvisionedTokenIdsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProvisionedTokenIds.
     */
    data: ProvisionedTokenIdsCreateManyInput | ProvisionedTokenIdsCreateManyInput[]
  }

  /**
   * ProvisionedTokenIds update
   */
  export type ProvisionedTokenIdsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProvisionedTokenIds
     */
    select?: ProvisionedTokenIdsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProvisionedTokenIds
     */
    omit?: ProvisionedTokenIdsOmit<ExtArgs> | null
    /**
     * The data needed to update a ProvisionedTokenIds.
     */
    data: XOR<ProvisionedTokenIdsUpdateInput, ProvisionedTokenIdsUncheckedUpdateInput>
    /**
     * Choose, which ProvisionedTokenIds to update.
     */
    where: ProvisionedTokenIdsWhereUniqueInput
  }

  /**
   * ProvisionedTokenIds updateMany
   */
  export type ProvisionedTokenIdsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProvisionedTokenIds.
     */
    data: XOR<ProvisionedTokenIdsUpdateManyMutationInput, ProvisionedTokenIdsUncheckedUpdateManyInput>
    /**
     * Filter which ProvisionedTokenIds to update
     */
    where?: ProvisionedTokenIdsWhereInput
    /**
     * Limit how many ProvisionedTokenIds to update.
     */
    limit?: number
  }

  /**
   * ProvisionedTokenIds upsert
   */
  export type ProvisionedTokenIdsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProvisionedTokenIds
     */
    select?: ProvisionedTokenIdsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProvisionedTokenIds
     */
    omit?: ProvisionedTokenIdsOmit<ExtArgs> | null
    /**
     * The filter to search for the ProvisionedTokenIds to update in case it exists.
     */
    where: ProvisionedTokenIdsWhereUniqueInput
    /**
     * In case the ProvisionedTokenIds found by the `where` argument doesn't exist, create a new ProvisionedTokenIds with this data.
     */
    create: XOR<ProvisionedTokenIdsCreateInput, ProvisionedTokenIdsUncheckedCreateInput>
    /**
     * In case the ProvisionedTokenIds was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProvisionedTokenIdsUpdateInput, ProvisionedTokenIdsUncheckedUpdateInput>
  }

  /**
   * ProvisionedTokenIds delete
   */
  export type ProvisionedTokenIdsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProvisionedTokenIds
     */
    select?: ProvisionedTokenIdsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProvisionedTokenIds
     */
    omit?: ProvisionedTokenIdsOmit<ExtArgs> | null
    /**
     * Filter which ProvisionedTokenIds to delete.
     */
    where: ProvisionedTokenIdsWhereUniqueInput
  }

  /**
   * ProvisionedTokenIds deleteMany
   */
  export type ProvisionedTokenIdsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProvisionedTokenIds to delete
     */
    where?: ProvisionedTokenIdsWhereInput
    /**
     * Limit how many ProvisionedTokenIds to delete.
     */
    limit?: number
  }

  /**
   * ProvisionedTokenIds without action
   */
  export type ProvisionedTokenIdsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProvisionedTokenIds
     */
    select?: ProvisionedTokenIdsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProvisionedTokenIds
     */
    omit?: ProvisionedTokenIdsOmit<ExtArgs> | null
  }


  /**
   * Model RegisterLogEntry
   */

  export type AggregateRegisterLogEntry = {
    _count: RegisterLogEntryCountAggregateOutputType | null
    _avg: RegisterLogEntryAvgAggregateOutputType | null
    _sum: RegisterLogEntrySumAggregateOutputType | null
    _min: RegisterLogEntryMinAggregateOutputType | null
    _max: RegisterLogEntryMaxAggregateOutputType | null
  }

  export type RegisterLogEntryAvgAggregateOutputType = {
    Id: number | null
  }

  export type RegisterLogEntrySumAggregateOutputType = {
    Id: number | null
  }

  export type RegisterLogEntryMinAggregateOutputType = {
    Id: number | null
    DeviceId: string | null
    MobileNumber: string | null
    RegistrationDateTime: Date | null
  }

  export type RegisterLogEntryMaxAggregateOutputType = {
    Id: number | null
    DeviceId: string | null
    MobileNumber: string | null
    RegistrationDateTime: Date | null
  }

  export type RegisterLogEntryCountAggregateOutputType = {
    Id: number
    DeviceId: number
    MobileNumber: number
    RegistrationDateTime: number
    _all: number
  }


  export type RegisterLogEntryAvgAggregateInputType = {
    Id?: true
  }

  export type RegisterLogEntrySumAggregateInputType = {
    Id?: true
  }

  export type RegisterLogEntryMinAggregateInputType = {
    Id?: true
    DeviceId?: true
    MobileNumber?: true
    RegistrationDateTime?: true
  }

  export type RegisterLogEntryMaxAggregateInputType = {
    Id?: true
    DeviceId?: true
    MobileNumber?: true
    RegistrationDateTime?: true
  }

  export type RegisterLogEntryCountAggregateInputType = {
    Id?: true
    DeviceId?: true
    MobileNumber?: true
    RegistrationDateTime?: true
    _all?: true
  }

  export type RegisterLogEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RegisterLogEntry to aggregate.
     */
    where?: RegisterLogEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RegisterLogEntries to fetch.
     */
    orderBy?: RegisterLogEntryOrderByWithRelationInput | RegisterLogEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RegisterLogEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RegisterLogEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RegisterLogEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RegisterLogEntries
    **/
    _count?: true | RegisterLogEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RegisterLogEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RegisterLogEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RegisterLogEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RegisterLogEntryMaxAggregateInputType
  }

  export type GetRegisterLogEntryAggregateType<T extends RegisterLogEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateRegisterLogEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRegisterLogEntry[P]>
      : GetScalarType<T[P], AggregateRegisterLogEntry[P]>
  }




  export type RegisterLogEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RegisterLogEntryWhereInput
    orderBy?: RegisterLogEntryOrderByWithAggregationInput | RegisterLogEntryOrderByWithAggregationInput[]
    by: RegisterLogEntryScalarFieldEnum[] | RegisterLogEntryScalarFieldEnum
    having?: RegisterLogEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RegisterLogEntryCountAggregateInputType | true
    _avg?: RegisterLogEntryAvgAggregateInputType
    _sum?: RegisterLogEntrySumAggregateInputType
    _min?: RegisterLogEntryMinAggregateInputType
    _max?: RegisterLogEntryMaxAggregateInputType
  }

  export type RegisterLogEntryGroupByOutputType = {
    Id: number
    DeviceId: string | null
    MobileNumber: string | null
    RegistrationDateTime: Date
    _count: RegisterLogEntryCountAggregateOutputType | null
    _avg: RegisterLogEntryAvgAggregateOutputType | null
    _sum: RegisterLogEntrySumAggregateOutputType | null
    _min: RegisterLogEntryMinAggregateOutputType | null
    _max: RegisterLogEntryMaxAggregateOutputType | null
  }

  type GetRegisterLogEntryGroupByPayload<T extends RegisterLogEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RegisterLogEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RegisterLogEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RegisterLogEntryGroupByOutputType[P]>
            : GetScalarType<T[P], RegisterLogEntryGroupByOutputType[P]>
        }
      >
    >


  export type RegisterLogEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    DeviceId?: boolean
    MobileNumber?: boolean
    RegistrationDateTime?: boolean
  }, ExtArgs["result"]["registerLogEntry"]>



  export type RegisterLogEntrySelectScalar = {
    Id?: boolean
    DeviceId?: boolean
    MobileNumber?: boolean
    RegistrationDateTime?: boolean
  }

  export type RegisterLogEntryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Id" | "DeviceId" | "MobileNumber" | "RegistrationDateTime", ExtArgs["result"]["registerLogEntry"]>

  export type $RegisterLogEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RegisterLogEntry"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      Id: number
      DeviceId: string | null
      MobileNumber: string | null
      RegistrationDateTime: Date
    }, ExtArgs["result"]["registerLogEntry"]>
    composites: {}
  }

  type RegisterLogEntryGetPayload<S extends boolean | null | undefined | RegisterLogEntryDefaultArgs> = $Result.GetResult<Prisma.$RegisterLogEntryPayload, S>

  type RegisterLogEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RegisterLogEntryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RegisterLogEntryCountAggregateInputType | true
    }

  export interface RegisterLogEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RegisterLogEntry'], meta: { name: 'RegisterLogEntry' } }
    /**
     * Find zero or one RegisterLogEntry that matches the filter.
     * @param {RegisterLogEntryFindUniqueArgs} args - Arguments to find a RegisterLogEntry
     * @example
     * // Get one RegisterLogEntry
     * const registerLogEntry = await prisma.registerLogEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RegisterLogEntryFindUniqueArgs>(args: SelectSubset<T, RegisterLogEntryFindUniqueArgs<ExtArgs>>): Prisma__RegisterLogEntryClient<$Result.GetResult<Prisma.$RegisterLogEntryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RegisterLogEntry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RegisterLogEntryFindUniqueOrThrowArgs} args - Arguments to find a RegisterLogEntry
     * @example
     * // Get one RegisterLogEntry
     * const registerLogEntry = await prisma.registerLogEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RegisterLogEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, RegisterLogEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RegisterLogEntryClient<$Result.GetResult<Prisma.$RegisterLogEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RegisterLogEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegisterLogEntryFindFirstArgs} args - Arguments to find a RegisterLogEntry
     * @example
     * // Get one RegisterLogEntry
     * const registerLogEntry = await prisma.registerLogEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RegisterLogEntryFindFirstArgs>(args?: SelectSubset<T, RegisterLogEntryFindFirstArgs<ExtArgs>>): Prisma__RegisterLogEntryClient<$Result.GetResult<Prisma.$RegisterLogEntryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RegisterLogEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegisterLogEntryFindFirstOrThrowArgs} args - Arguments to find a RegisterLogEntry
     * @example
     * // Get one RegisterLogEntry
     * const registerLogEntry = await prisma.registerLogEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RegisterLogEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, RegisterLogEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__RegisterLogEntryClient<$Result.GetResult<Prisma.$RegisterLogEntryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RegisterLogEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegisterLogEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RegisterLogEntries
     * const registerLogEntries = await prisma.registerLogEntry.findMany()
     * 
     * // Get first 10 RegisterLogEntries
     * const registerLogEntries = await prisma.registerLogEntry.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const registerLogEntryWithIdOnly = await prisma.registerLogEntry.findMany({ select: { Id: true } })
     * 
     */
    findMany<T extends RegisterLogEntryFindManyArgs>(args?: SelectSubset<T, RegisterLogEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegisterLogEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RegisterLogEntry.
     * @param {RegisterLogEntryCreateArgs} args - Arguments to create a RegisterLogEntry.
     * @example
     * // Create one RegisterLogEntry
     * const RegisterLogEntry = await prisma.registerLogEntry.create({
     *   data: {
     *     // ... data to create a RegisterLogEntry
     *   }
     * })
     * 
     */
    create<T extends RegisterLogEntryCreateArgs>(args: SelectSubset<T, RegisterLogEntryCreateArgs<ExtArgs>>): Prisma__RegisterLogEntryClient<$Result.GetResult<Prisma.$RegisterLogEntryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RegisterLogEntries.
     * @param {RegisterLogEntryCreateManyArgs} args - Arguments to create many RegisterLogEntries.
     * @example
     * // Create many RegisterLogEntries
     * const registerLogEntry = await prisma.registerLogEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RegisterLogEntryCreateManyArgs>(args?: SelectSubset<T, RegisterLogEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RegisterLogEntry.
     * @param {RegisterLogEntryDeleteArgs} args - Arguments to delete one RegisterLogEntry.
     * @example
     * // Delete one RegisterLogEntry
     * const RegisterLogEntry = await prisma.registerLogEntry.delete({
     *   where: {
     *     // ... filter to delete one RegisterLogEntry
     *   }
     * })
     * 
     */
    delete<T extends RegisterLogEntryDeleteArgs>(args: SelectSubset<T, RegisterLogEntryDeleteArgs<ExtArgs>>): Prisma__RegisterLogEntryClient<$Result.GetResult<Prisma.$RegisterLogEntryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RegisterLogEntry.
     * @param {RegisterLogEntryUpdateArgs} args - Arguments to update one RegisterLogEntry.
     * @example
     * // Update one RegisterLogEntry
     * const registerLogEntry = await prisma.registerLogEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RegisterLogEntryUpdateArgs>(args: SelectSubset<T, RegisterLogEntryUpdateArgs<ExtArgs>>): Prisma__RegisterLogEntryClient<$Result.GetResult<Prisma.$RegisterLogEntryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RegisterLogEntries.
     * @param {RegisterLogEntryDeleteManyArgs} args - Arguments to filter RegisterLogEntries to delete.
     * @example
     * // Delete a few RegisterLogEntries
     * const { count } = await prisma.registerLogEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RegisterLogEntryDeleteManyArgs>(args?: SelectSubset<T, RegisterLogEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RegisterLogEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegisterLogEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RegisterLogEntries
     * const registerLogEntry = await prisma.registerLogEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RegisterLogEntryUpdateManyArgs>(args: SelectSubset<T, RegisterLogEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RegisterLogEntry.
     * @param {RegisterLogEntryUpsertArgs} args - Arguments to update or create a RegisterLogEntry.
     * @example
     * // Update or create a RegisterLogEntry
     * const registerLogEntry = await prisma.registerLogEntry.upsert({
     *   create: {
     *     // ... data to create a RegisterLogEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RegisterLogEntry we want to update
     *   }
     * })
     */
    upsert<T extends RegisterLogEntryUpsertArgs>(args: SelectSubset<T, RegisterLogEntryUpsertArgs<ExtArgs>>): Prisma__RegisterLogEntryClient<$Result.GetResult<Prisma.$RegisterLogEntryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RegisterLogEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegisterLogEntryCountArgs} args - Arguments to filter RegisterLogEntries to count.
     * @example
     * // Count the number of RegisterLogEntries
     * const count = await prisma.registerLogEntry.count({
     *   where: {
     *     // ... the filter for the RegisterLogEntries we want to count
     *   }
     * })
    **/
    count<T extends RegisterLogEntryCountArgs>(
      args?: Subset<T, RegisterLogEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RegisterLogEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RegisterLogEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegisterLogEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RegisterLogEntryAggregateArgs>(args: Subset<T, RegisterLogEntryAggregateArgs>): Prisma.PrismaPromise<GetRegisterLogEntryAggregateType<T>>

    /**
     * Group by RegisterLogEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegisterLogEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RegisterLogEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RegisterLogEntryGroupByArgs['orderBy'] }
        : { orderBy?: RegisterLogEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RegisterLogEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRegisterLogEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RegisterLogEntry model
   */
  readonly fields: RegisterLogEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RegisterLogEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RegisterLogEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RegisterLogEntry model
   */
  interface RegisterLogEntryFieldRefs {
    readonly Id: FieldRef<"RegisterLogEntry", 'Int'>
    readonly DeviceId: FieldRef<"RegisterLogEntry", 'String'>
    readonly MobileNumber: FieldRef<"RegisterLogEntry", 'String'>
    readonly RegistrationDateTime: FieldRef<"RegisterLogEntry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RegisterLogEntry findUnique
   */
  export type RegisterLogEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegisterLogEntry
     */
    select?: RegisterLogEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegisterLogEntry
     */
    omit?: RegisterLogEntryOmit<ExtArgs> | null
    /**
     * Filter, which RegisterLogEntry to fetch.
     */
    where: RegisterLogEntryWhereUniqueInput
  }

  /**
   * RegisterLogEntry findUniqueOrThrow
   */
  export type RegisterLogEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegisterLogEntry
     */
    select?: RegisterLogEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegisterLogEntry
     */
    omit?: RegisterLogEntryOmit<ExtArgs> | null
    /**
     * Filter, which RegisterLogEntry to fetch.
     */
    where: RegisterLogEntryWhereUniqueInput
  }

  /**
   * RegisterLogEntry findFirst
   */
  export type RegisterLogEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegisterLogEntry
     */
    select?: RegisterLogEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegisterLogEntry
     */
    omit?: RegisterLogEntryOmit<ExtArgs> | null
    /**
     * Filter, which RegisterLogEntry to fetch.
     */
    where?: RegisterLogEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RegisterLogEntries to fetch.
     */
    orderBy?: RegisterLogEntryOrderByWithRelationInput | RegisterLogEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RegisterLogEntries.
     */
    cursor?: RegisterLogEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RegisterLogEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RegisterLogEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RegisterLogEntries.
     */
    distinct?: RegisterLogEntryScalarFieldEnum | RegisterLogEntryScalarFieldEnum[]
  }

  /**
   * RegisterLogEntry findFirstOrThrow
   */
  export type RegisterLogEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegisterLogEntry
     */
    select?: RegisterLogEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegisterLogEntry
     */
    omit?: RegisterLogEntryOmit<ExtArgs> | null
    /**
     * Filter, which RegisterLogEntry to fetch.
     */
    where?: RegisterLogEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RegisterLogEntries to fetch.
     */
    orderBy?: RegisterLogEntryOrderByWithRelationInput | RegisterLogEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RegisterLogEntries.
     */
    cursor?: RegisterLogEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RegisterLogEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RegisterLogEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RegisterLogEntries.
     */
    distinct?: RegisterLogEntryScalarFieldEnum | RegisterLogEntryScalarFieldEnum[]
  }

  /**
   * RegisterLogEntry findMany
   */
  export type RegisterLogEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegisterLogEntry
     */
    select?: RegisterLogEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegisterLogEntry
     */
    omit?: RegisterLogEntryOmit<ExtArgs> | null
    /**
     * Filter, which RegisterLogEntries to fetch.
     */
    where?: RegisterLogEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RegisterLogEntries to fetch.
     */
    orderBy?: RegisterLogEntryOrderByWithRelationInput | RegisterLogEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RegisterLogEntries.
     */
    cursor?: RegisterLogEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RegisterLogEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RegisterLogEntries.
     */
    skip?: number
    distinct?: RegisterLogEntryScalarFieldEnum | RegisterLogEntryScalarFieldEnum[]
  }

  /**
   * RegisterLogEntry create
   */
  export type RegisterLogEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegisterLogEntry
     */
    select?: RegisterLogEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegisterLogEntry
     */
    omit?: RegisterLogEntryOmit<ExtArgs> | null
    /**
     * The data needed to create a RegisterLogEntry.
     */
    data: XOR<RegisterLogEntryCreateInput, RegisterLogEntryUncheckedCreateInput>
  }

  /**
   * RegisterLogEntry createMany
   */
  export type RegisterLogEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RegisterLogEntries.
     */
    data: RegisterLogEntryCreateManyInput | RegisterLogEntryCreateManyInput[]
  }

  /**
   * RegisterLogEntry update
   */
  export type RegisterLogEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegisterLogEntry
     */
    select?: RegisterLogEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegisterLogEntry
     */
    omit?: RegisterLogEntryOmit<ExtArgs> | null
    /**
     * The data needed to update a RegisterLogEntry.
     */
    data: XOR<RegisterLogEntryUpdateInput, RegisterLogEntryUncheckedUpdateInput>
    /**
     * Choose, which RegisterLogEntry to update.
     */
    where: RegisterLogEntryWhereUniqueInput
  }

  /**
   * RegisterLogEntry updateMany
   */
  export type RegisterLogEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RegisterLogEntries.
     */
    data: XOR<RegisterLogEntryUpdateManyMutationInput, RegisterLogEntryUncheckedUpdateManyInput>
    /**
     * Filter which RegisterLogEntries to update
     */
    where?: RegisterLogEntryWhereInput
    /**
     * Limit how many RegisterLogEntries to update.
     */
    limit?: number
  }

  /**
   * RegisterLogEntry upsert
   */
  export type RegisterLogEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegisterLogEntry
     */
    select?: RegisterLogEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegisterLogEntry
     */
    omit?: RegisterLogEntryOmit<ExtArgs> | null
    /**
     * The filter to search for the RegisterLogEntry to update in case it exists.
     */
    where: RegisterLogEntryWhereUniqueInput
    /**
     * In case the RegisterLogEntry found by the `where` argument doesn't exist, create a new RegisterLogEntry with this data.
     */
    create: XOR<RegisterLogEntryCreateInput, RegisterLogEntryUncheckedCreateInput>
    /**
     * In case the RegisterLogEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RegisterLogEntryUpdateInput, RegisterLogEntryUncheckedUpdateInput>
  }

  /**
   * RegisterLogEntry delete
   */
  export type RegisterLogEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegisterLogEntry
     */
    select?: RegisterLogEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegisterLogEntry
     */
    omit?: RegisterLogEntryOmit<ExtArgs> | null
    /**
     * Filter which RegisterLogEntry to delete.
     */
    where: RegisterLogEntryWhereUniqueInput
  }

  /**
   * RegisterLogEntry deleteMany
   */
  export type RegisterLogEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RegisterLogEntries to delete
     */
    where?: RegisterLogEntryWhereInput
    /**
     * Limit how many RegisterLogEntries to delete.
     */
    limit?: number
  }

  /**
   * RegisterLogEntry without action
   */
  export type RegisterLogEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegisterLogEntry
     */
    select?: RegisterLogEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RegisterLogEntry
     */
    omit?: RegisterLogEntryOmit<ExtArgs> | null
  }


  /**
   * Model sysdiagrams
   */

  export type AggregateSysdiagrams = {
    _count: SysdiagramsCountAggregateOutputType | null
    _avg: SysdiagramsAvgAggregateOutputType | null
    _sum: SysdiagramsSumAggregateOutputType | null
    _min: SysdiagramsMinAggregateOutputType | null
    _max: SysdiagramsMaxAggregateOutputType | null
  }

  export type SysdiagramsAvgAggregateOutputType = {
    principal_id: number | null
    diagram_id: number | null
    version: number | null
  }

  export type SysdiagramsSumAggregateOutputType = {
    principal_id: number | null
    diagram_id: number | null
    version: number | null
  }

  export type SysdiagramsMinAggregateOutputType = {
    name: string | null
    principal_id: number | null
    diagram_id: number | null
    version: number | null
    definition: Uint8Array | null
  }

  export type SysdiagramsMaxAggregateOutputType = {
    name: string | null
    principal_id: number | null
    diagram_id: number | null
    version: number | null
    definition: Uint8Array | null
  }

  export type SysdiagramsCountAggregateOutputType = {
    name: number
    principal_id: number
    diagram_id: number
    version: number
    definition: number
    _all: number
  }


  export type SysdiagramsAvgAggregateInputType = {
    principal_id?: true
    diagram_id?: true
    version?: true
  }

  export type SysdiagramsSumAggregateInputType = {
    principal_id?: true
    diagram_id?: true
    version?: true
  }

  export type SysdiagramsMinAggregateInputType = {
    name?: true
    principal_id?: true
    diagram_id?: true
    version?: true
    definition?: true
  }

  export type SysdiagramsMaxAggregateInputType = {
    name?: true
    principal_id?: true
    diagram_id?: true
    version?: true
    definition?: true
  }

  export type SysdiagramsCountAggregateInputType = {
    name?: true
    principal_id?: true
    diagram_id?: true
    version?: true
    definition?: true
    _all?: true
  }

  export type SysdiagramsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sysdiagrams to aggregate.
     */
    where?: sysdiagramsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sysdiagrams to fetch.
     */
    orderBy?: sysdiagramsOrderByWithRelationInput | sysdiagramsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sysdiagramsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sysdiagrams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sysdiagrams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sysdiagrams
    **/
    _count?: true | SysdiagramsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SysdiagramsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SysdiagramsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SysdiagramsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SysdiagramsMaxAggregateInputType
  }

  export type GetSysdiagramsAggregateType<T extends SysdiagramsAggregateArgs> = {
        [P in keyof T & keyof AggregateSysdiagrams]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSysdiagrams[P]>
      : GetScalarType<T[P], AggregateSysdiagrams[P]>
  }




  export type sysdiagramsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sysdiagramsWhereInput
    orderBy?: sysdiagramsOrderByWithAggregationInput | sysdiagramsOrderByWithAggregationInput[]
    by: SysdiagramsScalarFieldEnum[] | SysdiagramsScalarFieldEnum
    having?: sysdiagramsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SysdiagramsCountAggregateInputType | true
    _avg?: SysdiagramsAvgAggregateInputType
    _sum?: SysdiagramsSumAggregateInputType
    _min?: SysdiagramsMinAggregateInputType
    _max?: SysdiagramsMaxAggregateInputType
  }

  export type SysdiagramsGroupByOutputType = {
    name: string
    principal_id: number
    diagram_id: number
    version: number | null
    definition: Uint8Array | null
    _count: SysdiagramsCountAggregateOutputType | null
    _avg: SysdiagramsAvgAggregateOutputType | null
    _sum: SysdiagramsSumAggregateOutputType | null
    _min: SysdiagramsMinAggregateOutputType | null
    _max: SysdiagramsMaxAggregateOutputType | null
  }

  type GetSysdiagramsGroupByPayload<T extends sysdiagramsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SysdiagramsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SysdiagramsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SysdiagramsGroupByOutputType[P]>
            : GetScalarType<T[P], SysdiagramsGroupByOutputType[P]>
        }
      >
    >


  export type sysdiagramsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    name?: boolean
    principal_id?: boolean
    diagram_id?: boolean
    version?: boolean
    definition?: boolean
  }, ExtArgs["result"]["sysdiagrams"]>



  export type sysdiagramsSelectScalar = {
    name?: boolean
    principal_id?: boolean
    diagram_id?: boolean
    version?: boolean
    definition?: boolean
  }

  export type sysdiagramsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"name" | "principal_id" | "diagram_id" | "version" | "definition", ExtArgs["result"]["sysdiagrams"]>

  export type $sysdiagramsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "sysdiagrams"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      name: string
      principal_id: number
      diagram_id: number
      version: number | null
      definition: Uint8Array | null
    }, ExtArgs["result"]["sysdiagrams"]>
    composites: {}
  }

  type sysdiagramsGetPayload<S extends boolean | null | undefined | sysdiagramsDefaultArgs> = $Result.GetResult<Prisma.$sysdiagramsPayload, S>

  type sysdiagramsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<sysdiagramsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SysdiagramsCountAggregateInputType | true
    }

  export interface sysdiagramsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['sysdiagrams'], meta: { name: 'sysdiagrams' } }
    /**
     * Find zero or one Sysdiagrams that matches the filter.
     * @param {sysdiagramsFindUniqueArgs} args - Arguments to find a Sysdiagrams
     * @example
     * // Get one Sysdiagrams
     * const sysdiagrams = await prisma.sysdiagrams.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends sysdiagramsFindUniqueArgs>(args: SelectSubset<T, sysdiagramsFindUniqueArgs<ExtArgs>>): Prisma__sysdiagramsClient<$Result.GetResult<Prisma.$sysdiagramsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Sysdiagrams that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {sysdiagramsFindUniqueOrThrowArgs} args - Arguments to find a Sysdiagrams
     * @example
     * // Get one Sysdiagrams
     * const sysdiagrams = await prisma.sysdiagrams.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends sysdiagramsFindUniqueOrThrowArgs>(args: SelectSubset<T, sysdiagramsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__sysdiagramsClient<$Result.GetResult<Prisma.$sysdiagramsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sysdiagrams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sysdiagramsFindFirstArgs} args - Arguments to find a Sysdiagrams
     * @example
     * // Get one Sysdiagrams
     * const sysdiagrams = await prisma.sysdiagrams.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends sysdiagramsFindFirstArgs>(args?: SelectSubset<T, sysdiagramsFindFirstArgs<ExtArgs>>): Prisma__sysdiagramsClient<$Result.GetResult<Prisma.$sysdiagramsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sysdiagrams that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sysdiagramsFindFirstOrThrowArgs} args - Arguments to find a Sysdiagrams
     * @example
     * // Get one Sysdiagrams
     * const sysdiagrams = await prisma.sysdiagrams.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends sysdiagramsFindFirstOrThrowArgs>(args?: SelectSubset<T, sysdiagramsFindFirstOrThrowArgs<ExtArgs>>): Prisma__sysdiagramsClient<$Result.GetResult<Prisma.$sysdiagramsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sysdiagrams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sysdiagramsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sysdiagrams
     * const sysdiagrams = await prisma.sysdiagrams.findMany()
     * 
     * // Get first 10 Sysdiagrams
     * const sysdiagrams = await prisma.sysdiagrams.findMany({ take: 10 })
     * 
     * // Only select the `name`
     * const sysdiagramsWithNameOnly = await prisma.sysdiagrams.findMany({ select: { name: true } })
     * 
     */
    findMany<T extends sysdiagramsFindManyArgs>(args?: SelectSubset<T, sysdiagramsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sysdiagramsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Sysdiagrams.
     * @param {sysdiagramsCreateArgs} args - Arguments to create a Sysdiagrams.
     * @example
     * // Create one Sysdiagrams
     * const Sysdiagrams = await prisma.sysdiagrams.create({
     *   data: {
     *     // ... data to create a Sysdiagrams
     *   }
     * })
     * 
     */
    create<T extends sysdiagramsCreateArgs>(args: SelectSubset<T, sysdiagramsCreateArgs<ExtArgs>>): Prisma__sysdiagramsClient<$Result.GetResult<Prisma.$sysdiagramsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sysdiagrams.
     * @param {sysdiagramsCreateManyArgs} args - Arguments to create many Sysdiagrams.
     * @example
     * // Create many Sysdiagrams
     * const sysdiagrams = await prisma.sysdiagrams.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends sysdiagramsCreateManyArgs>(args?: SelectSubset<T, sysdiagramsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Sysdiagrams.
     * @param {sysdiagramsDeleteArgs} args - Arguments to delete one Sysdiagrams.
     * @example
     * // Delete one Sysdiagrams
     * const Sysdiagrams = await prisma.sysdiagrams.delete({
     *   where: {
     *     // ... filter to delete one Sysdiagrams
     *   }
     * })
     * 
     */
    delete<T extends sysdiagramsDeleteArgs>(args: SelectSubset<T, sysdiagramsDeleteArgs<ExtArgs>>): Prisma__sysdiagramsClient<$Result.GetResult<Prisma.$sysdiagramsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Sysdiagrams.
     * @param {sysdiagramsUpdateArgs} args - Arguments to update one Sysdiagrams.
     * @example
     * // Update one Sysdiagrams
     * const sysdiagrams = await prisma.sysdiagrams.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends sysdiagramsUpdateArgs>(args: SelectSubset<T, sysdiagramsUpdateArgs<ExtArgs>>): Prisma__sysdiagramsClient<$Result.GetResult<Prisma.$sysdiagramsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sysdiagrams.
     * @param {sysdiagramsDeleteManyArgs} args - Arguments to filter Sysdiagrams to delete.
     * @example
     * // Delete a few Sysdiagrams
     * const { count } = await prisma.sysdiagrams.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends sysdiagramsDeleteManyArgs>(args?: SelectSubset<T, sysdiagramsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sysdiagrams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sysdiagramsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sysdiagrams
     * const sysdiagrams = await prisma.sysdiagrams.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends sysdiagramsUpdateManyArgs>(args: SelectSubset<T, sysdiagramsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sysdiagrams.
     * @param {sysdiagramsUpsertArgs} args - Arguments to update or create a Sysdiagrams.
     * @example
     * // Update or create a Sysdiagrams
     * const sysdiagrams = await prisma.sysdiagrams.upsert({
     *   create: {
     *     // ... data to create a Sysdiagrams
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sysdiagrams we want to update
     *   }
     * })
     */
    upsert<T extends sysdiagramsUpsertArgs>(args: SelectSubset<T, sysdiagramsUpsertArgs<ExtArgs>>): Prisma__sysdiagramsClient<$Result.GetResult<Prisma.$sysdiagramsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sysdiagrams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sysdiagramsCountArgs} args - Arguments to filter Sysdiagrams to count.
     * @example
     * // Count the number of Sysdiagrams
     * const count = await prisma.sysdiagrams.count({
     *   where: {
     *     // ... the filter for the Sysdiagrams we want to count
     *   }
     * })
    **/
    count<T extends sysdiagramsCountArgs>(
      args?: Subset<T, sysdiagramsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SysdiagramsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sysdiagrams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SysdiagramsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SysdiagramsAggregateArgs>(args: Subset<T, SysdiagramsAggregateArgs>): Prisma.PrismaPromise<GetSysdiagramsAggregateType<T>>

    /**
     * Group by Sysdiagrams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sysdiagramsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends sysdiagramsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: sysdiagramsGroupByArgs['orderBy'] }
        : { orderBy?: sysdiagramsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, sysdiagramsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSysdiagramsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the sysdiagrams model
   */
  readonly fields: sysdiagramsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for sysdiagrams.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__sysdiagramsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the sysdiagrams model
   */
  interface sysdiagramsFieldRefs {
    readonly name: FieldRef<"sysdiagrams", 'String'>
    readonly principal_id: FieldRef<"sysdiagrams", 'Int'>
    readonly diagram_id: FieldRef<"sysdiagrams", 'Int'>
    readonly version: FieldRef<"sysdiagrams", 'Int'>
    readonly definition: FieldRef<"sysdiagrams", 'Bytes'>
  }
    

  // Custom InputTypes
  /**
   * sysdiagrams findUnique
   */
  export type sysdiagramsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sysdiagrams
     */
    select?: sysdiagramsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sysdiagrams
     */
    omit?: sysdiagramsOmit<ExtArgs> | null
    /**
     * Filter, which sysdiagrams to fetch.
     */
    where: sysdiagramsWhereUniqueInput
  }

  /**
   * sysdiagrams findUniqueOrThrow
   */
  export type sysdiagramsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sysdiagrams
     */
    select?: sysdiagramsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sysdiagrams
     */
    omit?: sysdiagramsOmit<ExtArgs> | null
    /**
     * Filter, which sysdiagrams to fetch.
     */
    where: sysdiagramsWhereUniqueInput
  }

  /**
   * sysdiagrams findFirst
   */
  export type sysdiagramsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sysdiagrams
     */
    select?: sysdiagramsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sysdiagrams
     */
    omit?: sysdiagramsOmit<ExtArgs> | null
    /**
     * Filter, which sysdiagrams to fetch.
     */
    where?: sysdiagramsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sysdiagrams to fetch.
     */
    orderBy?: sysdiagramsOrderByWithRelationInput | sysdiagramsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sysdiagrams.
     */
    cursor?: sysdiagramsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sysdiagrams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sysdiagrams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sysdiagrams.
     */
    distinct?: SysdiagramsScalarFieldEnum | SysdiagramsScalarFieldEnum[]
  }

  /**
   * sysdiagrams findFirstOrThrow
   */
  export type sysdiagramsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sysdiagrams
     */
    select?: sysdiagramsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sysdiagrams
     */
    omit?: sysdiagramsOmit<ExtArgs> | null
    /**
     * Filter, which sysdiagrams to fetch.
     */
    where?: sysdiagramsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sysdiagrams to fetch.
     */
    orderBy?: sysdiagramsOrderByWithRelationInput | sysdiagramsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sysdiagrams.
     */
    cursor?: sysdiagramsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sysdiagrams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sysdiagrams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sysdiagrams.
     */
    distinct?: SysdiagramsScalarFieldEnum | SysdiagramsScalarFieldEnum[]
  }

  /**
   * sysdiagrams findMany
   */
  export type sysdiagramsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sysdiagrams
     */
    select?: sysdiagramsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sysdiagrams
     */
    omit?: sysdiagramsOmit<ExtArgs> | null
    /**
     * Filter, which sysdiagrams to fetch.
     */
    where?: sysdiagramsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sysdiagrams to fetch.
     */
    orderBy?: sysdiagramsOrderByWithRelationInput | sysdiagramsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sysdiagrams.
     */
    cursor?: sysdiagramsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sysdiagrams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sysdiagrams.
     */
    skip?: number
    distinct?: SysdiagramsScalarFieldEnum | SysdiagramsScalarFieldEnum[]
  }

  /**
   * sysdiagrams create
   */
  export type sysdiagramsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sysdiagrams
     */
    select?: sysdiagramsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sysdiagrams
     */
    omit?: sysdiagramsOmit<ExtArgs> | null
    /**
     * The data needed to create a sysdiagrams.
     */
    data: XOR<sysdiagramsCreateInput, sysdiagramsUncheckedCreateInput>
  }

  /**
   * sysdiagrams createMany
   */
  export type sysdiagramsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many sysdiagrams.
     */
    data: sysdiagramsCreateManyInput | sysdiagramsCreateManyInput[]
  }

  /**
   * sysdiagrams update
   */
  export type sysdiagramsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sysdiagrams
     */
    select?: sysdiagramsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sysdiagrams
     */
    omit?: sysdiagramsOmit<ExtArgs> | null
    /**
     * The data needed to update a sysdiagrams.
     */
    data: XOR<sysdiagramsUpdateInput, sysdiagramsUncheckedUpdateInput>
    /**
     * Choose, which sysdiagrams to update.
     */
    where: sysdiagramsWhereUniqueInput
  }

  /**
   * sysdiagrams updateMany
   */
  export type sysdiagramsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update sysdiagrams.
     */
    data: XOR<sysdiagramsUpdateManyMutationInput, sysdiagramsUncheckedUpdateManyInput>
    /**
     * Filter which sysdiagrams to update
     */
    where?: sysdiagramsWhereInput
    /**
     * Limit how many sysdiagrams to update.
     */
    limit?: number
  }

  /**
   * sysdiagrams upsert
   */
  export type sysdiagramsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sysdiagrams
     */
    select?: sysdiagramsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sysdiagrams
     */
    omit?: sysdiagramsOmit<ExtArgs> | null
    /**
     * The filter to search for the sysdiagrams to update in case it exists.
     */
    where: sysdiagramsWhereUniqueInput
    /**
     * In case the sysdiagrams found by the `where` argument doesn't exist, create a new sysdiagrams with this data.
     */
    create: XOR<sysdiagramsCreateInput, sysdiagramsUncheckedCreateInput>
    /**
     * In case the sysdiagrams was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sysdiagramsUpdateInput, sysdiagramsUncheckedUpdateInput>
  }

  /**
   * sysdiagrams delete
   */
  export type sysdiagramsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sysdiagrams
     */
    select?: sysdiagramsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sysdiagrams
     */
    omit?: sysdiagramsOmit<ExtArgs> | null
    /**
     * Filter which sysdiagrams to delete.
     */
    where: sysdiagramsWhereUniqueInput
  }

  /**
   * sysdiagrams deleteMany
   */
  export type sysdiagramsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sysdiagrams to delete
     */
    where?: sysdiagramsWhereInput
    /**
     * Limit how many sysdiagrams to delete.
     */
    limit?: number
  }

  /**
   * sysdiagrams without action
   */
  export type sysdiagramsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sysdiagrams
     */
    select?: sysdiagramsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sysdiagrams
     */
    omit?: sysdiagramsOmit<ExtArgs> | null
  }


  /**
   * Model TapToPayTransactionLog
   */

  export type AggregateTapToPayTransactionLog = {
    _count: TapToPayTransactionLogCountAggregateOutputType | null
    _avg: TapToPayTransactionLogAvgAggregateOutputType | null
    _sum: TapToPayTransactionLogSumAggregateOutputType | null
    _min: TapToPayTransactionLogMinAggregateOutputType | null
    _max: TapToPayTransactionLogMaxAggregateOutputType | null
  }

  export type TapToPayTransactionLogAvgAggregateOutputType = {
    Id: number | null
  }

  export type TapToPayTransactionLogSumAggregateOutputType = {
    Id: number | null
  }

  export type TapToPayTransactionLogMinAggregateOutputType = {
    Id: number | null
    DeviceId: string | null
    PhoneNumber: string | null
    TransactionDate: Date | null
  }

  export type TapToPayTransactionLogMaxAggregateOutputType = {
    Id: number | null
    DeviceId: string | null
    PhoneNumber: string | null
    TransactionDate: Date | null
  }

  export type TapToPayTransactionLogCountAggregateOutputType = {
    Id: number
    DeviceId: number
    PhoneNumber: number
    TransactionDate: number
    _all: number
  }


  export type TapToPayTransactionLogAvgAggregateInputType = {
    Id?: true
  }

  export type TapToPayTransactionLogSumAggregateInputType = {
    Id?: true
  }

  export type TapToPayTransactionLogMinAggregateInputType = {
    Id?: true
    DeviceId?: true
    PhoneNumber?: true
    TransactionDate?: true
  }

  export type TapToPayTransactionLogMaxAggregateInputType = {
    Id?: true
    DeviceId?: true
    PhoneNumber?: true
    TransactionDate?: true
  }

  export type TapToPayTransactionLogCountAggregateInputType = {
    Id?: true
    DeviceId?: true
    PhoneNumber?: true
    TransactionDate?: true
    _all?: true
  }

  export type TapToPayTransactionLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TapToPayTransactionLog to aggregate.
     */
    where?: TapToPayTransactionLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TapToPayTransactionLogs to fetch.
     */
    orderBy?: TapToPayTransactionLogOrderByWithRelationInput | TapToPayTransactionLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TapToPayTransactionLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TapToPayTransactionLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TapToPayTransactionLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TapToPayTransactionLogs
    **/
    _count?: true | TapToPayTransactionLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TapToPayTransactionLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TapToPayTransactionLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TapToPayTransactionLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TapToPayTransactionLogMaxAggregateInputType
  }

  export type GetTapToPayTransactionLogAggregateType<T extends TapToPayTransactionLogAggregateArgs> = {
        [P in keyof T & keyof AggregateTapToPayTransactionLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTapToPayTransactionLog[P]>
      : GetScalarType<T[P], AggregateTapToPayTransactionLog[P]>
  }




  export type TapToPayTransactionLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TapToPayTransactionLogWhereInput
    orderBy?: TapToPayTransactionLogOrderByWithAggregationInput | TapToPayTransactionLogOrderByWithAggregationInput[]
    by: TapToPayTransactionLogScalarFieldEnum[] | TapToPayTransactionLogScalarFieldEnum
    having?: TapToPayTransactionLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TapToPayTransactionLogCountAggregateInputType | true
    _avg?: TapToPayTransactionLogAvgAggregateInputType
    _sum?: TapToPayTransactionLogSumAggregateInputType
    _min?: TapToPayTransactionLogMinAggregateInputType
    _max?: TapToPayTransactionLogMaxAggregateInputType
  }

  export type TapToPayTransactionLogGroupByOutputType = {
    Id: number
    DeviceId: string | null
    PhoneNumber: string | null
    TransactionDate: Date
    _count: TapToPayTransactionLogCountAggregateOutputType | null
    _avg: TapToPayTransactionLogAvgAggregateOutputType | null
    _sum: TapToPayTransactionLogSumAggregateOutputType | null
    _min: TapToPayTransactionLogMinAggregateOutputType | null
    _max: TapToPayTransactionLogMaxAggregateOutputType | null
  }

  type GetTapToPayTransactionLogGroupByPayload<T extends TapToPayTransactionLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TapToPayTransactionLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TapToPayTransactionLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TapToPayTransactionLogGroupByOutputType[P]>
            : GetScalarType<T[P], TapToPayTransactionLogGroupByOutputType[P]>
        }
      >
    >


  export type TapToPayTransactionLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    DeviceId?: boolean
    PhoneNumber?: boolean
    TransactionDate?: boolean
  }, ExtArgs["result"]["tapToPayTransactionLog"]>



  export type TapToPayTransactionLogSelectScalar = {
    Id?: boolean
    DeviceId?: boolean
    PhoneNumber?: boolean
    TransactionDate?: boolean
  }

  export type TapToPayTransactionLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Id" | "DeviceId" | "PhoneNumber" | "TransactionDate", ExtArgs["result"]["tapToPayTransactionLog"]>

  export type $TapToPayTransactionLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TapToPayTransactionLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      Id: number
      DeviceId: string | null
      PhoneNumber: string | null
      TransactionDate: Date
    }, ExtArgs["result"]["tapToPayTransactionLog"]>
    composites: {}
  }

  type TapToPayTransactionLogGetPayload<S extends boolean | null | undefined | TapToPayTransactionLogDefaultArgs> = $Result.GetResult<Prisma.$TapToPayTransactionLogPayload, S>

  type TapToPayTransactionLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TapToPayTransactionLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TapToPayTransactionLogCountAggregateInputType | true
    }

  export interface TapToPayTransactionLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TapToPayTransactionLog'], meta: { name: 'TapToPayTransactionLog' } }
    /**
     * Find zero or one TapToPayTransactionLog that matches the filter.
     * @param {TapToPayTransactionLogFindUniqueArgs} args - Arguments to find a TapToPayTransactionLog
     * @example
     * // Get one TapToPayTransactionLog
     * const tapToPayTransactionLog = await prisma.tapToPayTransactionLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TapToPayTransactionLogFindUniqueArgs>(args: SelectSubset<T, TapToPayTransactionLogFindUniqueArgs<ExtArgs>>): Prisma__TapToPayTransactionLogClient<$Result.GetResult<Prisma.$TapToPayTransactionLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TapToPayTransactionLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TapToPayTransactionLogFindUniqueOrThrowArgs} args - Arguments to find a TapToPayTransactionLog
     * @example
     * // Get one TapToPayTransactionLog
     * const tapToPayTransactionLog = await prisma.tapToPayTransactionLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TapToPayTransactionLogFindUniqueOrThrowArgs>(args: SelectSubset<T, TapToPayTransactionLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TapToPayTransactionLogClient<$Result.GetResult<Prisma.$TapToPayTransactionLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TapToPayTransactionLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TapToPayTransactionLogFindFirstArgs} args - Arguments to find a TapToPayTransactionLog
     * @example
     * // Get one TapToPayTransactionLog
     * const tapToPayTransactionLog = await prisma.tapToPayTransactionLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TapToPayTransactionLogFindFirstArgs>(args?: SelectSubset<T, TapToPayTransactionLogFindFirstArgs<ExtArgs>>): Prisma__TapToPayTransactionLogClient<$Result.GetResult<Prisma.$TapToPayTransactionLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TapToPayTransactionLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TapToPayTransactionLogFindFirstOrThrowArgs} args - Arguments to find a TapToPayTransactionLog
     * @example
     * // Get one TapToPayTransactionLog
     * const tapToPayTransactionLog = await prisma.tapToPayTransactionLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TapToPayTransactionLogFindFirstOrThrowArgs>(args?: SelectSubset<T, TapToPayTransactionLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__TapToPayTransactionLogClient<$Result.GetResult<Prisma.$TapToPayTransactionLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TapToPayTransactionLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TapToPayTransactionLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TapToPayTransactionLogs
     * const tapToPayTransactionLogs = await prisma.tapToPayTransactionLog.findMany()
     * 
     * // Get first 10 TapToPayTransactionLogs
     * const tapToPayTransactionLogs = await prisma.tapToPayTransactionLog.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const tapToPayTransactionLogWithIdOnly = await prisma.tapToPayTransactionLog.findMany({ select: { Id: true } })
     * 
     */
    findMany<T extends TapToPayTransactionLogFindManyArgs>(args?: SelectSubset<T, TapToPayTransactionLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TapToPayTransactionLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TapToPayTransactionLog.
     * @param {TapToPayTransactionLogCreateArgs} args - Arguments to create a TapToPayTransactionLog.
     * @example
     * // Create one TapToPayTransactionLog
     * const TapToPayTransactionLog = await prisma.tapToPayTransactionLog.create({
     *   data: {
     *     // ... data to create a TapToPayTransactionLog
     *   }
     * })
     * 
     */
    create<T extends TapToPayTransactionLogCreateArgs>(args: SelectSubset<T, TapToPayTransactionLogCreateArgs<ExtArgs>>): Prisma__TapToPayTransactionLogClient<$Result.GetResult<Prisma.$TapToPayTransactionLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TapToPayTransactionLogs.
     * @param {TapToPayTransactionLogCreateManyArgs} args - Arguments to create many TapToPayTransactionLogs.
     * @example
     * // Create many TapToPayTransactionLogs
     * const tapToPayTransactionLog = await prisma.tapToPayTransactionLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TapToPayTransactionLogCreateManyArgs>(args?: SelectSubset<T, TapToPayTransactionLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TapToPayTransactionLog.
     * @param {TapToPayTransactionLogDeleteArgs} args - Arguments to delete one TapToPayTransactionLog.
     * @example
     * // Delete one TapToPayTransactionLog
     * const TapToPayTransactionLog = await prisma.tapToPayTransactionLog.delete({
     *   where: {
     *     // ... filter to delete one TapToPayTransactionLog
     *   }
     * })
     * 
     */
    delete<T extends TapToPayTransactionLogDeleteArgs>(args: SelectSubset<T, TapToPayTransactionLogDeleteArgs<ExtArgs>>): Prisma__TapToPayTransactionLogClient<$Result.GetResult<Prisma.$TapToPayTransactionLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TapToPayTransactionLog.
     * @param {TapToPayTransactionLogUpdateArgs} args - Arguments to update one TapToPayTransactionLog.
     * @example
     * // Update one TapToPayTransactionLog
     * const tapToPayTransactionLog = await prisma.tapToPayTransactionLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TapToPayTransactionLogUpdateArgs>(args: SelectSubset<T, TapToPayTransactionLogUpdateArgs<ExtArgs>>): Prisma__TapToPayTransactionLogClient<$Result.GetResult<Prisma.$TapToPayTransactionLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TapToPayTransactionLogs.
     * @param {TapToPayTransactionLogDeleteManyArgs} args - Arguments to filter TapToPayTransactionLogs to delete.
     * @example
     * // Delete a few TapToPayTransactionLogs
     * const { count } = await prisma.tapToPayTransactionLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TapToPayTransactionLogDeleteManyArgs>(args?: SelectSubset<T, TapToPayTransactionLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TapToPayTransactionLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TapToPayTransactionLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TapToPayTransactionLogs
     * const tapToPayTransactionLog = await prisma.tapToPayTransactionLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TapToPayTransactionLogUpdateManyArgs>(args: SelectSubset<T, TapToPayTransactionLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TapToPayTransactionLog.
     * @param {TapToPayTransactionLogUpsertArgs} args - Arguments to update or create a TapToPayTransactionLog.
     * @example
     * // Update or create a TapToPayTransactionLog
     * const tapToPayTransactionLog = await prisma.tapToPayTransactionLog.upsert({
     *   create: {
     *     // ... data to create a TapToPayTransactionLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TapToPayTransactionLog we want to update
     *   }
     * })
     */
    upsert<T extends TapToPayTransactionLogUpsertArgs>(args: SelectSubset<T, TapToPayTransactionLogUpsertArgs<ExtArgs>>): Prisma__TapToPayTransactionLogClient<$Result.GetResult<Prisma.$TapToPayTransactionLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TapToPayTransactionLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TapToPayTransactionLogCountArgs} args - Arguments to filter TapToPayTransactionLogs to count.
     * @example
     * // Count the number of TapToPayTransactionLogs
     * const count = await prisma.tapToPayTransactionLog.count({
     *   where: {
     *     // ... the filter for the TapToPayTransactionLogs we want to count
     *   }
     * })
    **/
    count<T extends TapToPayTransactionLogCountArgs>(
      args?: Subset<T, TapToPayTransactionLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TapToPayTransactionLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TapToPayTransactionLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TapToPayTransactionLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TapToPayTransactionLogAggregateArgs>(args: Subset<T, TapToPayTransactionLogAggregateArgs>): Prisma.PrismaPromise<GetTapToPayTransactionLogAggregateType<T>>

    /**
     * Group by TapToPayTransactionLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TapToPayTransactionLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TapToPayTransactionLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TapToPayTransactionLogGroupByArgs['orderBy'] }
        : { orderBy?: TapToPayTransactionLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TapToPayTransactionLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTapToPayTransactionLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TapToPayTransactionLog model
   */
  readonly fields: TapToPayTransactionLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TapToPayTransactionLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TapToPayTransactionLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TapToPayTransactionLog model
   */
  interface TapToPayTransactionLogFieldRefs {
    readonly Id: FieldRef<"TapToPayTransactionLog", 'Int'>
    readonly DeviceId: FieldRef<"TapToPayTransactionLog", 'String'>
    readonly PhoneNumber: FieldRef<"TapToPayTransactionLog", 'String'>
    readonly TransactionDate: FieldRef<"TapToPayTransactionLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TapToPayTransactionLog findUnique
   */
  export type TapToPayTransactionLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TapToPayTransactionLog
     */
    select?: TapToPayTransactionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TapToPayTransactionLog
     */
    omit?: TapToPayTransactionLogOmit<ExtArgs> | null
    /**
     * Filter, which TapToPayTransactionLog to fetch.
     */
    where: TapToPayTransactionLogWhereUniqueInput
  }

  /**
   * TapToPayTransactionLog findUniqueOrThrow
   */
  export type TapToPayTransactionLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TapToPayTransactionLog
     */
    select?: TapToPayTransactionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TapToPayTransactionLog
     */
    omit?: TapToPayTransactionLogOmit<ExtArgs> | null
    /**
     * Filter, which TapToPayTransactionLog to fetch.
     */
    where: TapToPayTransactionLogWhereUniqueInput
  }

  /**
   * TapToPayTransactionLog findFirst
   */
  export type TapToPayTransactionLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TapToPayTransactionLog
     */
    select?: TapToPayTransactionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TapToPayTransactionLog
     */
    omit?: TapToPayTransactionLogOmit<ExtArgs> | null
    /**
     * Filter, which TapToPayTransactionLog to fetch.
     */
    where?: TapToPayTransactionLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TapToPayTransactionLogs to fetch.
     */
    orderBy?: TapToPayTransactionLogOrderByWithRelationInput | TapToPayTransactionLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TapToPayTransactionLogs.
     */
    cursor?: TapToPayTransactionLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TapToPayTransactionLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TapToPayTransactionLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TapToPayTransactionLogs.
     */
    distinct?: TapToPayTransactionLogScalarFieldEnum | TapToPayTransactionLogScalarFieldEnum[]
  }

  /**
   * TapToPayTransactionLog findFirstOrThrow
   */
  export type TapToPayTransactionLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TapToPayTransactionLog
     */
    select?: TapToPayTransactionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TapToPayTransactionLog
     */
    omit?: TapToPayTransactionLogOmit<ExtArgs> | null
    /**
     * Filter, which TapToPayTransactionLog to fetch.
     */
    where?: TapToPayTransactionLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TapToPayTransactionLogs to fetch.
     */
    orderBy?: TapToPayTransactionLogOrderByWithRelationInput | TapToPayTransactionLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TapToPayTransactionLogs.
     */
    cursor?: TapToPayTransactionLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TapToPayTransactionLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TapToPayTransactionLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TapToPayTransactionLogs.
     */
    distinct?: TapToPayTransactionLogScalarFieldEnum | TapToPayTransactionLogScalarFieldEnum[]
  }

  /**
   * TapToPayTransactionLog findMany
   */
  export type TapToPayTransactionLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TapToPayTransactionLog
     */
    select?: TapToPayTransactionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TapToPayTransactionLog
     */
    omit?: TapToPayTransactionLogOmit<ExtArgs> | null
    /**
     * Filter, which TapToPayTransactionLogs to fetch.
     */
    where?: TapToPayTransactionLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TapToPayTransactionLogs to fetch.
     */
    orderBy?: TapToPayTransactionLogOrderByWithRelationInput | TapToPayTransactionLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TapToPayTransactionLogs.
     */
    cursor?: TapToPayTransactionLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TapToPayTransactionLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TapToPayTransactionLogs.
     */
    skip?: number
    distinct?: TapToPayTransactionLogScalarFieldEnum | TapToPayTransactionLogScalarFieldEnum[]
  }

  /**
   * TapToPayTransactionLog create
   */
  export type TapToPayTransactionLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TapToPayTransactionLog
     */
    select?: TapToPayTransactionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TapToPayTransactionLog
     */
    omit?: TapToPayTransactionLogOmit<ExtArgs> | null
    /**
     * The data needed to create a TapToPayTransactionLog.
     */
    data: XOR<TapToPayTransactionLogCreateInput, TapToPayTransactionLogUncheckedCreateInput>
  }

  /**
   * TapToPayTransactionLog createMany
   */
  export type TapToPayTransactionLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TapToPayTransactionLogs.
     */
    data: TapToPayTransactionLogCreateManyInput | TapToPayTransactionLogCreateManyInput[]
  }

  /**
   * TapToPayTransactionLog update
   */
  export type TapToPayTransactionLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TapToPayTransactionLog
     */
    select?: TapToPayTransactionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TapToPayTransactionLog
     */
    omit?: TapToPayTransactionLogOmit<ExtArgs> | null
    /**
     * The data needed to update a TapToPayTransactionLog.
     */
    data: XOR<TapToPayTransactionLogUpdateInput, TapToPayTransactionLogUncheckedUpdateInput>
    /**
     * Choose, which TapToPayTransactionLog to update.
     */
    where: TapToPayTransactionLogWhereUniqueInput
  }

  /**
   * TapToPayTransactionLog updateMany
   */
  export type TapToPayTransactionLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TapToPayTransactionLogs.
     */
    data: XOR<TapToPayTransactionLogUpdateManyMutationInput, TapToPayTransactionLogUncheckedUpdateManyInput>
    /**
     * Filter which TapToPayTransactionLogs to update
     */
    where?: TapToPayTransactionLogWhereInput
    /**
     * Limit how many TapToPayTransactionLogs to update.
     */
    limit?: number
  }

  /**
   * TapToPayTransactionLog upsert
   */
  export type TapToPayTransactionLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TapToPayTransactionLog
     */
    select?: TapToPayTransactionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TapToPayTransactionLog
     */
    omit?: TapToPayTransactionLogOmit<ExtArgs> | null
    /**
     * The filter to search for the TapToPayTransactionLog to update in case it exists.
     */
    where: TapToPayTransactionLogWhereUniqueInput
    /**
     * In case the TapToPayTransactionLog found by the `where` argument doesn't exist, create a new TapToPayTransactionLog with this data.
     */
    create: XOR<TapToPayTransactionLogCreateInput, TapToPayTransactionLogUncheckedCreateInput>
    /**
     * In case the TapToPayTransactionLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TapToPayTransactionLogUpdateInput, TapToPayTransactionLogUncheckedUpdateInput>
  }

  /**
   * TapToPayTransactionLog delete
   */
  export type TapToPayTransactionLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TapToPayTransactionLog
     */
    select?: TapToPayTransactionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TapToPayTransactionLog
     */
    omit?: TapToPayTransactionLogOmit<ExtArgs> | null
    /**
     * Filter which TapToPayTransactionLog to delete.
     */
    where: TapToPayTransactionLogWhereUniqueInput
  }

  /**
   * TapToPayTransactionLog deleteMany
   */
  export type TapToPayTransactionLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TapToPayTransactionLogs to delete
     */
    where?: TapToPayTransactionLogWhereInput
    /**
     * Limit how many TapToPayTransactionLogs to delete.
     */
    limit?: number
  }

  /**
   * TapToPayTransactionLog without action
   */
  export type TapToPayTransactionLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TapToPayTransactionLog
     */
    select?: TapToPayTransactionLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TapToPayTransactionLog
     */
    omit?: TapToPayTransactionLogOmit<ExtArgs> | null
  }


  /**
   * Model TokenStatuses
   */

  export type AggregateTokenStatuses = {
    _count: TokenStatusesCountAggregateOutputType | null
    _avg: TokenStatusesAvgAggregateOutputType | null
    _sum: TokenStatusesSumAggregateOutputType | null
    _min: TokenStatusesMinAggregateOutputType | null
    _max: TokenStatusesMaxAggregateOutputType | null
  }

  export type TokenStatusesAvgAggregateOutputType = {
    ID: number | null
  }

  export type TokenStatusesSumAggregateOutputType = {
    ID: number | null
  }

  export type TokenStatusesMinAggregateOutputType = {
    ID: number | null
    Name: string | null
    CardProviderName: string | null
    IsSuspended: boolean | null
    IsDeleted: boolean | null
    IsActive: boolean | null
    IsInactive: boolean | null
  }

  export type TokenStatusesMaxAggregateOutputType = {
    ID: number | null
    Name: string | null
    CardProviderName: string | null
    IsSuspended: boolean | null
    IsDeleted: boolean | null
    IsActive: boolean | null
    IsInactive: boolean | null
  }

  export type TokenStatusesCountAggregateOutputType = {
    ID: number
    Name: number
    CardProviderName: number
    IsSuspended: number
    IsDeleted: number
    IsActive: number
    IsInactive: number
    _all: number
  }


  export type TokenStatusesAvgAggregateInputType = {
    ID?: true
  }

  export type TokenStatusesSumAggregateInputType = {
    ID?: true
  }

  export type TokenStatusesMinAggregateInputType = {
    ID?: true
    Name?: true
    CardProviderName?: true
    IsSuspended?: true
    IsDeleted?: true
    IsActive?: true
    IsInactive?: true
  }

  export type TokenStatusesMaxAggregateInputType = {
    ID?: true
    Name?: true
    CardProviderName?: true
    IsSuspended?: true
    IsDeleted?: true
    IsActive?: true
    IsInactive?: true
  }

  export type TokenStatusesCountAggregateInputType = {
    ID?: true
    Name?: true
    CardProviderName?: true
    IsSuspended?: true
    IsDeleted?: true
    IsActive?: true
    IsInactive?: true
    _all?: true
  }

  export type TokenStatusesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TokenStatuses to aggregate.
     */
    where?: TokenStatusesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TokenStatuses to fetch.
     */
    orderBy?: TokenStatusesOrderByWithRelationInput | TokenStatusesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TokenStatusesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TokenStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TokenStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TokenStatuses
    **/
    _count?: true | TokenStatusesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TokenStatusesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TokenStatusesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TokenStatusesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TokenStatusesMaxAggregateInputType
  }

  export type GetTokenStatusesAggregateType<T extends TokenStatusesAggregateArgs> = {
        [P in keyof T & keyof AggregateTokenStatuses]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTokenStatuses[P]>
      : GetScalarType<T[P], AggregateTokenStatuses[P]>
  }




  export type TokenStatusesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TokenStatusesWhereInput
    orderBy?: TokenStatusesOrderByWithAggregationInput | TokenStatusesOrderByWithAggregationInput[]
    by: TokenStatusesScalarFieldEnum[] | TokenStatusesScalarFieldEnum
    having?: TokenStatusesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TokenStatusesCountAggregateInputType | true
    _avg?: TokenStatusesAvgAggregateInputType
    _sum?: TokenStatusesSumAggregateInputType
    _min?: TokenStatusesMinAggregateInputType
    _max?: TokenStatusesMaxAggregateInputType
  }

  export type TokenStatusesGroupByOutputType = {
    ID: number
    Name: string | null
    CardProviderName: string | null
    IsSuspended: boolean
    IsDeleted: boolean
    IsActive: boolean
    IsInactive: boolean
    _count: TokenStatusesCountAggregateOutputType | null
    _avg: TokenStatusesAvgAggregateOutputType | null
    _sum: TokenStatusesSumAggregateOutputType | null
    _min: TokenStatusesMinAggregateOutputType | null
    _max: TokenStatusesMaxAggregateOutputType | null
  }

  type GetTokenStatusesGroupByPayload<T extends TokenStatusesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TokenStatusesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TokenStatusesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TokenStatusesGroupByOutputType[P]>
            : GetScalarType<T[P], TokenStatusesGroupByOutputType[P]>
        }
      >
    >


  export type TokenStatusesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    Name?: boolean
    CardProviderName?: boolean
    IsSuspended?: boolean
    IsDeleted?: boolean
    IsActive?: boolean
    IsInactive?: boolean
    VisaProvisionedTokens?: boolean | TokenStatuses$VisaProvisionedTokensArgs<ExtArgs>
    _count?: boolean | TokenStatusesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tokenStatuses"]>



  export type TokenStatusesSelectScalar = {
    ID?: boolean
    Name?: boolean
    CardProviderName?: boolean
    IsSuspended?: boolean
    IsDeleted?: boolean
    IsActive?: boolean
    IsInactive?: boolean
  }

  export type TokenStatusesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"ID" | "Name" | "CardProviderName" | "IsSuspended" | "IsDeleted" | "IsActive" | "IsInactive", ExtArgs["result"]["tokenStatuses"]>
  export type TokenStatusesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    VisaProvisionedTokens?: boolean | TokenStatuses$VisaProvisionedTokensArgs<ExtArgs>
    _count?: boolean | TokenStatusesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $TokenStatusesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TokenStatuses"
    objects: {
      VisaProvisionedTokens: Prisma.$VisaProvisionedTokensPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      ID: number
      Name: string | null
      CardProviderName: string | null
      IsSuspended: boolean
      IsDeleted: boolean
      IsActive: boolean
      IsInactive: boolean
    }, ExtArgs["result"]["tokenStatuses"]>
    composites: {}
  }

  type TokenStatusesGetPayload<S extends boolean | null | undefined | TokenStatusesDefaultArgs> = $Result.GetResult<Prisma.$TokenStatusesPayload, S>

  type TokenStatusesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TokenStatusesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TokenStatusesCountAggregateInputType | true
    }

  export interface TokenStatusesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TokenStatuses'], meta: { name: 'TokenStatuses' } }
    /**
     * Find zero or one TokenStatuses that matches the filter.
     * @param {TokenStatusesFindUniqueArgs} args - Arguments to find a TokenStatuses
     * @example
     * // Get one TokenStatuses
     * const tokenStatuses = await prisma.tokenStatuses.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TokenStatusesFindUniqueArgs>(args: SelectSubset<T, TokenStatusesFindUniqueArgs<ExtArgs>>): Prisma__TokenStatusesClient<$Result.GetResult<Prisma.$TokenStatusesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TokenStatuses that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TokenStatusesFindUniqueOrThrowArgs} args - Arguments to find a TokenStatuses
     * @example
     * // Get one TokenStatuses
     * const tokenStatuses = await prisma.tokenStatuses.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TokenStatusesFindUniqueOrThrowArgs>(args: SelectSubset<T, TokenStatusesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TokenStatusesClient<$Result.GetResult<Prisma.$TokenStatusesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TokenStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenStatusesFindFirstArgs} args - Arguments to find a TokenStatuses
     * @example
     * // Get one TokenStatuses
     * const tokenStatuses = await prisma.tokenStatuses.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TokenStatusesFindFirstArgs>(args?: SelectSubset<T, TokenStatusesFindFirstArgs<ExtArgs>>): Prisma__TokenStatusesClient<$Result.GetResult<Prisma.$TokenStatusesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TokenStatuses that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenStatusesFindFirstOrThrowArgs} args - Arguments to find a TokenStatuses
     * @example
     * // Get one TokenStatuses
     * const tokenStatuses = await prisma.tokenStatuses.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TokenStatusesFindFirstOrThrowArgs>(args?: SelectSubset<T, TokenStatusesFindFirstOrThrowArgs<ExtArgs>>): Prisma__TokenStatusesClient<$Result.GetResult<Prisma.$TokenStatusesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TokenStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenStatusesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TokenStatuses
     * const tokenStatuses = await prisma.tokenStatuses.findMany()
     * 
     * // Get first 10 TokenStatuses
     * const tokenStatuses = await prisma.tokenStatuses.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const tokenStatusesWithIDOnly = await prisma.tokenStatuses.findMany({ select: { ID: true } })
     * 
     */
    findMany<T extends TokenStatusesFindManyArgs>(args?: SelectSubset<T, TokenStatusesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenStatusesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TokenStatuses.
     * @param {TokenStatusesCreateArgs} args - Arguments to create a TokenStatuses.
     * @example
     * // Create one TokenStatuses
     * const TokenStatuses = await prisma.tokenStatuses.create({
     *   data: {
     *     // ... data to create a TokenStatuses
     *   }
     * })
     * 
     */
    create<T extends TokenStatusesCreateArgs>(args: SelectSubset<T, TokenStatusesCreateArgs<ExtArgs>>): Prisma__TokenStatusesClient<$Result.GetResult<Prisma.$TokenStatusesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TokenStatuses.
     * @param {TokenStatusesCreateManyArgs} args - Arguments to create many TokenStatuses.
     * @example
     * // Create many TokenStatuses
     * const tokenStatuses = await prisma.tokenStatuses.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TokenStatusesCreateManyArgs>(args?: SelectSubset<T, TokenStatusesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TokenStatuses.
     * @param {TokenStatusesDeleteArgs} args - Arguments to delete one TokenStatuses.
     * @example
     * // Delete one TokenStatuses
     * const TokenStatuses = await prisma.tokenStatuses.delete({
     *   where: {
     *     // ... filter to delete one TokenStatuses
     *   }
     * })
     * 
     */
    delete<T extends TokenStatusesDeleteArgs>(args: SelectSubset<T, TokenStatusesDeleteArgs<ExtArgs>>): Prisma__TokenStatusesClient<$Result.GetResult<Prisma.$TokenStatusesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TokenStatuses.
     * @param {TokenStatusesUpdateArgs} args - Arguments to update one TokenStatuses.
     * @example
     * // Update one TokenStatuses
     * const tokenStatuses = await prisma.tokenStatuses.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TokenStatusesUpdateArgs>(args: SelectSubset<T, TokenStatusesUpdateArgs<ExtArgs>>): Prisma__TokenStatusesClient<$Result.GetResult<Prisma.$TokenStatusesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TokenStatuses.
     * @param {TokenStatusesDeleteManyArgs} args - Arguments to filter TokenStatuses to delete.
     * @example
     * // Delete a few TokenStatuses
     * const { count } = await prisma.tokenStatuses.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TokenStatusesDeleteManyArgs>(args?: SelectSubset<T, TokenStatusesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TokenStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenStatusesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TokenStatuses
     * const tokenStatuses = await prisma.tokenStatuses.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TokenStatusesUpdateManyArgs>(args: SelectSubset<T, TokenStatusesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TokenStatuses.
     * @param {TokenStatusesUpsertArgs} args - Arguments to update or create a TokenStatuses.
     * @example
     * // Update or create a TokenStatuses
     * const tokenStatuses = await prisma.tokenStatuses.upsert({
     *   create: {
     *     // ... data to create a TokenStatuses
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TokenStatuses we want to update
     *   }
     * })
     */
    upsert<T extends TokenStatusesUpsertArgs>(args: SelectSubset<T, TokenStatusesUpsertArgs<ExtArgs>>): Prisma__TokenStatusesClient<$Result.GetResult<Prisma.$TokenStatusesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TokenStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenStatusesCountArgs} args - Arguments to filter TokenStatuses to count.
     * @example
     * // Count the number of TokenStatuses
     * const count = await prisma.tokenStatuses.count({
     *   where: {
     *     // ... the filter for the TokenStatuses we want to count
     *   }
     * })
    **/
    count<T extends TokenStatusesCountArgs>(
      args?: Subset<T, TokenStatusesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TokenStatusesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TokenStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenStatusesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TokenStatusesAggregateArgs>(args: Subset<T, TokenStatusesAggregateArgs>): Prisma.PrismaPromise<GetTokenStatusesAggregateType<T>>

    /**
     * Group by TokenStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenStatusesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TokenStatusesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TokenStatusesGroupByArgs['orderBy'] }
        : { orderBy?: TokenStatusesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TokenStatusesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTokenStatusesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TokenStatuses model
   */
  readonly fields: TokenStatusesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TokenStatuses.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TokenStatusesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    VisaProvisionedTokens<T extends TokenStatuses$VisaProvisionedTokensArgs<ExtArgs> = {}>(args?: Subset<T, TokenStatuses$VisaProvisionedTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisaProvisionedTokensPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TokenStatuses model
   */
  interface TokenStatusesFieldRefs {
    readonly ID: FieldRef<"TokenStatuses", 'Int'>
    readonly Name: FieldRef<"TokenStatuses", 'String'>
    readonly CardProviderName: FieldRef<"TokenStatuses", 'String'>
    readonly IsSuspended: FieldRef<"TokenStatuses", 'Boolean'>
    readonly IsDeleted: FieldRef<"TokenStatuses", 'Boolean'>
    readonly IsActive: FieldRef<"TokenStatuses", 'Boolean'>
    readonly IsInactive: FieldRef<"TokenStatuses", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * TokenStatuses findUnique
   */
  export type TokenStatusesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenStatuses
     */
    select?: TokenStatusesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TokenStatuses
     */
    omit?: TokenStatusesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenStatusesInclude<ExtArgs> | null
    /**
     * Filter, which TokenStatuses to fetch.
     */
    where: TokenStatusesWhereUniqueInput
  }

  /**
   * TokenStatuses findUniqueOrThrow
   */
  export type TokenStatusesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenStatuses
     */
    select?: TokenStatusesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TokenStatuses
     */
    omit?: TokenStatusesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenStatusesInclude<ExtArgs> | null
    /**
     * Filter, which TokenStatuses to fetch.
     */
    where: TokenStatusesWhereUniqueInput
  }

  /**
   * TokenStatuses findFirst
   */
  export type TokenStatusesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenStatuses
     */
    select?: TokenStatusesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TokenStatuses
     */
    omit?: TokenStatusesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenStatusesInclude<ExtArgs> | null
    /**
     * Filter, which TokenStatuses to fetch.
     */
    where?: TokenStatusesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TokenStatuses to fetch.
     */
    orderBy?: TokenStatusesOrderByWithRelationInput | TokenStatusesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TokenStatuses.
     */
    cursor?: TokenStatusesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TokenStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TokenStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TokenStatuses.
     */
    distinct?: TokenStatusesScalarFieldEnum | TokenStatusesScalarFieldEnum[]
  }

  /**
   * TokenStatuses findFirstOrThrow
   */
  export type TokenStatusesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenStatuses
     */
    select?: TokenStatusesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TokenStatuses
     */
    omit?: TokenStatusesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenStatusesInclude<ExtArgs> | null
    /**
     * Filter, which TokenStatuses to fetch.
     */
    where?: TokenStatusesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TokenStatuses to fetch.
     */
    orderBy?: TokenStatusesOrderByWithRelationInput | TokenStatusesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TokenStatuses.
     */
    cursor?: TokenStatusesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TokenStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TokenStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TokenStatuses.
     */
    distinct?: TokenStatusesScalarFieldEnum | TokenStatusesScalarFieldEnum[]
  }

  /**
   * TokenStatuses findMany
   */
  export type TokenStatusesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenStatuses
     */
    select?: TokenStatusesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TokenStatuses
     */
    omit?: TokenStatusesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenStatusesInclude<ExtArgs> | null
    /**
     * Filter, which TokenStatuses to fetch.
     */
    where?: TokenStatusesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TokenStatuses to fetch.
     */
    orderBy?: TokenStatusesOrderByWithRelationInput | TokenStatusesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TokenStatuses.
     */
    cursor?: TokenStatusesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TokenStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TokenStatuses.
     */
    skip?: number
    distinct?: TokenStatusesScalarFieldEnum | TokenStatusesScalarFieldEnum[]
  }

  /**
   * TokenStatuses create
   */
  export type TokenStatusesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenStatuses
     */
    select?: TokenStatusesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TokenStatuses
     */
    omit?: TokenStatusesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenStatusesInclude<ExtArgs> | null
    /**
     * The data needed to create a TokenStatuses.
     */
    data: XOR<TokenStatusesCreateInput, TokenStatusesUncheckedCreateInput>
  }

  /**
   * TokenStatuses createMany
   */
  export type TokenStatusesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TokenStatuses.
     */
    data: TokenStatusesCreateManyInput | TokenStatusesCreateManyInput[]
  }

  /**
   * TokenStatuses update
   */
  export type TokenStatusesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenStatuses
     */
    select?: TokenStatusesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TokenStatuses
     */
    omit?: TokenStatusesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenStatusesInclude<ExtArgs> | null
    /**
     * The data needed to update a TokenStatuses.
     */
    data: XOR<TokenStatusesUpdateInput, TokenStatusesUncheckedUpdateInput>
    /**
     * Choose, which TokenStatuses to update.
     */
    where: TokenStatusesWhereUniqueInput
  }

  /**
   * TokenStatuses updateMany
   */
  export type TokenStatusesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TokenStatuses.
     */
    data: XOR<TokenStatusesUpdateManyMutationInput, TokenStatusesUncheckedUpdateManyInput>
    /**
     * Filter which TokenStatuses to update
     */
    where?: TokenStatusesWhereInput
    /**
     * Limit how many TokenStatuses to update.
     */
    limit?: number
  }

  /**
   * TokenStatuses upsert
   */
  export type TokenStatusesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenStatuses
     */
    select?: TokenStatusesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TokenStatuses
     */
    omit?: TokenStatusesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenStatusesInclude<ExtArgs> | null
    /**
     * The filter to search for the TokenStatuses to update in case it exists.
     */
    where: TokenStatusesWhereUniqueInput
    /**
     * In case the TokenStatuses found by the `where` argument doesn't exist, create a new TokenStatuses with this data.
     */
    create: XOR<TokenStatusesCreateInput, TokenStatusesUncheckedCreateInput>
    /**
     * In case the TokenStatuses was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TokenStatusesUpdateInput, TokenStatusesUncheckedUpdateInput>
  }

  /**
   * TokenStatuses delete
   */
  export type TokenStatusesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenStatuses
     */
    select?: TokenStatusesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TokenStatuses
     */
    omit?: TokenStatusesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenStatusesInclude<ExtArgs> | null
    /**
     * Filter which TokenStatuses to delete.
     */
    where: TokenStatusesWhereUniqueInput
  }

  /**
   * TokenStatuses deleteMany
   */
  export type TokenStatusesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TokenStatuses to delete
     */
    where?: TokenStatusesWhereInput
    /**
     * Limit how many TokenStatuses to delete.
     */
    limit?: number
  }

  /**
   * TokenStatuses.VisaProvisionedTokens
   */
  export type TokenStatuses$VisaProvisionedTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisaProvisionedTokens
     */
    select?: VisaProvisionedTokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisaProvisionedTokens
     */
    omit?: VisaProvisionedTokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisaProvisionedTokensInclude<ExtArgs> | null
    where?: VisaProvisionedTokensWhereInput
    orderBy?: VisaProvisionedTokensOrderByWithRelationInput | VisaProvisionedTokensOrderByWithRelationInput[]
    cursor?: VisaProvisionedTokensWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VisaProvisionedTokensScalarFieldEnum | VisaProvisionedTokensScalarFieldEnum[]
  }

  /**
   * TokenStatuses without action
   */
  export type TokenStatusesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenStatuses
     */
    select?: TokenStatusesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TokenStatuses
     */
    omit?: TokenStatusesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenStatusesInclude<ExtArgs> | null
  }


  /**
   * Model VisaProvisionedTokens
   */

  export type AggregateVisaProvisionedTokens = {
    _count: VisaProvisionedTokensCountAggregateOutputType | null
    _avg: VisaProvisionedTokensAvgAggregateOutputType | null
    _sum: VisaProvisionedTokensSumAggregateOutputType | null
    _min: VisaProvisionedTokensMinAggregateOutputType | null
    _max: VisaProvisionedTokensMaxAggregateOutputType | null
  }

  export type VisaProvisionedTokensAvgAggregateOutputType = {
    StatusId: number | null
  }

  export type VisaProvisionedTokensSumAggregateOutputType = {
    StatusId: number | null
  }

  export type VisaProvisionedTokensMinAggregateOutputType = {
    ProvisionedTokenId: string | null
    PhoneNumber: string | null
    DeviceId: string | null
    StatusId: number | null
    PanEnrollmentId: string | null
  }

  export type VisaProvisionedTokensMaxAggregateOutputType = {
    ProvisionedTokenId: string | null
    PhoneNumber: string | null
    DeviceId: string | null
    StatusId: number | null
    PanEnrollmentId: string | null
  }

  export type VisaProvisionedTokensCountAggregateOutputType = {
    ProvisionedTokenId: number
    PhoneNumber: number
    DeviceId: number
    StatusId: number
    PanEnrollmentId: number
    _all: number
  }


  export type VisaProvisionedTokensAvgAggregateInputType = {
    StatusId?: true
  }

  export type VisaProvisionedTokensSumAggregateInputType = {
    StatusId?: true
  }

  export type VisaProvisionedTokensMinAggregateInputType = {
    ProvisionedTokenId?: true
    PhoneNumber?: true
    DeviceId?: true
    StatusId?: true
    PanEnrollmentId?: true
  }

  export type VisaProvisionedTokensMaxAggregateInputType = {
    ProvisionedTokenId?: true
    PhoneNumber?: true
    DeviceId?: true
    StatusId?: true
    PanEnrollmentId?: true
  }

  export type VisaProvisionedTokensCountAggregateInputType = {
    ProvisionedTokenId?: true
    PhoneNumber?: true
    DeviceId?: true
    StatusId?: true
    PanEnrollmentId?: true
    _all?: true
  }

  export type VisaProvisionedTokensAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VisaProvisionedTokens to aggregate.
     */
    where?: VisaProvisionedTokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisaProvisionedTokens to fetch.
     */
    orderBy?: VisaProvisionedTokensOrderByWithRelationInput | VisaProvisionedTokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VisaProvisionedTokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisaProvisionedTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisaProvisionedTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VisaProvisionedTokens
    **/
    _count?: true | VisaProvisionedTokensCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VisaProvisionedTokensAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VisaProvisionedTokensSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VisaProvisionedTokensMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VisaProvisionedTokensMaxAggregateInputType
  }

  export type GetVisaProvisionedTokensAggregateType<T extends VisaProvisionedTokensAggregateArgs> = {
        [P in keyof T & keyof AggregateVisaProvisionedTokens]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVisaProvisionedTokens[P]>
      : GetScalarType<T[P], AggregateVisaProvisionedTokens[P]>
  }




  export type VisaProvisionedTokensGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisaProvisionedTokensWhereInput
    orderBy?: VisaProvisionedTokensOrderByWithAggregationInput | VisaProvisionedTokensOrderByWithAggregationInput[]
    by: VisaProvisionedTokensScalarFieldEnum[] | VisaProvisionedTokensScalarFieldEnum
    having?: VisaProvisionedTokensScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VisaProvisionedTokensCountAggregateInputType | true
    _avg?: VisaProvisionedTokensAvgAggregateInputType
    _sum?: VisaProvisionedTokensSumAggregateInputType
    _min?: VisaProvisionedTokensMinAggregateInputType
    _max?: VisaProvisionedTokensMaxAggregateInputType
  }

  export type VisaProvisionedTokensGroupByOutputType = {
    ProvisionedTokenId: string
    PhoneNumber: string
    DeviceId: string | null
    StatusId: number | null
    PanEnrollmentId: string | null
    _count: VisaProvisionedTokensCountAggregateOutputType | null
    _avg: VisaProvisionedTokensAvgAggregateOutputType | null
    _sum: VisaProvisionedTokensSumAggregateOutputType | null
    _min: VisaProvisionedTokensMinAggregateOutputType | null
    _max: VisaProvisionedTokensMaxAggregateOutputType | null
  }

  type GetVisaProvisionedTokensGroupByPayload<T extends VisaProvisionedTokensGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VisaProvisionedTokensGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VisaProvisionedTokensGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VisaProvisionedTokensGroupByOutputType[P]>
            : GetScalarType<T[P], VisaProvisionedTokensGroupByOutputType[P]>
        }
      >
    >


  export type VisaProvisionedTokensSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ProvisionedTokenId?: boolean
    PhoneNumber?: boolean
    DeviceId?: boolean
    StatusId?: boolean
    PanEnrollmentId?: boolean
    TokenStatuses?: boolean | VisaProvisionedTokens$TokenStatusesArgs<ExtArgs>
  }, ExtArgs["result"]["visaProvisionedTokens"]>



  export type VisaProvisionedTokensSelectScalar = {
    ProvisionedTokenId?: boolean
    PhoneNumber?: boolean
    DeviceId?: boolean
    StatusId?: boolean
    PanEnrollmentId?: boolean
  }

  export type VisaProvisionedTokensOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"ProvisionedTokenId" | "PhoneNumber" | "DeviceId" | "StatusId" | "PanEnrollmentId", ExtArgs["result"]["visaProvisionedTokens"]>
  export type VisaProvisionedTokensInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    TokenStatuses?: boolean | VisaProvisionedTokens$TokenStatusesArgs<ExtArgs>
  }

  export type $VisaProvisionedTokensPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VisaProvisionedTokens"
    objects: {
      TokenStatuses: Prisma.$TokenStatusesPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      ProvisionedTokenId: string
      PhoneNumber: string
      DeviceId: string | null
      StatusId: number | null
      PanEnrollmentId: string | null
    }, ExtArgs["result"]["visaProvisionedTokens"]>
    composites: {}
  }

  type VisaProvisionedTokensGetPayload<S extends boolean | null | undefined | VisaProvisionedTokensDefaultArgs> = $Result.GetResult<Prisma.$VisaProvisionedTokensPayload, S>

  type VisaProvisionedTokensCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VisaProvisionedTokensFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VisaProvisionedTokensCountAggregateInputType | true
    }

  export interface VisaProvisionedTokensDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VisaProvisionedTokens'], meta: { name: 'VisaProvisionedTokens' } }
    /**
     * Find zero or one VisaProvisionedTokens that matches the filter.
     * @param {VisaProvisionedTokensFindUniqueArgs} args - Arguments to find a VisaProvisionedTokens
     * @example
     * // Get one VisaProvisionedTokens
     * const visaProvisionedTokens = await prisma.visaProvisionedTokens.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VisaProvisionedTokensFindUniqueArgs>(args: SelectSubset<T, VisaProvisionedTokensFindUniqueArgs<ExtArgs>>): Prisma__VisaProvisionedTokensClient<$Result.GetResult<Prisma.$VisaProvisionedTokensPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VisaProvisionedTokens that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VisaProvisionedTokensFindUniqueOrThrowArgs} args - Arguments to find a VisaProvisionedTokens
     * @example
     * // Get one VisaProvisionedTokens
     * const visaProvisionedTokens = await prisma.visaProvisionedTokens.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VisaProvisionedTokensFindUniqueOrThrowArgs>(args: SelectSubset<T, VisaProvisionedTokensFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VisaProvisionedTokensClient<$Result.GetResult<Prisma.$VisaProvisionedTokensPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VisaProvisionedTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisaProvisionedTokensFindFirstArgs} args - Arguments to find a VisaProvisionedTokens
     * @example
     * // Get one VisaProvisionedTokens
     * const visaProvisionedTokens = await prisma.visaProvisionedTokens.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VisaProvisionedTokensFindFirstArgs>(args?: SelectSubset<T, VisaProvisionedTokensFindFirstArgs<ExtArgs>>): Prisma__VisaProvisionedTokensClient<$Result.GetResult<Prisma.$VisaProvisionedTokensPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VisaProvisionedTokens that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisaProvisionedTokensFindFirstOrThrowArgs} args - Arguments to find a VisaProvisionedTokens
     * @example
     * // Get one VisaProvisionedTokens
     * const visaProvisionedTokens = await prisma.visaProvisionedTokens.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VisaProvisionedTokensFindFirstOrThrowArgs>(args?: SelectSubset<T, VisaProvisionedTokensFindFirstOrThrowArgs<ExtArgs>>): Prisma__VisaProvisionedTokensClient<$Result.GetResult<Prisma.$VisaProvisionedTokensPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VisaProvisionedTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisaProvisionedTokensFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VisaProvisionedTokens
     * const visaProvisionedTokens = await prisma.visaProvisionedTokens.findMany()
     * 
     * // Get first 10 VisaProvisionedTokens
     * const visaProvisionedTokens = await prisma.visaProvisionedTokens.findMany({ take: 10 })
     * 
     * // Only select the `ProvisionedTokenId`
     * const visaProvisionedTokensWithProvisionedTokenIdOnly = await prisma.visaProvisionedTokens.findMany({ select: { ProvisionedTokenId: true } })
     * 
     */
    findMany<T extends VisaProvisionedTokensFindManyArgs>(args?: SelectSubset<T, VisaProvisionedTokensFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisaProvisionedTokensPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VisaProvisionedTokens.
     * @param {VisaProvisionedTokensCreateArgs} args - Arguments to create a VisaProvisionedTokens.
     * @example
     * // Create one VisaProvisionedTokens
     * const VisaProvisionedTokens = await prisma.visaProvisionedTokens.create({
     *   data: {
     *     // ... data to create a VisaProvisionedTokens
     *   }
     * })
     * 
     */
    create<T extends VisaProvisionedTokensCreateArgs>(args: SelectSubset<T, VisaProvisionedTokensCreateArgs<ExtArgs>>): Prisma__VisaProvisionedTokensClient<$Result.GetResult<Prisma.$VisaProvisionedTokensPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VisaProvisionedTokens.
     * @param {VisaProvisionedTokensCreateManyArgs} args - Arguments to create many VisaProvisionedTokens.
     * @example
     * // Create many VisaProvisionedTokens
     * const visaProvisionedTokens = await prisma.visaProvisionedTokens.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VisaProvisionedTokensCreateManyArgs>(args?: SelectSubset<T, VisaProvisionedTokensCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a VisaProvisionedTokens.
     * @param {VisaProvisionedTokensDeleteArgs} args - Arguments to delete one VisaProvisionedTokens.
     * @example
     * // Delete one VisaProvisionedTokens
     * const VisaProvisionedTokens = await prisma.visaProvisionedTokens.delete({
     *   where: {
     *     // ... filter to delete one VisaProvisionedTokens
     *   }
     * })
     * 
     */
    delete<T extends VisaProvisionedTokensDeleteArgs>(args: SelectSubset<T, VisaProvisionedTokensDeleteArgs<ExtArgs>>): Prisma__VisaProvisionedTokensClient<$Result.GetResult<Prisma.$VisaProvisionedTokensPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VisaProvisionedTokens.
     * @param {VisaProvisionedTokensUpdateArgs} args - Arguments to update one VisaProvisionedTokens.
     * @example
     * // Update one VisaProvisionedTokens
     * const visaProvisionedTokens = await prisma.visaProvisionedTokens.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VisaProvisionedTokensUpdateArgs>(args: SelectSubset<T, VisaProvisionedTokensUpdateArgs<ExtArgs>>): Prisma__VisaProvisionedTokensClient<$Result.GetResult<Prisma.$VisaProvisionedTokensPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VisaProvisionedTokens.
     * @param {VisaProvisionedTokensDeleteManyArgs} args - Arguments to filter VisaProvisionedTokens to delete.
     * @example
     * // Delete a few VisaProvisionedTokens
     * const { count } = await prisma.visaProvisionedTokens.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VisaProvisionedTokensDeleteManyArgs>(args?: SelectSubset<T, VisaProvisionedTokensDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VisaProvisionedTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisaProvisionedTokensUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VisaProvisionedTokens
     * const visaProvisionedTokens = await prisma.visaProvisionedTokens.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VisaProvisionedTokensUpdateManyArgs>(args: SelectSubset<T, VisaProvisionedTokensUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VisaProvisionedTokens.
     * @param {VisaProvisionedTokensUpsertArgs} args - Arguments to update or create a VisaProvisionedTokens.
     * @example
     * // Update or create a VisaProvisionedTokens
     * const visaProvisionedTokens = await prisma.visaProvisionedTokens.upsert({
     *   create: {
     *     // ... data to create a VisaProvisionedTokens
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VisaProvisionedTokens we want to update
     *   }
     * })
     */
    upsert<T extends VisaProvisionedTokensUpsertArgs>(args: SelectSubset<T, VisaProvisionedTokensUpsertArgs<ExtArgs>>): Prisma__VisaProvisionedTokensClient<$Result.GetResult<Prisma.$VisaProvisionedTokensPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VisaProvisionedTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisaProvisionedTokensCountArgs} args - Arguments to filter VisaProvisionedTokens to count.
     * @example
     * // Count the number of VisaProvisionedTokens
     * const count = await prisma.visaProvisionedTokens.count({
     *   where: {
     *     // ... the filter for the VisaProvisionedTokens we want to count
     *   }
     * })
    **/
    count<T extends VisaProvisionedTokensCountArgs>(
      args?: Subset<T, VisaProvisionedTokensCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VisaProvisionedTokensCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VisaProvisionedTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisaProvisionedTokensAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VisaProvisionedTokensAggregateArgs>(args: Subset<T, VisaProvisionedTokensAggregateArgs>): Prisma.PrismaPromise<GetVisaProvisionedTokensAggregateType<T>>

    /**
     * Group by VisaProvisionedTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisaProvisionedTokensGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VisaProvisionedTokensGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VisaProvisionedTokensGroupByArgs['orderBy'] }
        : { orderBy?: VisaProvisionedTokensGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VisaProvisionedTokensGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVisaProvisionedTokensGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VisaProvisionedTokens model
   */
  readonly fields: VisaProvisionedTokensFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VisaProvisionedTokens.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VisaProvisionedTokensClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    TokenStatuses<T extends VisaProvisionedTokens$TokenStatusesArgs<ExtArgs> = {}>(args?: Subset<T, VisaProvisionedTokens$TokenStatusesArgs<ExtArgs>>): Prisma__TokenStatusesClient<$Result.GetResult<Prisma.$TokenStatusesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VisaProvisionedTokens model
   */
  interface VisaProvisionedTokensFieldRefs {
    readonly ProvisionedTokenId: FieldRef<"VisaProvisionedTokens", 'String'>
    readonly PhoneNumber: FieldRef<"VisaProvisionedTokens", 'String'>
    readonly DeviceId: FieldRef<"VisaProvisionedTokens", 'String'>
    readonly StatusId: FieldRef<"VisaProvisionedTokens", 'Int'>
    readonly PanEnrollmentId: FieldRef<"VisaProvisionedTokens", 'String'>
  }
    

  // Custom InputTypes
  /**
   * VisaProvisionedTokens findUnique
   */
  export type VisaProvisionedTokensFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisaProvisionedTokens
     */
    select?: VisaProvisionedTokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisaProvisionedTokens
     */
    omit?: VisaProvisionedTokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisaProvisionedTokensInclude<ExtArgs> | null
    /**
     * Filter, which VisaProvisionedTokens to fetch.
     */
    where: VisaProvisionedTokensWhereUniqueInput
  }

  /**
   * VisaProvisionedTokens findUniqueOrThrow
   */
  export type VisaProvisionedTokensFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisaProvisionedTokens
     */
    select?: VisaProvisionedTokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisaProvisionedTokens
     */
    omit?: VisaProvisionedTokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisaProvisionedTokensInclude<ExtArgs> | null
    /**
     * Filter, which VisaProvisionedTokens to fetch.
     */
    where: VisaProvisionedTokensWhereUniqueInput
  }

  /**
   * VisaProvisionedTokens findFirst
   */
  export type VisaProvisionedTokensFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisaProvisionedTokens
     */
    select?: VisaProvisionedTokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisaProvisionedTokens
     */
    omit?: VisaProvisionedTokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisaProvisionedTokensInclude<ExtArgs> | null
    /**
     * Filter, which VisaProvisionedTokens to fetch.
     */
    where?: VisaProvisionedTokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisaProvisionedTokens to fetch.
     */
    orderBy?: VisaProvisionedTokensOrderByWithRelationInput | VisaProvisionedTokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VisaProvisionedTokens.
     */
    cursor?: VisaProvisionedTokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisaProvisionedTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisaProvisionedTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VisaProvisionedTokens.
     */
    distinct?: VisaProvisionedTokensScalarFieldEnum | VisaProvisionedTokensScalarFieldEnum[]
  }

  /**
   * VisaProvisionedTokens findFirstOrThrow
   */
  export type VisaProvisionedTokensFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisaProvisionedTokens
     */
    select?: VisaProvisionedTokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisaProvisionedTokens
     */
    omit?: VisaProvisionedTokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisaProvisionedTokensInclude<ExtArgs> | null
    /**
     * Filter, which VisaProvisionedTokens to fetch.
     */
    where?: VisaProvisionedTokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisaProvisionedTokens to fetch.
     */
    orderBy?: VisaProvisionedTokensOrderByWithRelationInput | VisaProvisionedTokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VisaProvisionedTokens.
     */
    cursor?: VisaProvisionedTokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisaProvisionedTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisaProvisionedTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VisaProvisionedTokens.
     */
    distinct?: VisaProvisionedTokensScalarFieldEnum | VisaProvisionedTokensScalarFieldEnum[]
  }

  /**
   * VisaProvisionedTokens findMany
   */
  export type VisaProvisionedTokensFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisaProvisionedTokens
     */
    select?: VisaProvisionedTokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisaProvisionedTokens
     */
    omit?: VisaProvisionedTokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisaProvisionedTokensInclude<ExtArgs> | null
    /**
     * Filter, which VisaProvisionedTokens to fetch.
     */
    where?: VisaProvisionedTokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisaProvisionedTokens to fetch.
     */
    orderBy?: VisaProvisionedTokensOrderByWithRelationInput | VisaProvisionedTokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VisaProvisionedTokens.
     */
    cursor?: VisaProvisionedTokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisaProvisionedTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisaProvisionedTokens.
     */
    skip?: number
    distinct?: VisaProvisionedTokensScalarFieldEnum | VisaProvisionedTokensScalarFieldEnum[]
  }

  /**
   * VisaProvisionedTokens create
   */
  export type VisaProvisionedTokensCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisaProvisionedTokens
     */
    select?: VisaProvisionedTokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisaProvisionedTokens
     */
    omit?: VisaProvisionedTokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisaProvisionedTokensInclude<ExtArgs> | null
    /**
     * The data needed to create a VisaProvisionedTokens.
     */
    data: XOR<VisaProvisionedTokensCreateInput, VisaProvisionedTokensUncheckedCreateInput>
  }

  /**
   * VisaProvisionedTokens createMany
   */
  export type VisaProvisionedTokensCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VisaProvisionedTokens.
     */
    data: VisaProvisionedTokensCreateManyInput | VisaProvisionedTokensCreateManyInput[]
  }

  /**
   * VisaProvisionedTokens update
   */
  export type VisaProvisionedTokensUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisaProvisionedTokens
     */
    select?: VisaProvisionedTokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisaProvisionedTokens
     */
    omit?: VisaProvisionedTokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisaProvisionedTokensInclude<ExtArgs> | null
    /**
     * The data needed to update a VisaProvisionedTokens.
     */
    data: XOR<VisaProvisionedTokensUpdateInput, VisaProvisionedTokensUncheckedUpdateInput>
    /**
     * Choose, which VisaProvisionedTokens to update.
     */
    where: VisaProvisionedTokensWhereUniqueInput
  }

  /**
   * VisaProvisionedTokens updateMany
   */
  export type VisaProvisionedTokensUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VisaProvisionedTokens.
     */
    data: XOR<VisaProvisionedTokensUpdateManyMutationInput, VisaProvisionedTokensUncheckedUpdateManyInput>
    /**
     * Filter which VisaProvisionedTokens to update
     */
    where?: VisaProvisionedTokensWhereInput
    /**
     * Limit how many VisaProvisionedTokens to update.
     */
    limit?: number
  }

  /**
   * VisaProvisionedTokens upsert
   */
  export type VisaProvisionedTokensUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisaProvisionedTokens
     */
    select?: VisaProvisionedTokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisaProvisionedTokens
     */
    omit?: VisaProvisionedTokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisaProvisionedTokensInclude<ExtArgs> | null
    /**
     * The filter to search for the VisaProvisionedTokens to update in case it exists.
     */
    where: VisaProvisionedTokensWhereUniqueInput
    /**
     * In case the VisaProvisionedTokens found by the `where` argument doesn't exist, create a new VisaProvisionedTokens with this data.
     */
    create: XOR<VisaProvisionedTokensCreateInput, VisaProvisionedTokensUncheckedCreateInput>
    /**
     * In case the VisaProvisionedTokens was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VisaProvisionedTokensUpdateInput, VisaProvisionedTokensUncheckedUpdateInput>
  }

  /**
   * VisaProvisionedTokens delete
   */
  export type VisaProvisionedTokensDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisaProvisionedTokens
     */
    select?: VisaProvisionedTokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisaProvisionedTokens
     */
    omit?: VisaProvisionedTokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisaProvisionedTokensInclude<ExtArgs> | null
    /**
     * Filter which VisaProvisionedTokens to delete.
     */
    where: VisaProvisionedTokensWhereUniqueInput
  }

  /**
   * VisaProvisionedTokens deleteMany
   */
  export type VisaProvisionedTokensDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VisaProvisionedTokens to delete
     */
    where?: VisaProvisionedTokensWhereInput
    /**
     * Limit how many VisaProvisionedTokens to delete.
     */
    limit?: number
  }

  /**
   * VisaProvisionedTokens.TokenStatuses
   */
  export type VisaProvisionedTokens$TokenStatusesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenStatuses
     */
    select?: TokenStatusesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TokenStatuses
     */
    omit?: TokenStatusesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenStatusesInclude<ExtArgs> | null
    where?: TokenStatusesWhereInput
  }

  /**
   * VisaProvisionedTokens without action
   */
  export type VisaProvisionedTokensDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisaProvisionedTokens
     */
    select?: VisaProvisionedTokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisaProvisionedTokens
     */
    omit?: VisaProvisionedTokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisaProvisionedTokensInclude<ExtArgs> | null
  }


  /**
   * Model VisaRequests
   */

  export type AggregateVisaRequests = {
    _count: VisaRequestsCountAggregateOutputType | null
    _min: VisaRequestsMinAggregateOutputType | null
    _max: VisaRequestsMaxAggregateOutputType | null
  }

  export type VisaRequestsMinAggregateOutputType = {
    Id: string | null
    CreatedDate: Date | null
    UpdatedDate: Date | null
    RequestUrl: string | null
    RequestMethod: string | null
    RequestHeaders: string | null
    RequestBody: string | null
    ResponseHeaders: string | null
    ResponseBody: string | null
    ResponseCode: string | null
    RequestIp: string | null
    RequestQuery: string | null
  }

  export type VisaRequestsMaxAggregateOutputType = {
    Id: string | null
    CreatedDate: Date | null
    UpdatedDate: Date | null
    RequestUrl: string | null
    RequestMethod: string | null
    RequestHeaders: string | null
    RequestBody: string | null
    ResponseHeaders: string | null
    ResponseBody: string | null
    ResponseCode: string | null
    RequestIp: string | null
    RequestQuery: string | null
  }

  export type VisaRequestsCountAggregateOutputType = {
    Id: number
    CreatedDate: number
    UpdatedDate: number
    RequestUrl: number
    RequestMethod: number
    RequestHeaders: number
    RequestBody: number
    ResponseHeaders: number
    ResponseBody: number
    ResponseCode: number
    RequestIp: number
    RequestQuery: number
    _all: number
  }


  export type VisaRequestsMinAggregateInputType = {
    Id?: true
    CreatedDate?: true
    UpdatedDate?: true
    RequestUrl?: true
    RequestMethod?: true
    RequestHeaders?: true
    RequestBody?: true
    ResponseHeaders?: true
    ResponseBody?: true
    ResponseCode?: true
    RequestIp?: true
    RequestQuery?: true
  }

  export type VisaRequestsMaxAggregateInputType = {
    Id?: true
    CreatedDate?: true
    UpdatedDate?: true
    RequestUrl?: true
    RequestMethod?: true
    RequestHeaders?: true
    RequestBody?: true
    ResponseHeaders?: true
    ResponseBody?: true
    ResponseCode?: true
    RequestIp?: true
    RequestQuery?: true
  }

  export type VisaRequestsCountAggregateInputType = {
    Id?: true
    CreatedDate?: true
    UpdatedDate?: true
    RequestUrl?: true
    RequestMethod?: true
    RequestHeaders?: true
    RequestBody?: true
    ResponseHeaders?: true
    ResponseBody?: true
    ResponseCode?: true
    RequestIp?: true
    RequestQuery?: true
    _all?: true
  }

  export type VisaRequestsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VisaRequests to aggregate.
     */
    where?: VisaRequestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisaRequests to fetch.
     */
    orderBy?: VisaRequestsOrderByWithRelationInput | VisaRequestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VisaRequestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisaRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisaRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VisaRequests
    **/
    _count?: true | VisaRequestsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VisaRequestsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VisaRequestsMaxAggregateInputType
  }

  export type GetVisaRequestsAggregateType<T extends VisaRequestsAggregateArgs> = {
        [P in keyof T & keyof AggregateVisaRequests]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVisaRequests[P]>
      : GetScalarType<T[P], AggregateVisaRequests[P]>
  }




  export type VisaRequestsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisaRequestsWhereInput
    orderBy?: VisaRequestsOrderByWithAggregationInput | VisaRequestsOrderByWithAggregationInput[]
    by: VisaRequestsScalarFieldEnum[] | VisaRequestsScalarFieldEnum
    having?: VisaRequestsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VisaRequestsCountAggregateInputType | true
    _min?: VisaRequestsMinAggregateInputType
    _max?: VisaRequestsMaxAggregateInputType
  }

  export type VisaRequestsGroupByOutputType = {
    Id: string
    CreatedDate: Date
    UpdatedDate: Date
    RequestUrl: string | null
    RequestMethod: string | null
    RequestHeaders: string | null
    RequestBody: string | null
    ResponseHeaders: string | null
    ResponseBody: string | null
    ResponseCode: string | null
    RequestIp: string | null
    RequestQuery: string | null
    _count: VisaRequestsCountAggregateOutputType | null
    _min: VisaRequestsMinAggregateOutputType | null
    _max: VisaRequestsMaxAggregateOutputType | null
  }

  type GetVisaRequestsGroupByPayload<T extends VisaRequestsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VisaRequestsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VisaRequestsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VisaRequestsGroupByOutputType[P]>
            : GetScalarType<T[P], VisaRequestsGroupByOutputType[P]>
        }
      >
    >


  export type VisaRequestsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    CreatedDate?: boolean
    UpdatedDate?: boolean
    RequestUrl?: boolean
    RequestMethod?: boolean
    RequestHeaders?: boolean
    RequestBody?: boolean
    ResponseHeaders?: boolean
    ResponseBody?: boolean
    ResponseCode?: boolean
    RequestIp?: boolean
    RequestQuery?: boolean
  }, ExtArgs["result"]["visaRequests"]>



  export type VisaRequestsSelectScalar = {
    Id?: boolean
    CreatedDate?: boolean
    UpdatedDate?: boolean
    RequestUrl?: boolean
    RequestMethod?: boolean
    RequestHeaders?: boolean
    RequestBody?: boolean
    ResponseHeaders?: boolean
    ResponseBody?: boolean
    ResponseCode?: boolean
    RequestIp?: boolean
    RequestQuery?: boolean
  }

  export type VisaRequestsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Id" | "CreatedDate" | "UpdatedDate" | "RequestUrl" | "RequestMethod" | "RequestHeaders" | "RequestBody" | "ResponseHeaders" | "ResponseBody" | "ResponseCode" | "RequestIp" | "RequestQuery", ExtArgs["result"]["visaRequests"]>

  export type $VisaRequestsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VisaRequests"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      Id: string
      CreatedDate: Date
      UpdatedDate: Date
      RequestUrl: string | null
      RequestMethod: string | null
      RequestHeaders: string | null
      RequestBody: string | null
      ResponseHeaders: string | null
      ResponseBody: string | null
      ResponseCode: string | null
      RequestIp: string | null
      RequestQuery: string | null
    }, ExtArgs["result"]["visaRequests"]>
    composites: {}
  }

  type VisaRequestsGetPayload<S extends boolean | null | undefined | VisaRequestsDefaultArgs> = $Result.GetResult<Prisma.$VisaRequestsPayload, S>

  type VisaRequestsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VisaRequestsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VisaRequestsCountAggregateInputType | true
    }

  export interface VisaRequestsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VisaRequests'], meta: { name: 'VisaRequests' } }
    /**
     * Find zero or one VisaRequests that matches the filter.
     * @param {VisaRequestsFindUniqueArgs} args - Arguments to find a VisaRequests
     * @example
     * // Get one VisaRequests
     * const visaRequests = await prisma.visaRequests.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VisaRequestsFindUniqueArgs>(args: SelectSubset<T, VisaRequestsFindUniqueArgs<ExtArgs>>): Prisma__VisaRequestsClient<$Result.GetResult<Prisma.$VisaRequestsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VisaRequests that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VisaRequestsFindUniqueOrThrowArgs} args - Arguments to find a VisaRequests
     * @example
     * // Get one VisaRequests
     * const visaRequests = await prisma.visaRequests.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VisaRequestsFindUniqueOrThrowArgs>(args: SelectSubset<T, VisaRequestsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VisaRequestsClient<$Result.GetResult<Prisma.$VisaRequestsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VisaRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisaRequestsFindFirstArgs} args - Arguments to find a VisaRequests
     * @example
     * // Get one VisaRequests
     * const visaRequests = await prisma.visaRequests.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VisaRequestsFindFirstArgs>(args?: SelectSubset<T, VisaRequestsFindFirstArgs<ExtArgs>>): Prisma__VisaRequestsClient<$Result.GetResult<Prisma.$VisaRequestsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VisaRequests that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisaRequestsFindFirstOrThrowArgs} args - Arguments to find a VisaRequests
     * @example
     * // Get one VisaRequests
     * const visaRequests = await prisma.visaRequests.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VisaRequestsFindFirstOrThrowArgs>(args?: SelectSubset<T, VisaRequestsFindFirstOrThrowArgs<ExtArgs>>): Prisma__VisaRequestsClient<$Result.GetResult<Prisma.$VisaRequestsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VisaRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisaRequestsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VisaRequests
     * const visaRequests = await prisma.visaRequests.findMany()
     * 
     * // Get first 10 VisaRequests
     * const visaRequests = await prisma.visaRequests.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const visaRequestsWithIdOnly = await prisma.visaRequests.findMany({ select: { Id: true } })
     * 
     */
    findMany<T extends VisaRequestsFindManyArgs>(args?: SelectSubset<T, VisaRequestsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisaRequestsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VisaRequests.
     * @param {VisaRequestsCreateArgs} args - Arguments to create a VisaRequests.
     * @example
     * // Create one VisaRequests
     * const VisaRequests = await prisma.visaRequests.create({
     *   data: {
     *     // ... data to create a VisaRequests
     *   }
     * })
     * 
     */
    create<T extends VisaRequestsCreateArgs>(args: SelectSubset<T, VisaRequestsCreateArgs<ExtArgs>>): Prisma__VisaRequestsClient<$Result.GetResult<Prisma.$VisaRequestsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VisaRequests.
     * @param {VisaRequestsCreateManyArgs} args - Arguments to create many VisaRequests.
     * @example
     * // Create many VisaRequests
     * const visaRequests = await prisma.visaRequests.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VisaRequestsCreateManyArgs>(args?: SelectSubset<T, VisaRequestsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a VisaRequests.
     * @param {VisaRequestsDeleteArgs} args - Arguments to delete one VisaRequests.
     * @example
     * // Delete one VisaRequests
     * const VisaRequests = await prisma.visaRequests.delete({
     *   where: {
     *     // ... filter to delete one VisaRequests
     *   }
     * })
     * 
     */
    delete<T extends VisaRequestsDeleteArgs>(args: SelectSubset<T, VisaRequestsDeleteArgs<ExtArgs>>): Prisma__VisaRequestsClient<$Result.GetResult<Prisma.$VisaRequestsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VisaRequests.
     * @param {VisaRequestsUpdateArgs} args - Arguments to update one VisaRequests.
     * @example
     * // Update one VisaRequests
     * const visaRequests = await prisma.visaRequests.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VisaRequestsUpdateArgs>(args: SelectSubset<T, VisaRequestsUpdateArgs<ExtArgs>>): Prisma__VisaRequestsClient<$Result.GetResult<Prisma.$VisaRequestsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VisaRequests.
     * @param {VisaRequestsDeleteManyArgs} args - Arguments to filter VisaRequests to delete.
     * @example
     * // Delete a few VisaRequests
     * const { count } = await prisma.visaRequests.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VisaRequestsDeleteManyArgs>(args?: SelectSubset<T, VisaRequestsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VisaRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisaRequestsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VisaRequests
     * const visaRequests = await prisma.visaRequests.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VisaRequestsUpdateManyArgs>(args: SelectSubset<T, VisaRequestsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VisaRequests.
     * @param {VisaRequestsUpsertArgs} args - Arguments to update or create a VisaRequests.
     * @example
     * // Update or create a VisaRequests
     * const visaRequests = await prisma.visaRequests.upsert({
     *   create: {
     *     // ... data to create a VisaRequests
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VisaRequests we want to update
     *   }
     * })
     */
    upsert<T extends VisaRequestsUpsertArgs>(args: SelectSubset<T, VisaRequestsUpsertArgs<ExtArgs>>): Prisma__VisaRequestsClient<$Result.GetResult<Prisma.$VisaRequestsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VisaRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisaRequestsCountArgs} args - Arguments to filter VisaRequests to count.
     * @example
     * // Count the number of VisaRequests
     * const count = await prisma.visaRequests.count({
     *   where: {
     *     // ... the filter for the VisaRequests we want to count
     *   }
     * })
    **/
    count<T extends VisaRequestsCountArgs>(
      args?: Subset<T, VisaRequestsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VisaRequestsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VisaRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisaRequestsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VisaRequestsAggregateArgs>(args: Subset<T, VisaRequestsAggregateArgs>): Prisma.PrismaPromise<GetVisaRequestsAggregateType<T>>

    /**
     * Group by VisaRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisaRequestsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VisaRequestsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VisaRequestsGroupByArgs['orderBy'] }
        : { orderBy?: VisaRequestsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VisaRequestsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVisaRequestsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VisaRequests model
   */
  readonly fields: VisaRequestsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VisaRequests.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VisaRequestsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VisaRequests model
   */
  interface VisaRequestsFieldRefs {
    readonly Id: FieldRef<"VisaRequests", 'String'>
    readonly CreatedDate: FieldRef<"VisaRequests", 'DateTime'>
    readonly UpdatedDate: FieldRef<"VisaRequests", 'DateTime'>
    readonly RequestUrl: FieldRef<"VisaRequests", 'String'>
    readonly RequestMethod: FieldRef<"VisaRequests", 'String'>
    readonly RequestHeaders: FieldRef<"VisaRequests", 'String'>
    readonly RequestBody: FieldRef<"VisaRequests", 'String'>
    readonly ResponseHeaders: FieldRef<"VisaRequests", 'String'>
    readonly ResponseBody: FieldRef<"VisaRequests", 'String'>
    readonly ResponseCode: FieldRef<"VisaRequests", 'String'>
    readonly RequestIp: FieldRef<"VisaRequests", 'String'>
    readonly RequestQuery: FieldRef<"VisaRequests", 'String'>
  }
    

  // Custom InputTypes
  /**
   * VisaRequests findUnique
   */
  export type VisaRequestsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisaRequests
     */
    select?: VisaRequestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisaRequests
     */
    omit?: VisaRequestsOmit<ExtArgs> | null
    /**
     * Filter, which VisaRequests to fetch.
     */
    where: VisaRequestsWhereUniqueInput
  }

  /**
   * VisaRequests findUniqueOrThrow
   */
  export type VisaRequestsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisaRequests
     */
    select?: VisaRequestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisaRequests
     */
    omit?: VisaRequestsOmit<ExtArgs> | null
    /**
     * Filter, which VisaRequests to fetch.
     */
    where: VisaRequestsWhereUniqueInput
  }

  /**
   * VisaRequests findFirst
   */
  export type VisaRequestsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisaRequests
     */
    select?: VisaRequestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisaRequests
     */
    omit?: VisaRequestsOmit<ExtArgs> | null
    /**
     * Filter, which VisaRequests to fetch.
     */
    where?: VisaRequestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisaRequests to fetch.
     */
    orderBy?: VisaRequestsOrderByWithRelationInput | VisaRequestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VisaRequests.
     */
    cursor?: VisaRequestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisaRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisaRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VisaRequests.
     */
    distinct?: VisaRequestsScalarFieldEnum | VisaRequestsScalarFieldEnum[]
  }

  /**
   * VisaRequests findFirstOrThrow
   */
  export type VisaRequestsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisaRequests
     */
    select?: VisaRequestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisaRequests
     */
    omit?: VisaRequestsOmit<ExtArgs> | null
    /**
     * Filter, which VisaRequests to fetch.
     */
    where?: VisaRequestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisaRequests to fetch.
     */
    orderBy?: VisaRequestsOrderByWithRelationInput | VisaRequestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VisaRequests.
     */
    cursor?: VisaRequestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisaRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisaRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VisaRequests.
     */
    distinct?: VisaRequestsScalarFieldEnum | VisaRequestsScalarFieldEnum[]
  }

  /**
   * VisaRequests findMany
   */
  export type VisaRequestsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisaRequests
     */
    select?: VisaRequestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisaRequests
     */
    omit?: VisaRequestsOmit<ExtArgs> | null
    /**
     * Filter, which VisaRequests to fetch.
     */
    where?: VisaRequestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisaRequests to fetch.
     */
    orderBy?: VisaRequestsOrderByWithRelationInput | VisaRequestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VisaRequests.
     */
    cursor?: VisaRequestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisaRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisaRequests.
     */
    skip?: number
    distinct?: VisaRequestsScalarFieldEnum | VisaRequestsScalarFieldEnum[]
  }

  /**
   * VisaRequests create
   */
  export type VisaRequestsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisaRequests
     */
    select?: VisaRequestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisaRequests
     */
    omit?: VisaRequestsOmit<ExtArgs> | null
    /**
     * The data needed to create a VisaRequests.
     */
    data: XOR<VisaRequestsCreateInput, VisaRequestsUncheckedCreateInput>
  }

  /**
   * VisaRequests createMany
   */
  export type VisaRequestsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VisaRequests.
     */
    data: VisaRequestsCreateManyInput | VisaRequestsCreateManyInput[]
  }

  /**
   * VisaRequests update
   */
  export type VisaRequestsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisaRequests
     */
    select?: VisaRequestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisaRequests
     */
    omit?: VisaRequestsOmit<ExtArgs> | null
    /**
     * The data needed to update a VisaRequests.
     */
    data: XOR<VisaRequestsUpdateInput, VisaRequestsUncheckedUpdateInput>
    /**
     * Choose, which VisaRequests to update.
     */
    where: VisaRequestsWhereUniqueInput
  }

  /**
   * VisaRequests updateMany
   */
  export type VisaRequestsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VisaRequests.
     */
    data: XOR<VisaRequestsUpdateManyMutationInput, VisaRequestsUncheckedUpdateManyInput>
    /**
     * Filter which VisaRequests to update
     */
    where?: VisaRequestsWhereInput
    /**
     * Limit how many VisaRequests to update.
     */
    limit?: number
  }

  /**
   * VisaRequests upsert
   */
  export type VisaRequestsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisaRequests
     */
    select?: VisaRequestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisaRequests
     */
    omit?: VisaRequestsOmit<ExtArgs> | null
    /**
     * The filter to search for the VisaRequests to update in case it exists.
     */
    where: VisaRequestsWhereUniqueInput
    /**
     * In case the VisaRequests found by the `where` argument doesn't exist, create a new VisaRequests with this data.
     */
    create: XOR<VisaRequestsCreateInput, VisaRequestsUncheckedCreateInput>
    /**
     * In case the VisaRequests was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VisaRequestsUpdateInput, VisaRequestsUncheckedUpdateInput>
  }

  /**
   * VisaRequests delete
   */
  export type VisaRequestsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisaRequests
     */
    select?: VisaRequestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisaRequests
     */
    omit?: VisaRequestsOmit<ExtArgs> | null
    /**
     * Filter which VisaRequests to delete.
     */
    where: VisaRequestsWhereUniqueInput
  }

  /**
   * VisaRequests deleteMany
   */
  export type VisaRequestsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VisaRequests to delete
     */
    where?: VisaRequestsWhereInput
    /**
     * Limit how many VisaRequests to delete.
     */
    limit?: number
  }

  /**
   * VisaRequests without action
   */
  export type VisaRequestsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisaRequests
     */
    select?: VisaRequestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VisaRequests
     */
    omit?: VisaRequestsOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable',
    Snapshot: 'Snapshot'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const EFMigrationsHistoryScalarFieldEnum: {
    MigrationId: 'MigrationId',
    ProductVersion: 'ProductVersion'
  };

  export type EFMigrationsHistoryScalarFieldEnum = (typeof EFMigrationsHistoryScalarFieldEnum)[keyof typeof EFMigrationsHistoryScalarFieldEnum]


  export const AccessLogScalarFieldEnum: {
    Id: 'Id',
    CreatedDate: 'CreatedDate',
    UpdatedDate: 'UpdatedDate',
    RequestUrl: 'RequestUrl',
    RequestMethod: 'RequestMethod',
    RequestHeaders: 'RequestHeaders',
    RequestBody: 'RequestBody',
    ResponseHeaders: 'ResponseHeaders',
    ResponseBody: 'ResponseBody',
    ResponseCode: 'ResponseCode',
    RequestIp: 'RequestIp',
    RequestQuery: 'RequestQuery'
  };

  export type AccessLogScalarFieldEnum = (typeof AccessLogScalarFieldEnum)[keyof typeof AccessLogScalarFieldEnum]


  export const AppSurveyScalarFieldEnum: {
    Id: 'Id',
    Rating: 'Rating',
    PhoneNumber: 'PhoneNumber',
    AccomplishedDate: 'AccomplishedDate'
  };

  export type AppSurveyScalarFieldEnum = (typeof AppSurveyScalarFieldEnum)[keyof typeof AppSurveyScalarFieldEnum]


  export const AspNetRoleClaimsScalarFieldEnum: {
    Id: 'Id',
    RoleId: 'RoleId',
    ClaimType: 'ClaimType',
    ClaimValue: 'ClaimValue'
  };

  export type AspNetRoleClaimsScalarFieldEnum = (typeof AspNetRoleClaimsScalarFieldEnum)[keyof typeof AspNetRoleClaimsScalarFieldEnum]


  export const AspNetRolesScalarFieldEnum: {
    Id: 'Id',
    Name: 'Name',
    NormalizedName: 'NormalizedName',
    ConcurrencyStamp: 'ConcurrencyStamp'
  };

  export type AspNetRolesScalarFieldEnum = (typeof AspNetRolesScalarFieldEnum)[keyof typeof AspNetRolesScalarFieldEnum]


  export const AspNetUserClaimsScalarFieldEnum: {
    Id: 'Id',
    UserId: 'UserId',
    ClaimType: 'ClaimType',
    ClaimValue: 'ClaimValue'
  };

  export type AspNetUserClaimsScalarFieldEnum = (typeof AspNetUserClaimsScalarFieldEnum)[keyof typeof AspNetUserClaimsScalarFieldEnum]


  export const AspNetUserLoginsScalarFieldEnum: {
    LoginProvider: 'LoginProvider',
    ProviderKey: 'ProviderKey',
    ProviderDisplayName: 'ProviderDisplayName',
    UserId: 'UserId'
  };

  export type AspNetUserLoginsScalarFieldEnum = (typeof AspNetUserLoginsScalarFieldEnum)[keyof typeof AspNetUserLoginsScalarFieldEnum]


  export const AspNetUserRolesScalarFieldEnum: {
    UserId: 'UserId',
    RoleId: 'RoleId'
  };

  export type AspNetUserRolesScalarFieldEnum = (typeof AspNetUserRolesScalarFieldEnum)[keyof typeof AspNetUserRolesScalarFieldEnum]


  export const AspNetUsersScalarFieldEnum: {
    Id: 'Id',
    UserName: 'UserName',
    NormalizedUserName: 'NormalizedUserName',
    Email: 'Email',
    NormalizedEmail: 'NormalizedEmail',
    EmailConfirmed: 'EmailConfirmed',
    PasswordHash: 'PasswordHash',
    SecurityStamp: 'SecurityStamp',
    ConcurrencyStamp: 'ConcurrencyStamp',
    PhoneNumber: 'PhoneNumber',
    PhoneNumberConfirmed: 'PhoneNumberConfirmed',
    TwoFactorEnabled: 'TwoFactorEnabled',
    LockoutEnd: 'LockoutEnd',
    LockoutEnabled: 'LockoutEnabled',
    AccessFailedCount: 'AccessFailedCount',
    PasswordValidUntil: 'PasswordValidUntil',
    DeviceId: 'DeviceId',
    FcmToken: 'FcmToken',
    FullName: 'FullName'
  };

  export type AspNetUsersScalarFieldEnum = (typeof AspNetUsersScalarFieldEnum)[keyof typeof AspNetUsersScalarFieldEnum]


  export const AspNetUserTokensScalarFieldEnum: {
    UserId: 'UserId',
    LoginProvider: 'LoginProvider',
    Name: 'Name',
    Value: 'Value'
  };

  export type AspNetUserTokensScalarFieldEnum = (typeof AspNetUserTokensScalarFieldEnum)[keyof typeof AspNetUserTokensScalarFieldEnum]


  export const CardReplacementRequestsScalarFieldEnum: {
    RequestID: 'RequestID',
    CreatedDate: 'CreatedDate',
    UpdatedDate: 'UpdatedDate',
    PhoneNumber: 'PhoneNumber',
    OldFourDigits: 'OldFourDigits',
    NewFourDigits: 'NewFourDigits',
    IsCompleted: 'IsCompleted',
    DeviceId: 'DeviceId'
  };

  export type CardReplacementRequestsScalarFieldEnum = (typeof CardReplacementRequestsScalarFieldEnum)[keyof typeof CardReplacementRequestsScalarFieldEnum]


  export const DetractorsFeedbackScalarFieldEnum: {
    Id: 'Id',
    Rating: 'Rating',
    PhoneNumber: 'PhoneNumber',
    Feedback: 'Feedback',
    AccomplishedDate: 'AccomplishedDate'
  };

  export type DetractorsFeedbackScalarFieldEnum = (typeof DetractorsFeedbackScalarFieldEnum)[keyof typeof DetractorsFeedbackScalarFieldEnum]


  export const DeviceAccessLogScalarFieldEnum: {
    Id: 'Id',
    AccessDateTime: 'AccessDateTime',
    DeviceId: 'DeviceId',
    MobileNumber: 'MobileNumber',
    FullName: 'FullName'
  };

  export type DeviceAccessLogScalarFieldEnum = (typeof DeviceAccessLogScalarFieldEnum)[keyof typeof DeviceAccessLogScalarFieldEnum]


  export const DeviceCodesScalarFieldEnum: {
    UserCode: 'UserCode',
    DeviceCode: 'DeviceCode',
    SubjectId: 'SubjectId',
    ClientId: 'ClientId',
    CreationTime: 'CreationTime',
    Expiration: 'Expiration',
    Data: 'Data'
  };

  export type DeviceCodesScalarFieldEnum = (typeof DeviceCodesScalarFieldEnum)[keyof typeof DeviceCodesScalarFieldEnum]


  export const EwPayActivatedCardsScalarFieldEnum: {
    Id: 'Id',
    UCRN: 'UCRN',
    DateActivated: 'DateActivated'
  };

  export type EwPayActivatedCardsScalarFieldEnum = (typeof EwPayActivatedCardsScalarFieldEnum)[keyof typeof EwPayActivatedCardsScalarFieldEnum]


  export const EwPayIneligibleCardsScalarFieldEnum: {
    Id: 'Id',
    UCRN: 'UCRN',
    IsReported: 'IsReported',
    IsActivated: 'IsActivated',
    DateReported: 'DateReported'
  };

  export type EwPayIneligibleCardsScalarFieldEnum = (typeof EwPayIneligibleCardsScalarFieldEnum)[keyof typeof EwPayIneligibleCardsScalarFieldEnum]


  export const InvalidDeviceAccessScalarFieldEnum: {
    Id: 'Id',
    AccessDateTime: 'AccessDateTime',
    DeviceId: 'DeviceId',
    MobileNumber: 'MobileNumber',
    Reason: 'Reason'
  };

  export type InvalidDeviceAccessScalarFieldEnum = (typeof InvalidDeviceAccessScalarFieldEnum)[keyof typeof InvalidDeviceAccessScalarFieldEnum]


  export const MastercardProvisionedTokensScalarFieldEnum: {
    TokenUniqueReferenceId: 'TokenUniqueReferenceId',
    PhoneNumber: 'PhoneNumber',
    DeviceId: 'DeviceId',
    PaymentAccountReference: 'PaymentAccountReference'
  };

  export type MastercardProvisionedTokensScalarFieldEnum = (typeof MastercardProvisionedTokensScalarFieldEnum)[keyof typeof MastercardProvisionedTokensScalarFieldEnum]


  export const PersistedGrantsScalarFieldEnum: {
    Key: 'Key',
    Type: 'Type',
    SubjectId: 'SubjectId',
    ClientId: 'ClientId',
    CreationTime: 'CreationTime',
    Expiration: 'Expiration',
    Data: 'Data'
  };

  export type PersistedGrantsScalarFieldEnum = (typeof PersistedGrantsScalarFieldEnum)[keyof typeof PersistedGrantsScalarFieldEnum]


  export const ProvisionedTokenIdsScalarFieldEnum: {
    Id: 'Id',
    ProvisionedTokenId: 'ProvisionedTokenId',
    PanEnrollmentId: 'PanEnrollmentId',
    TokenReferenceId: 'TokenReferenceId'
  };

  export type ProvisionedTokenIdsScalarFieldEnum = (typeof ProvisionedTokenIdsScalarFieldEnum)[keyof typeof ProvisionedTokenIdsScalarFieldEnum]


  export const RegisterLogEntryScalarFieldEnum: {
    Id: 'Id',
    DeviceId: 'DeviceId',
    MobileNumber: 'MobileNumber',
    RegistrationDateTime: 'RegistrationDateTime'
  };

  export type RegisterLogEntryScalarFieldEnum = (typeof RegisterLogEntryScalarFieldEnum)[keyof typeof RegisterLogEntryScalarFieldEnum]


  export const SysdiagramsScalarFieldEnum: {
    name: 'name',
    principal_id: 'principal_id',
    diagram_id: 'diagram_id',
    version: 'version',
    definition: 'definition'
  };

  export type SysdiagramsScalarFieldEnum = (typeof SysdiagramsScalarFieldEnum)[keyof typeof SysdiagramsScalarFieldEnum]


  export const TapToPayTransactionLogScalarFieldEnum: {
    Id: 'Id',
    DeviceId: 'DeviceId',
    PhoneNumber: 'PhoneNumber',
    TransactionDate: 'TransactionDate'
  };

  export type TapToPayTransactionLogScalarFieldEnum = (typeof TapToPayTransactionLogScalarFieldEnum)[keyof typeof TapToPayTransactionLogScalarFieldEnum]


  export const TokenStatusesScalarFieldEnum: {
    ID: 'ID',
    Name: 'Name',
    CardProviderName: 'CardProviderName',
    IsSuspended: 'IsSuspended',
    IsDeleted: 'IsDeleted',
    IsActive: 'IsActive',
    IsInactive: 'IsInactive'
  };

  export type TokenStatusesScalarFieldEnum = (typeof TokenStatusesScalarFieldEnum)[keyof typeof TokenStatusesScalarFieldEnum]


  export const VisaProvisionedTokensScalarFieldEnum: {
    ProvisionedTokenId: 'ProvisionedTokenId',
    PhoneNumber: 'PhoneNumber',
    DeviceId: 'DeviceId',
    StatusId: 'StatusId',
    PanEnrollmentId: 'PanEnrollmentId'
  };

  export type VisaProvisionedTokensScalarFieldEnum = (typeof VisaProvisionedTokensScalarFieldEnum)[keyof typeof VisaProvisionedTokensScalarFieldEnum]


  export const VisaRequestsScalarFieldEnum: {
    Id: 'Id',
    CreatedDate: 'CreatedDate',
    UpdatedDate: 'UpdatedDate',
    RequestUrl: 'RequestUrl',
    RequestMethod: 'RequestMethod',
    RequestHeaders: 'RequestHeaders',
    RequestBody: 'RequestBody',
    ResponseHeaders: 'ResponseHeaders',
    ResponseBody: 'ResponseBody',
    ResponseCode: 'ResponseCode',
    RequestIp: 'RequestIp',
    RequestQuery: 'RequestQuery'
  };

  export type VisaRequestsScalarFieldEnum = (typeof VisaRequestsScalarFieldEnum)[keyof typeof VisaRequestsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Bytes'
   */
  export type BytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type EFMigrationsHistoryWhereInput = {
    AND?: EFMigrationsHistoryWhereInput | EFMigrationsHistoryWhereInput[]
    OR?: EFMigrationsHistoryWhereInput[]
    NOT?: EFMigrationsHistoryWhereInput | EFMigrationsHistoryWhereInput[]
    MigrationId?: StringFilter<"EFMigrationsHistory"> | string
    ProductVersion?: StringFilter<"EFMigrationsHistory"> | string
  }

  export type EFMigrationsHistoryOrderByWithRelationInput = {
    MigrationId?: SortOrder
    ProductVersion?: SortOrder
  }

  export type EFMigrationsHistoryWhereUniqueInput = Prisma.AtLeast<{
    MigrationId?: string
    AND?: EFMigrationsHistoryWhereInput | EFMigrationsHistoryWhereInput[]
    OR?: EFMigrationsHistoryWhereInput[]
    NOT?: EFMigrationsHistoryWhereInput | EFMigrationsHistoryWhereInput[]
    ProductVersion?: StringFilter<"EFMigrationsHistory"> | string
  }, "MigrationId">

  export type EFMigrationsHistoryOrderByWithAggregationInput = {
    MigrationId?: SortOrder
    ProductVersion?: SortOrder
    _count?: EFMigrationsHistoryCountOrderByAggregateInput
    _max?: EFMigrationsHistoryMaxOrderByAggregateInput
    _min?: EFMigrationsHistoryMinOrderByAggregateInput
  }

  export type EFMigrationsHistoryScalarWhereWithAggregatesInput = {
    AND?: EFMigrationsHistoryScalarWhereWithAggregatesInput | EFMigrationsHistoryScalarWhereWithAggregatesInput[]
    OR?: EFMigrationsHistoryScalarWhereWithAggregatesInput[]
    NOT?: EFMigrationsHistoryScalarWhereWithAggregatesInput | EFMigrationsHistoryScalarWhereWithAggregatesInput[]
    MigrationId?: StringWithAggregatesFilter<"EFMigrationsHistory"> | string
    ProductVersion?: StringWithAggregatesFilter<"EFMigrationsHistory"> | string
  }

  export type AccessLogWhereInput = {
    AND?: AccessLogWhereInput | AccessLogWhereInput[]
    OR?: AccessLogWhereInput[]
    NOT?: AccessLogWhereInput | AccessLogWhereInput[]
    Id?: IntFilter<"AccessLog"> | number
    CreatedDate?: DateTimeFilter<"AccessLog"> | Date | string
    UpdatedDate?: DateTimeFilter<"AccessLog"> | Date | string
    RequestUrl?: StringNullableFilter<"AccessLog"> | string | null
    RequestMethod?: StringNullableFilter<"AccessLog"> | string | null
    RequestHeaders?: StringNullableFilter<"AccessLog"> | string | null
    RequestBody?: StringNullableFilter<"AccessLog"> | string | null
    ResponseHeaders?: StringNullableFilter<"AccessLog"> | string | null
    ResponseBody?: StringNullableFilter<"AccessLog"> | string | null
    ResponseCode?: StringNullableFilter<"AccessLog"> | string | null
    RequestIp?: StringNullableFilter<"AccessLog"> | string | null
    RequestQuery?: StringNullableFilter<"AccessLog"> | string | null
  }

  export type AccessLogOrderByWithRelationInput = {
    Id?: SortOrder
    CreatedDate?: SortOrder
    UpdatedDate?: SortOrder
    RequestUrl?: SortOrderInput | SortOrder
    RequestMethod?: SortOrderInput | SortOrder
    RequestHeaders?: SortOrderInput | SortOrder
    RequestBody?: SortOrderInput | SortOrder
    ResponseHeaders?: SortOrderInput | SortOrder
    ResponseBody?: SortOrderInput | SortOrder
    ResponseCode?: SortOrderInput | SortOrder
    RequestIp?: SortOrderInput | SortOrder
    RequestQuery?: SortOrderInput | SortOrder
  }

  export type AccessLogWhereUniqueInput = Prisma.AtLeast<{
    Id?: number
    AND?: AccessLogWhereInput | AccessLogWhereInput[]
    OR?: AccessLogWhereInput[]
    NOT?: AccessLogWhereInput | AccessLogWhereInput[]
    CreatedDate?: DateTimeFilter<"AccessLog"> | Date | string
    UpdatedDate?: DateTimeFilter<"AccessLog"> | Date | string
    RequestUrl?: StringNullableFilter<"AccessLog"> | string | null
    RequestMethod?: StringNullableFilter<"AccessLog"> | string | null
    RequestHeaders?: StringNullableFilter<"AccessLog"> | string | null
    RequestBody?: StringNullableFilter<"AccessLog"> | string | null
    ResponseHeaders?: StringNullableFilter<"AccessLog"> | string | null
    ResponseBody?: StringNullableFilter<"AccessLog"> | string | null
    ResponseCode?: StringNullableFilter<"AccessLog"> | string | null
    RequestIp?: StringNullableFilter<"AccessLog"> | string | null
    RequestQuery?: StringNullableFilter<"AccessLog"> | string | null
  }, "Id">

  export type AccessLogOrderByWithAggregationInput = {
    Id?: SortOrder
    CreatedDate?: SortOrder
    UpdatedDate?: SortOrder
    RequestUrl?: SortOrderInput | SortOrder
    RequestMethod?: SortOrderInput | SortOrder
    RequestHeaders?: SortOrderInput | SortOrder
    RequestBody?: SortOrderInput | SortOrder
    ResponseHeaders?: SortOrderInput | SortOrder
    ResponseBody?: SortOrderInput | SortOrder
    ResponseCode?: SortOrderInput | SortOrder
    RequestIp?: SortOrderInput | SortOrder
    RequestQuery?: SortOrderInput | SortOrder
    _count?: AccessLogCountOrderByAggregateInput
    _avg?: AccessLogAvgOrderByAggregateInput
    _max?: AccessLogMaxOrderByAggregateInput
    _min?: AccessLogMinOrderByAggregateInput
    _sum?: AccessLogSumOrderByAggregateInput
  }

  export type AccessLogScalarWhereWithAggregatesInput = {
    AND?: AccessLogScalarWhereWithAggregatesInput | AccessLogScalarWhereWithAggregatesInput[]
    OR?: AccessLogScalarWhereWithAggregatesInput[]
    NOT?: AccessLogScalarWhereWithAggregatesInput | AccessLogScalarWhereWithAggregatesInput[]
    Id?: IntWithAggregatesFilter<"AccessLog"> | number
    CreatedDate?: DateTimeWithAggregatesFilter<"AccessLog"> | Date | string
    UpdatedDate?: DateTimeWithAggregatesFilter<"AccessLog"> | Date | string
    RequestUrl?: StringNullableWithAggregatesFilter<"AccessLog"> | string | null
    RequestMethod?: StringNullableWithAggregatesFilter<"AccessLog"> | string | null
    RequestHeaders?: StringNullableWithAggregatesFilter<"AccessLog"> | string | null
    RequestBody?: StringNullableWithAggregatesFilter<"AccessLog"> | string | null
    ResponseHeaders?: StringNullableWithAggregatesFilter<"AccessLog"> | string | null
    ResponseBody?: StringNullableWithAggregatesFilter<"AccessLog"> | string | null
    ResponseCode?: StringNullableWithAggregatesFilter<"AccessLog"> | string | null
    RequestIp?: StringNullableWithAggregatesFilter<"AccessLog"> | string | null
    RequestQuery?: StringNullableWithAggregatesFilter<"AccessLog"> | string | null
  }

  export type AppSurveyWhereInput = {
    AND?: AppSurveyWhereInput | AppSurveyWhereInput[]
    OR?: AppSurveyWhereInput[]
    NOT?: AppSurveyWhereInput | AppSurveyWhereInput[]
    Id?: IntFilter<"AppSurvey"> | number
    Rating?: IntFilter<"AppSurvey"> | number
    PhoneNumber?: StringNullableFilter<"AppSurvey"> | string | null
    AccomplishedDate?: DateTimeFilter<"AppSurvey"> | Date | string
  }

  export type AppSurveyOrderByWithRelationInput = {
    Id?: SortOrder
    Rating?: SortOrder
    PhoneNumber?: SortOrderInput | SortOrder
    AccomplishedDate?: SortOrder
  }

  export type AppSurveyWhereUniqueInput = Prisma.AtLeast<{
    Id?: number
    AND?: AppSurveyWhereInput | AppSurveyWhereInput[]
    OR?: AppSurveyWhereInput[]
    NOT?: AppSurveyWhereInput | AppSurveyWhereInput[]
    Rating?: IntFilter<"AppSurvey"> | number
    PhoneNumber?: StringNullableFilter<"AppSurvey"> | string | null
    AccomplishedDate?: DateTimeFilter<"AppSurvey"> | Date | string
  }, "Id">

  export type AppSurveyOrderByWithAggregationInput = {
    Id?: SortOrder
    Rating?: SortOrder
    PhoneNumber?: SortOrderInput | SortOrder
    AccomplishedDate?: SortOrder
    _count?: AppSurveyCountOrderByAggregateInput
    _avg?: AppSurveyAvgOrderByAggregateInput
    _max?: AppSurveyMaxOrderByAggregateInput
    _min?: AppSurveyMinOrderByAggregateInput
    _sum?: AppSurveySumOrderByAggregateInput
  }

  export type AppSurveyScalarWhereWithAggregatesInput = {
    AND?: AppSurveyScalarWhereWithAggregatesInput | AppSurveyScalarWhereWithAggregatesInput[]
    OR?: AppSurveyScalarWhereWithAggregatesInput[]
    NOT?: AppSurveyScalarWhereWithAggregatesInput | AppSurveyScalarWhereWithAggregatesInput[]
    Id?: IntWithAggregatesFilter<"AppSurvey"> | number
    Rating?: IntWithAggregatesFilter<"AppSurvey"> | number
    PhoneNumber?: StringNullableWithAggregatesFilter<"AppSurvey"> | string | null
    AccomplishedDate?: DateTimeWithAggregatesFilter<"AppSurvey"> | Date | string
  }

  export type AspNetRoleClaimsWhereInput = {
    AND?: AspNetRoleClaimsWhereInput | AspNetRoleClaimsWhereInput[]
    OR?: AspNetRoleClaimsWhereInput[]
    NOT?: AspNetRoleClaimsWhereInput | AspNetRoleClaimsWhereInput[]
    Id?: IntFilter<"AspNetRoleClaims"> | number
    RoleId?: StringFilter<"AspNetRoleClaims"> | string
    ClaimType?: StringNullableFilter<"AspNetRoleClaims"> | string | null
    ClaimValue?: StringNullableFilter<"AspNetRoleClaims"> | string | null
    AspNetRoles?: XOR<AspNetRolesScalarRelationFilter, AspNetRolesWhereInput>
  }

  export type AspNetRoleClaimsOrderByWithRelationInput = {
    Id?: SortOrder
    RoleId?: SortOrder
    ClaimType?: SortOrderInput | SortOrder
    ClaimValue?: SortOrderInput | SortOrder
    AspNetRoles?: AspNetRolesOrderByWithRelationInput
  }

  export type AspNetRoleClaimsWhereUniqueInput = Prisma.AtLeast<{
    Id?: number
    AND?: AspNetRoleClaimsWhereInput | AspNetRoleClaimsWhereInput[]
    OR?: AspNetRoleClaimsWhereInput[]
    NOT?: AspNetRoleClaimsWhereInput | AspNetRoleClaimsWhereInput[]
    RoleId?: StringFilter<"AspNetRoleClaims"> | string
    ClaimType?: StringNullableFilter<"AspNetRoleClaims"> | string | null
    ClaimValue?: StringNullableFilter<"AspNetRoleClaims"> | string | null
    AspNetRoles?: XOR<AspNetRolesScalarRelationFilter, AspNetRolesWhereInput>
  }, "Id">

  export type AspNetRoleClaimsOrderByWithAggregationInput = {
    Id?: SortOrder
    RoleId?: SortOrder
    ClaimType?: SortOrderInput | SortOrder
    ClaimValue?: SortOrderInput | SortOrder
    _count?: AspNetRoleClaimsCountOrderByAggregateInput
    _avg?: AspNetRoleClaimsAvgOrderByAggregateInput
    _max?: AspNetRoleClaimsMaxOrderByAggregateInput
    _min?: AspNetRoleClaimsMinOrderByAggregateInput
    _sum?: AspNetRoleClaimsSumOrderByAggregateInput
  }

  export type AspNetRoleClaimsScalarWhereWithAggregatesInput = {
    AND?: AspNetRoleClaimsScalarWhereWithAggregatesInput | AspNetRoleClaimsScalarWhereWithAggregatesInput[]
    OR?: AspNetRoleClaimsScalarWhereWithAggregatesInput[]
    NOT?: AspNetRoleClaimsScalarWhereWithAggregatesInput | AspNetRoleClaimsScalarWhereWithAggregatesInput[]
    Id?: IntWithAggregatesFilter<"AspNetRoleClaims"> | number
    RoleId?: StringWithAggregatesFilter<"AspNetRoleClaims"> | string
    ClaimType?: StringNullableWithAggregatesFilter<"AspNetRoleClaims"> | string | null
    ClaimValue?: StringNullableWithAggregatesFilter<"AspNetRoleClaims"> | string | null
  }

  export type AspNetRolesWhereInput = {
    AND?: AspNetRolesWhereInput | AspNetRolesWhereInput[]
    OR?: AspNetRolesWhereInput[]
    NOT?: AspNetRolesWhereInput | AspNetRolesWhereInput[]
    Id?: StringFilter<"AspNetRoles"> | string
    Name?: StringNullableFilter<"AspNetRoles"> | string | null
    NormalizedName?: StringNullableFilter<"AspNetRoles"> | string | null
    ConcurrencyStamp?: StringNullableFilter<"AspNetRoles"> | string | null
    AspNetRoleClaims?: AspNetRoleClaimsListRelationFilter
    AspNetUserRoles?: AspNetUserRolesListRelationFilter
  }

  export type AspNetRolesOrderByWithRelationInput = {
    Id?: SortOrder
    Name?: SortOrderInput | SortOrder
    NormalizedName?: SortOrderInput | SortOrder
    ConcurrencyStamp?: SortOrderInput | SortOrder
    AspNetRoleClaims?: AspNetRoleClaimsOrderByRelationAggregateInput
    AspNetUserRoles?: AspNetUserRolesOrderByRelationAggregateInput
  }

  export type AspNetRolesWhereUniqueInput = Prisma.AtLeast<{
    Id?: string
    AND?: AspNetRolesWhereInput | AspNetRolesWhereInput[]
    OR?: AspNetRolesWhereInput[]
    NOT?: AspNetRolesWhereInput | AspNetRolesWhereInput[]
    Name?: StringNullableFilter<"AspNetRoles"> | string | null
    NormalizedName?: StringNullableFilter<"AspNetRoles"> | string | null
    ConcurrencyStamp?: StringNullableFilter<"AspNetRoles"> | string | null
    AspNetRoleClaims?: AspNetRoleClaimsListRelationFilter
    AspNetUserRoles?: AspNetUserRolesListRelationFilter
  }, "Id">

  export type AspNetRolesOrderByWithAggregationInput = {
    Id?: SortOrder
    Name?: SortOrderInput | SortOrder
    NormalizedName?: SortOrderInput | SortOrder
    ConcurrencyStamp?: SortOrderInput | SortOrder
    _count?: AspNetRolesCountOrderByAggregateInput
    _max?: AspNetRolesMaxOrderByAggregateInput
    _min?: AspNetRolesMinOrderByAggregateInput
  }

  export type AspNetRolesScalarWhereWithAggregatesInput = {
    AND?: AspNetRolesScalarWhereWithAggregatesInput | AspNetRolesScalarWhereWithAggregatesInput[]
    OR?: AspNetRolesScalarWhereWithAggregatesInput[]
    NOT?: AspNetRolesScalarWhereWithAggregatesInput | AspNetRolesScalarWhereWithAggregatesInput[]
    Id?: StringWithAggregatesFilter<"AspNetRoles"> | string
    Name?: StringNullableWithAggregatesFilter<"AspNetRoles"> | string | null
    NormalizedName?: StringNullableWithAggregatesFilter<"AspNetRoles"> | string | null
    ConcurrencyStamp?: StringNullableWithAggregatesFilter<"AspNetRoles"> | string | null
  }

  export type AspNetUserClaimsWhereInput = {
    AND?: AspNetUserClaimsWhereInput | AspNetUserClaimsWhereInput[]
    OR?: AspNetUserClaimsWhereInput[]
    NOT?: AspNetUserClaimsWhereInput | AspNetUserClaimsWhereInput[]
    Id?: IntFilter<"AspNetUserClaims"> | number
    UserId?: StringFilter<"AspNetUserClaims"> | string
    ClaimType?: StringNullableFilter<"AspNetUserClaims"> | string | null
    ClaimValue?: StringNullableFilter<"AspNetUserClaims"> | string | null
    AspNetUsers?: XOR<AspNetUsersScalarRelationFilter, AspNetUsersWhereInput>
  }

  export type AspNetUserClaimsOrderByWithRelationInput = {
    Id?: SortOrder
    UserId?: SortOrder
    ClaimType?: SortOrderInput | SortOrder
    ClaimValue?: SortOrderInput | SortOrder
    AspNetUsers?: AspNetUsersOrderByWithRelationInput
  }

  export type AspNetUserClaimsWhereUniqueInput = Prisma.AtLeast<{
    Id?: number
    AND?: AspNetUserClaimsWhereInput | AspNetUserClaimsWhereInput[]
    OR?: AspNetUserClaimsWhereInput[]
    NOT?: AspNetUserClaimsWhereInput | AspNetUserClaimsWhereInput[]
    UserId?: StringFilter<"AspNetUserClaims"> | string
    ClaimType?: StringNullableFilter<"AspNetUserClaims"> | string | null
    ClaimValue?: StringNullableFilter<"AspNetUserClaims"> | string | null
    AspNetUsers?: XOR<AspNetUsersScalarRelationFilter, AspNetUsersWhereInput>
  }, "Id">

  export type AspNetUserClaimsOrderByWithAggregationInput = {
    Id?: SortOrder
    UserId?: SortOrder
    ClaimType?: SortOrderInput | SortOrder
    ClaimValue?: SortOrderInput | SortOrder
    _count?: AspNetUserClaimsCountOrderByAggregateInput
    _avg?: AspNetUserClaimsAvgOrderByAggregateInput
    _max?: AspNetUserClaimsMaxOrderByAggregateInput
    _min?: AspNetUserClaimsMinOrderByAggregateInput
    _sum?: AspNetUserClaimsSumOrderByAggregateInput
  }

  export type AspNetUserClaimsScalarWhereWithAggregatesInput = {
    AND?: AspNetUserClaimsScalarWhereWithAggregatesInput | AspNetUserClaimsScalarWhereWithAggregatesInput[]
    OR?: AspNetUserClaimsScalarWhereWithAggregatesInput[]
    NOT?: AspNetUserClaimsScalarWhereWithAggregatesInput | AspNetUserClaimsScalarWhereWithAggregatesInput[]
    Id?: IntWithAggregatesFilter<"AspNetUserClaims"> | number
    UserId?: StringWithAggregatesFilter<"AspNetUserClaims"> | string
    ClaimType?: StringNullableWithAggregatesFilter<"AspNetUserClaims"> | string | null
    ClaimValue?: StringNullableWithAggregatesFilter<"AspNetUserClaims"> | string | null
  }

  export type AspNetUserLoginsWhereInput = {
    AND?: AspNetUserLoginsWhereInput | AspNetUserLoginsWhereInput[]
    OR?: AspNetUserLoginsWhereInput[]
    NOT?: AspNetUserLoginsWhereInput | AspNetUserLoginsWhereInput[]
    LoginProvider?: StringFilter<"AspNetUserLogins"> | string
    ProviderKey?: StringFilter<"AspNetUserLogins"> | string
    ProviderDisplayName?: StringNullableFilter<"AspNetUserLogins"> | string | null
    UserId?: StringFilter<"AspNetUserLogins"> | string
    AspNetUsers?: XOR<AspNetUsersScalarRelationFilter, AspNetUsersWhereInput>
  }

  export type AspNetUserLoginsOrderByWithRelationInput = {
    LoginProvider?: SortOrder
    ProviderKey?: SortOrder
    ProviderDisplayName?: SortOrderInput | SortOrder
    UserId?: SortOrder
    AspNetUsers?: AspNetUsersOrderByWithRelationInput
  }

  export type AspNetUserLoginsWhereUniqueInput = Prisma.AtLeast<{
    LoginProvider_ProviderKey?: AspNetUserLoginsLoginProviderProviderKeyCompoundUniqueInput
    AND?: AspNetUserLoginsWhereInput | AspNetUserLoginsWhereInput[]
    OR?: AspNetUserLoginsWhereInput[]
    NOT?: AspNetUserLoginsWhereInput | AspNetUserLoginsWhereInput[]
    LoginProvider?: StringFilter<"AspNetUserLogins"> | string
    ProviderKey?: StringFilter<"AspNetUserLogins"> | string
    ProviderDisplayName?: StringNullableFilter<"AspNetUserLogins"> | string | null
    UserId?: StringFilter<"AspNetUserLogins"> | string
    AspNetUsers?: XOR<AspNetUsersScalarRelationFilter, AspNetUsersWhereInput>
  }, "LoginProvider_ProviderKey">

  export type AspNetUserLoginsOrderByWithAggregationInput = {
    LoginProvider?: SortOrder
    ProviderKey?: SortOrder
    ProviderDisplayName?: SortOrderInput | SortOrder
    UserId?: SortOrder
    _count?: AspNetUserLoginsCountOrderByAggregateInput
    _max?: AspNetUserLoginsMaxOrderByAggregateInput
    _min?: AspNetUserLoginsMinOrderByAggregateInput
  }

  export type AspNetUserLoginsScalarWhereWithAggregatesInput = {
    AND?: AspNetUserLoginsScalarWhereWithAggregatesInput | AspNetUserLoginsScalarWhereWithAggregatesInput[]
    OR?: AspNetUserLoginsScalarWhereWithAggregatesInput[]
    NOT?: AspNetUserLoginsScalarWhereWithAggregatesInput | AspNetUserLoginsScalarWhereWithAggregatesInput[]
    LoginProvider?: StringWithAggregatesFilter<"AspNetUserLogins"> | string
    ProviderKey?: StringWithAggregatesFilter<"AspNetUserLogins"> | string
    ProviderDisplayName?: StringNullableWithAggregatesFilter<"AspNetUserLogins"> | string | null
    UserId?: StringWithAggregatesFilter<"AspNetUserLogins"> | string
  }

  export type AspNetUserRolesWhereInput = {
    AND?: AspNetUserRolesWhereInput | AspNetUserRolesWhereInput[]
    OR?: AspNetUserRolesWhereInput[]
    NOT?: AspNetUserRolesWhereInput | AspNetUserRolesWhereInput[]
    UserId?: StringFilter<"AspNetUserRoles"> | string
    RoleId?: StringFilter<"AspNetUserRoles"> | string
    AspNetRoles?: XOR<AspNetRolesScalarRelationFilter, AspNetRolesWhereInput>
    AspNetUsers?: XOR<AspNetUsersScalarRelationFilter, AspNetUsersWhereInput>
  }

  export type AspNetUserRolesOrderByWithRelationInput = {
    UserId?: SortOrder
    RoleId?: SortOrder
    AspNetRoles?: AspNetRolesOrderByWithRelationInput
    AspNetUsers?: AspNetUsersOrderByWithRelationInput
  }

  export type AspNetUserRolesWhereUniqueInput = Prisma.AtLeast<{
    UserId_RoleId?: AspNetUserRolesUserIdRoleIdCompoundUniqueInput
    AND?: AspNetUserRolesWhereInput | AspNetUserRolesWhereInput[]
    OR?: AspNetUserRolesWhereInput[]
    NOT?: AspNetUserRolesWhereInput | AspNetUserRolesWhereInput[]
    UserId?: StringFilter<"AspNetUserRoles"> | string
    RoleId?: StringFilter<"AspNetUserRoles"> | string
    AspNetRoles?: XOR<AspNetRolesScalarRelationFilter, AspNetRolesWhereInput>
    AspNetUsers?: XOR<AspNetUsersScalarRelationFilter, AspNetUsersWhereInput>
  }, "UserId_RoleId">

  export type AspNetUserRolesOrderByWithAggregationInput = {
    UserId?: SortOrder
    RoleId?: SortOrder
    _count?: AspNetUserRolesCountOrderByAggregateInput
    _max?: AspNetUserRolesMaxOrderByAggregateInput
    _min?: AspNetUserRolesMinOrderByAggregateInput
  }

  export type AspNetUserRolesScalarWhereWithAggregatesInput = {
    AND?: AspNetUserRolesScalarWhereWithAggregatesInput | AspNetUserRolesScalarWhereWithAggregatesInput[]
    OR?: AspNetUserRolesScalarWhereWithAggregatesInput[]
    NOT?: AspNetUserRolesScalarWhereWithAggregatesInput | AspNetUserRolesScalarWhereWithAggregatesInput[]
    UserId?: StringWithAggregatesFilter<"AspNetUserRoles"> | string
    RoleId?: StringWithAggregatesFilter<"AspNetUserRoles"> | string
  }

  export type AspNetUsersWhereInput = {
    AND?: AspNetUsersWhereInput | AspNetUsersWhereInput[]
    OR?: AspNetUsersWhereInput[]
    NOT?: AspNetUsersWhereInput | AspNetUsersWhereInput[]
    Id?: StringFilter<"AspNetUsers"> | string
    UserName?: StringNullableFilter<"AspNetUsers"> | string | null
    NormalizedUserName?: StringNullableFilter<"AspNetUsers"> | string | null
    Email?: StringNullableFilter<"AspNetUsers"> | string | null
    NormalizedEmail?: StringNullableFilter<"AspNetUsers"> | string | null
    EmailConfirmed?: BoolFilter<"AspNetUsers"> | boolean
    PasswordHash?: StringNullableFilter<"AspNetUsers"> | string | null
    SecurityStamp?: StringNullableFilter<"AspNetUsers"> | string | null
    ConcurrencyStamp?: StringNullableFilter<"AspNetUsers"> | string | null
    PhoneNumber?: StringNullableFilter<"AspNetUsers"> | string | null
    PhoneNumberConfirmed?: BoolFilter<"AspNetUsers"> | boolean
    TwoFactorEnabled?: BoolFilter<"AspNetUsers"> | boolean
    LockoutEnd?: DateTimeNullableFilter<"AspNetUsers"> | Date | string | null
    LockoutEnabled?: BoolFilter<"AspNetUsers"> | boolean
    AccessFailedCount?: IntFilter<"AspNetUsers"> | number
    PasswordValidUntil?: DateTimeFilter<"AspNetUsers"> | Date | string
    DeviceId?: StringNullableFilter<"AspNetUsers"> | string | null
    FcmToken?: StringNullableFilter<"AspNetUsers"> | string | null
    FullName?: StringNullableFilter<"AspNetUsers"> | string | null
    AspNetUserClaims?: AspNetUserClaimsListRelationFilter
    AspNetUserLogins?: AspNetUserLoginsListRelationFilter
    AspNetUserRoles?: AspNetUserRolesListRelationFilter
    AspNetUserTokens?: AspNetUserTokensListRelationFilter
  }

  export type AspNetUsersOrderByWithRelationInput = {
    Id?: SortOrder
    UserName?: SortOrderInput | SortOrder
    NormalizedUserName?: SortOrderInput | SortOrder
    Email?: SortOrderInput | SortOrder
    NormalizedEmail?: SortOrderInput | SortOrder
    EmailConfirmed?: SortOrder
    PasswordHash?: SortOrderInput | SortOrder
    SecurityStamp?: SortOrderInput | SortOrder
    ConcurrencyStamp?: SortOrderInput | SortOrder
    PhoneNumber?: SortOrderInput | SortOrder
    PhoneNumberConfirmed?: SortOrder
    TwoFactorEnabled?: SortOrder
    LockoutEnd?: SortOrderInput | SortOrder
    LockoutEnabled?: SortOrder
    AccessFailedCount?: SortOrder
    PasswordValidUntil?: SortOrder
    DeviceId?: SortOrderInput | SortOrder
    FcmToken?: SortOrderInput | SortOrder
    FullName?: SortOrderInput | SortOrder
    AspNetUserClaims?: AspNetUserClaimsOrderByRelationAggregateInput
    AspNetUserLogins?: AspNetUserLoginsOrderByRelationAggregateInput
    AspNetUserRoles?: AspNetUserRolesOrderByRelationAggregateInput
    AspNetUserTokens?: AspNetUserTokensOrderByRelationAggregateInput
  }

  export type AspNetUsersWhereUniqueInput = Prisma.AtLeast<{
    Id?: string
    AND?: AspNetUsersWhereInput | AspNetUsersWhereInput[]
    OR?: AspNetUsersWhereInput[]
    NOT?: AspNetUsersWhereInput | AspNetUsersWhereInput[]
    UserName?: StringNullableFilter<"AspNetUsers"> | string | null
    NormalizedUserName?: StringNullableFilter<"AspNetUsers"> | string | null
    Email?: StringNullableFilter<"AspNetUsers"> | string | null
    NormalizedEmail?: StringNullableFilter<"AspNetUsers"> | string | null
    EmailConfirmed?: BoolFilter<"AspNetUsers"> | boolean
    PasswordHash?: StringNullableFilter<"AspNetUsers"> | string | null
    SecurityStamp?: StringNullableFilter<"AspNetUsers"> | string | null
    ConcurrencyStamp?: StringNullableFilter<"AspNetUsers"> | string | null
    PhoneNumber?: StringNullableFilter<"AspNetUsers"> | string | null
    PhoneNumberConfirmed?: BoolFilter<"AspNetUsers"> | boolean
    TwoFactorEnabled?: BoolFilter<"AspNetUsers"> | boolean
    LockoutEnd?: DateTimeNullableFilter<"AspNetUsers"> | Date | string | null
    LockoutEnabled?: BoolFilter<"AspNetUsers"> | boolean
    AccessFailedCount?: IntFilter<"AspNetUsers"> | number
    PasswordValidUntil?: DateTimeFilter<"AspNetUsers"> | Date | string
    DeviceId?: StringNullableFilter<"AspNetUsers"> | string | null
    FcmToken?: StringNullableFilter<"AspNetUsers"> | string | null
    FullName?: StringNullableFilter<"AspNetUsers"> | string | null
    AspNetUserClaims?: AspNetUserClaimsListRelationFilter
    AspNetUserLogins?: AspNetUserLoginsListRelationFilter
    AspNetUserRoles?: AspNetUserRolesListRelationFilter
    AspNetUserTokens?: AspNetUserTokensListRelationFilter
  }, "Id">

  export type AspNetUsersOrderByWithAggregationInput = {
    Id?: SortOrder
    UserName?: SortOrderInput | SortOrder
    NormalizedUserName?: SortOrderInput | SortOrder
    Email?: SortOrderInput | SortOrder
    NormalizedEmail?: SortOrderInput | SortOrder
    EmailConfirmed?: SortOrder
    PasswordHash?: SortOrderInput | SortOrder
    SecurityStamp?: SortOrderInput | SortOrder
    ConcurrencyStamp?: SortOrderInput | SortOrder
    PhoneNumber?: SortOrderInput | SortOrder
    PhoneNumberConfirmed?: SortOrder
    TwoFactorEnabled?: SortOrder
    LockoutEnd?: SortOrderInput | SortOrder
    LockoutEnabled?: SortOrder
    AccessFailedCount?: SortOrder
    PasswordValidUntil?: SortOrder
    DeviceId?: SortOrderInput | SortOrder
    FcmToken?: SortOrderInput | SortOrder
    FullName?: SortOrderInput | SortOrder
    _count?: AspNetUsersCountOrderByAggregateInput
    _avg?: AspNetUsersAvgOrderByAggregateInput
    _max?: AspNetUsersMaxOrderByAggregateInput
    _min?: AspNetUsersMinOrderByAggregateInput
    _sum?: AspNetUsersSumOrderByAggregateInput
  }

  export type AspNetUsersScalarWhereWithAggregatesInput = {
    AND?: AspNetUsersScalarWhereWithAggregatesInput | AspNetUsersScalarWhereWithAggregatesInput[]
    OR?: AspNetUsersScalarWhereWithAggregatesInput[]
    NOT?: AspNetUsersScalarWhereWithAggregatesInput | AspNetUsersScalarWhereWithAggregatesInput[]
    Id?: StringWithAggregatesFilter<"AspNetUsers"> | string
    UserName?: StringNullableWithAggregatesFilter<"AspNetUsers"> | string | null
    NormalizedUserName?: StringNullableWithAggregatesFilter<"AspNetUsers"> | string | null
    Email?: StringNullableWithAggregatesFilter<"AspNetUsers"> | string | null
    NormalizedEmail?: StringNullableWithAggregatesFilter<"AspNetUsers"> | string | null
    EmailConfirmed?: BoolWithAggregatesFilter<"AspNetUsers"> | boolean
    PasswordHash?: StringNullableWithAggregatesFilter<"AspNetUsers"> | string | null
    SecurityStamp?: StringNullableWithAggregatesFilter<"AspNetUsers"> | string | null
    ConcurrencyStamp?: StringNullableWithAggregatesFilter<"AspNetUsers"> | string | null
    PhoneNumber?: StringNullableWithAggregatesFilter<"AspNetUsers"> | string | null
    PhoneNumberConfirmed?: BoolWithAggregatesFilter<"AspNetUsers"> | boolean
    TwoFactorEnabled?: BoolWithAggregatesFilter<"AspNetUsers"> | boolean
    LockoutEnd?: DateTimeNullableWithAggregatesFilter<"AspNetUsers"> | Date | string | null
    LockoutEnabled?: BoolWithAggregatesFilter<"AspNetUsers"> | boolean
    AccessFailedCount?: IntWithAggregatesFilter<"AspNetUsers"> | number
    PasswordValidUntil?: DateTimeWithAggregatesFilter<"AspNetUsers"> | Date | string
    DeviceId?: StringNullableWithAggregatesFilter<"AspNetUsers"> | string | null
    FcmToken?: StringNullableWithAggregatesFilter<"AspNetUsers"> | string | null
    FullName?: StringNullableWithAggregatesFilter<"AspNetUsers"> | string | null
  }

  export type AspNetUserTokensWhereInput = {
    AND?: AspNetUserTokensWhereInput | AspNetUserTokensWhereInput[]
    OR?: AspNetUserTokensWhereInput[]
    NOT?: AspNetUserTokensWhereInput | AspNetUserTokensWhereInput[]
    UserId?: StringFilter<"AspNetUserTokens"> | string
    LoginProvider?: StringFilter<"AspNetUserTokens"> | string
    Name?: StringFilter<"AspNetUserTokens"> | string
    Value?: StringNullableFilter<"AspNetUserTokens"> | string | null
    AspNetUsers?: XOR<AspNetUsersScalarRelationFilter, AspNetUsersWhereInput>
  }

  export type AspNetUserTokensOrderByWithRelationInput = {
    UserId?: SortOrder
    LoginProvider?: SortOrder
    Name?: SortOrder
    Value?: SortOrderInput | SortOrder
    AspNetUsers?: AspNetUsersOrderByWithRelationInput
  }

  export type AspNetUserTokensWhereUniqueInput = Prisma.AtLeast<{
    UserId_LoginProvider_Name?: AspNetUserTokensUserIdLoginProviderNameCompoundUniqueInput
    AND?: AspNetUserTokensWhereInput | AspNetUserTokensWhereInput[]
    OR?: AspNetUserTokensWhereInput[]
    NOT?: AspNetUserTokensWhereInput | AspNetUserTokensWhereInput[]
    UserId?: StringFilter<"AspNetUserTokens"> | string
    LoginProvider?: StringFilter<"AspNetUserTokens"> | string
    Name?: StringFilter<"AspNetUserTokens"> | string
    Value?: StringNullableFilter<"AspNetUserTokens"> | string | null
    AspNetUsers?: XOR<AspNetUsersScalarRelationFilter, AspNetUsersWhereInput>
  }, "UserId_LoginProvider_Name">

  export type AspNetUserTokensOrderByWithAggregationInput = {
    UserId?: SortOrder
    LoginProvider?: SortOrder
    Name?: SortOrder
    Value?: SortOrderInput | SortOrder
    _count?: AspNetUserTokensCountOrderByAggregateInput
    _max?: AspNetUserTokensMaxOrderByAggregateInput
    _min?: AspNetUserTokensMinOrderByAggregateInput
  }

  export type AspNetUserTokensScalarWhereWithAggregatesInput = {
    AND?: AspNetUserTokensScalarWhereWithAggregatesInput | AspNetUserTokensScalarWhereWithAggregatesInput[]
    OR?: AspNetUserTokensScalarWhereWithAggregatesInput[]
    NOT?: AspNetUserTokensScalarWhereWithAggregatesInput | AspNetUserTokensScalarWhereWithAggregatesInput[]
    UserId?: StringWithAggregatesFilter<"AspNetUserTokens"> | string
    LoginProvider?: StringWithAggregatesFilter<"AspNetUserTokens"> | string
    Name?: StringWithAggregatesFilter<"AspNetUserTokens"> | string
    Value?: StringNullableWithAggregatesFilter<"AspNetUserTokens"> | string | null
  }

  export type CardReplacementRequestsWhereInput = {
    AND?: CardReplacementRequestsWhereInput | CardReplacementRequestsWhereInput[]
    OR?: CardReplacementRequestsWhereInput[]
    NOT?: CardReplacementRequestsWhereInput | CardReplacementRequestsWhereInput[]
    RequestID?: StringFilter<"CardReplacementRequests"> | string
    CreatedDate?: DateTimeFilter<"CardReplacementRequests"> | Date | string
    UpdatedDate?: DateTimeFilter<"CardReplacementRequests"> | Date | string
    PhoneNumber?: StringNullableFilter<"CardReplacementRequests"> | string | null
    OldFourDigits?: StringNullableFilter<"CardReplacementRequests"> | string | null
    NewFourDigits?: StringNullableFilter<"CardReplacementRequests"> | string | null
    IsCompleted?: BoolFilter<"CardReplacementRequests"> | boolean
    DeviceId?: StringNullableFilter<"CardReplacementRequests"> | string | null
  }

  export type CardReplacementRequestsOrderByWithRelationInput = {
    RequestID?: SortOrder
    CreatedDate?: SortOrder
    UpdatedDate?: SortOrder
    PhoneNumber?: SortOrderInput | SortOrder
    OldFourDigits?: SortOrderInput | SortOrder
    NewFourDigits?: SortOrderInput | SortOrder
    IsCompleted?: SortOrder
    DeviceId?: SortOrderInput | SortOrder
  }

  export type CardReplacementRequestsWhereUniqueInput = Prisma.AtLeast<{
    RequestID?: string
    AND?: CardReplacementRequestsWhereInput | CardReplacementRequestsWhereInput[]
    OR?: CardReplacementRequestsWhereInput[]
    NOT?: CardReplacementRequestsWhereInput | CardReplacementRequestsWhereInput[]
    CreatedDate?: DateTimeFilter<"CardReplacementRequests"> | Date | string
    UpdatedDate?: DateTimeFilter<"CardReplacementRequests"> | Date | string
    PhoneNumber?: StringNullableFilter<"CardReplacementRequests"> | string | null
    OldFourDigits?: StringNullableFilter<"CardReplacementRequests"> | string | null
    NewFourDigits?: StringNullableFilter<"CardReplacementRequests"> | string | null
    IsCompleted?: BoolFilter<"CardReplacementRequests"> | boolean
    DeviceId?: StringNullableFilter<"CardReplacementRequests"> | string | null
  }, "RequestID">

  export type CardReplacementRequestsOrderByWithAggregationInput = {
    RequestID?: SortOrder
    CreatedDate?: SortOrder
    UpdatedDate?: SortOrder
    PhoneNumber?: SortOrderInput | SortOrder
    OldFourDigits?: SortOrderInput | SortOrder
    NewFourDigits?: SortOrderInput | SortOrder
    IsCompleted?: SortOrder
    DeviceId?: SortOrderInput | SortOrder
    _count?: CardReplacementRequestsCountOrderByAggregateInput
    _max?: CardReplacementRequestsMaxOrderByAggregateInput
    _min?: CardReplacementRequestsMinOrderByAggregateInput
  }

  export type CardReplacementRequestsScalarWhereWithAggregatesInput = {
    AND?: CardReplacementRequestsScalarWhereWithAggregatesInput | CardReplacementRequestsScalarWhereWithAggregatesInput[]
    OR?: CardReplacementRequestsScalarWhereWithAggregatesInput[]
    NOT?: CardReplacementRequestsScalarWhereWithAggregatesInput | CardReplacementRequestsScalarWhereWithAggregatesInput[]
    RequestID?: StringWithAggregatesFilter<"CardReplacementRequests"> | string
    CreatedDate?: DateTimeWithAggregatesFilter<"CardReplacementRequests"> | Date | string
    UpdatedDate?: DateTimeWithAggregatesFilter<"CardReplacementRequests"> | Date | string
    PhoneNumber?: StringNullableWithAggregatesFilter<"CardReplacementRequests"> | string | null
    OldFourDigits?: StringNullableWithAggregatesFilter<"CardReplacementRequests"> | string | null
    NewFourDigits?: StringNullableWithAggregatesFilter<"CardReplacementRequests"> | string | null
    IsCompleted?: BoolWithAggregatesFilter<"CardReplacementRequests"> | boolean
    DeviceId?: StringNullableWithAggregatesFilter<"CardReplacementRequests"> | string | null
  }

  export type DetractorsFeedbackWhereInput = {
    AND?: DetractorsFeedbackWhereInput | DetractorsFeedbackWhereInput[]
    OR?: DetractorsFeedbackWhereInput[]
    NOT?: DetractorsFeedbackWhereInput | DetractorsFeedbackWhereInput[]
    Id?: IntFilter<"DetractorsFeedback"> | number
    Rating?: IntFilter<"DetractorsFeedback"> | number
    PhoneNumber?: StringNullableFilter<"DetractorsFeedback"> | string | null
    Feedback?: StringNullableFilter<"DetractorsFeedback"> | string | null
    AccomplishedDate?: DateTimeFilter<"DetractorsFeedback"> | Date | string
  }

  export type DetractorsFeedbackOrderByWithRelationInput = {
    Id?: SortOrder
    Rating?: SortOrder
    PhoneNumber?: SortOrderInput | SortOrder
    Feedback?: SortOrderInput | SortOrder
    AccomplishedDate?: SortOrder
  }

  export type DetractorsFeedbackWhereUniqueInput = Prisma.AtLeast<{
    Id?: number
    AND?: DetractorsFeedbackWhereInput | DetractorsFeedbackWhereInput[]
    OR?: DetractorsFeedbackWhereInput[]
    NOT?: DetractorsFeedbackWhereInput | DetractorsFeedbackWhereInput[]
    Rating?: IntFilter<"DetractorsFeedback"> | number
    PhoneNumber?: StringNullableFilter<"DetractorsFeedback"> | string | null
    Feedback?: StringNullableFilter<"DetractorsFeedback"> | string | null
    AccomplishedDate?: DateTimeFilter<"DetractorsFeedback"> | Date | string
  }, "Id">

  export type DetractorsFeedbackOrderByWithAggregationInput = {
    Id?: SortOrder
    Rating?: SortOrder
    PhoneNumber?: SortOrderInput | SortOrder
    Feedback?: SortOrderInput | SortOrder
    AccomplishedDate?: SortOrder
    _count?: DetractorsFeedbackCountOrderByAggregateInput
    _avg?: DetractorsFeedbackAvgOrderByAggregateInput
    _max?: DetractorsFeedbackMaxOrderByAggregateInput
    _min?: DetractorsFeedbackMinOrderByAggregateInput
    _sum?: DetractorsFeedbackSumOrderByAggregateInput
  }

  export type DetractorsFeedbackScalarWhereWithAggregatesInput = {
    AND?: DetractorsFeedbackScalarWhereWithAggregatesInput | DetractorsFeedbackScalarWhereWithAggregatesInput[]
    OR?: DetractorsFeedbackScalarWhereWithAggregatesInput[]
    NOT?: DetractorsFeedbackScalarWhereWithAggregatesInput | DetractorsFeedbackScalarWhereWithAggregatesInput[]
    Id?: IntWithAggregatesFilter<"DetractorsFeedback"> | number
    Rating?: IntWithAggregatesFilter<"DetractorsFeedback"> | number
    PhoneNumber?: StringNullableWithAggregatesFilter<"DetractorsFeedback"> | string | null
    Feedback?: StringNullableWithAggregatesFilter<"DetractorsFeedback"> | string | null
    AccomplishedDate?: DateTimeWithAggregatesFilter<"DetractorsFeedback"> | Date | string
  }

  export type DeviceAccessLogWhereInput = {
    AND?: DeviceAccessLogWhereInput | DeviceAccessLogWhereInput[]
    OR?: DeviceAccessLogWhereInput[]
    NOT?: DeviceAccessLogWhereInput | DeviceAccessLogWhereInput[]
    Id?: IntFilter<"DeviceAccessLog"> | number
    AccessDateTime?: DateTimeFilter<"DeviceAccessLog"> | Date | string
    DeviceId?: StringNullableFilter<"DeviceAccessLog"> | string | null
    MobileNumber?: StringNullableFilter<"DeviceAccessLog"> | string | null
    FullName?: StringNullableFilter<"DeviceAccessLog"> | string | null
  }

  export type DeviceAccessLogOrderByWithRelationInput = {
    Id?: SortOrder
    AccessDateTime?: SortOrder
    DeviceId?: SortOrderInput | SortOrder
    MobileNumber?: SortOrderInput | SortOrder
    FullName?: SortOrderInput | SortOrder
  }

  export type DeviceAccessLogWhereUniqueInput = Prisma.AtLeast<{
    Id?: number
    AND?: DeviceAccessLogWhereInput | DeviceAccessLogWhereInput[]
    OR?: DeviceAccessLogWhereInput[]
    NOT?: DeviceAccessLogWhereInput | DeviceAccessLogWhereInput[]
    AccessDateTime?: DateTimeFilter<"DeviceAccessLog"> | Date | string
    DeviceId?: StringNullableFilter<"DeviceAccessLog"> | string | null
    MobileNumber?: StringNullableFilter<"DeviceAccessLog"> | string | null
    FullName?: StringNullableFilter<"DeviceAccessLog"> | string | null
  }, "Id">

  export type DeviceAccessLogOrderByWithAggregationInput = {
    Id?: SortOrder
    AccessDateTime?: SortOrder
    DeviceId?: SortOrderInput | SortOrder
    MobileNumber?: SortOrderInput | SortOrder
    FullName?: SortOrderInput | SortOrder
    _count?: DeviceAccessLogCountOrderByAggregateInput
    _avg?: DeviceAccessLogAvgOrderByAggregateInput
    _max?: DeviceAccessLogMaxOrderByAggregateInput
    _min?: DeviceAccessLogMinOrderByAggregateInput
    _sum?: DeviceAccessLogSumOrderByAggregateInput
  }

  export type DeviceAccessLogScalarWhereWithAggregatesInput = {
    AND?: DeviceAccessLogScalarWhereWithAggregatesInput | DeviceAccessLogScalarWhereWithAggregatesInput[]
    OR?: DeviceAccessLogScalarWhereWithAggregatesInput[]
    NOT?: DeviceAccessLogScalarWhereWithAggregatesInput | DeviceAccessLogScalarWhereWithAggregatesInput[]
    Id?: IntWithAggregatesFilter<"DeviceAccessLog"> | number
    AccessDateTime?: DateTimeWithAggregatesFilter<"DeviceAccessLog"> | Date | string
    DeviceId?: StringNullableWithAggregatesFilter<"DeviceAccessLog"> | string | null
    MobileNumber?: StringNullableWithAggregatesFilter<"DeviceAccessLog"> | string | null
    FullName?: StringNullableWithAggregatesFilter<"DeviceAccessLog"> | string | null
  }

  export type DeviceCodesWhereInput = {
    AND?: DeviceCodesWhereInput | DeviceCodesWhereInput[]
    OR?: DeviceCodesWhereInput[]
    NOT?: DeviceCodesWhereInput | DeviceCodesWhereInput[]
    UserCode?: StringFilter<"DeviceCodes"> | string
    DeviceCode?: StringFilter<"DeviceCodes"> | string
    SubjectId?: StringNullableFilter<"DeviceCodes"> | string | null
    ClientId?: StringFilter<"DeviceCodes"> | string
    CreationTime?: DateTimeFilter<"DeviceCodes"> | Date | string
    Expiration?: DateTimeFilter<"DeviceCodes"> | Date | string
    Data?: StringFilter<"DeviceCodes"> | string
  }

  export type DeviceCodesOrderByWithRelationInput = {
    UserCode?: SortOrder
    DeviceCode?: SortOrder
    SubjectId?: SortOrderInput | SortOrder
    ClientId?: SortOrder
    CreationTime?: SortOrder
    Expiration?: SortOrder
    Data?: SortOrder
  }

  export type DeviceCodesWhereUniqueInput = Prisma.AtLeast<{
    UserCode?: string
    DeviceCode?: string
    AND?: DeviceCodesWhereInput | DeviceCodesWhereInput[]
    OR?: DeviceCodesWhereInput[]
    NOT?: DeviceCodesWhereInput | DeviceCodesWhereInput[]
    SubjectId?: StringNullableFilter<"DeviceCodes"> | string | null
    ClientId?: StringFilter<"DeviceCodes"> | string
    CreationTime?: DateTimeFilter<"DeviceCodes"> | Date | string
    Expiration?: DateTimeFilter<"DeviceCodes"> | Date | string
    Data?: StringFilter<"DeviceCodes"> | string
  }, "UserCode" | "DeviceCode">

  export type DeviceCodesOrderByWithAggregationInput = {
    UserCode?: SortOrder
    DeviceCode?: SortOrder
    SubjectId?: SortOrderInput | SortOrder
    ClientId?: SortOrder
    CreationTime?: SortOrder
    Expiration?: SortOrder
    Data?: SortOrder
    _count?: DeviceCodesCountOrderByAggregateInput
    _max?: DeviceCodesMaxOrderByAggregateInput
    _min?: DeviceCodesMinOrderByAggregateInput
  }

  export type DeviceCodesScalarWhereWithAggregatesInput = {
    AND?: DeviceCodesScalarWhereWithAggregatesInput | DeviceCodesScalarWhereWithAggregatesInput[]
    OR?: DeviceCodesScalarWhereWithAggregatesInput[]
    NOT?: DeviceCodesScalarWhereWithAggregatesInput | DeviceCodesScalarWhereWithAggregatesInput[]
    UserCode?: StringWithAggregatesFilter<"DeviceCodes"> | string
    DeviceCode?: StringWithAggregatesFilter<"DeviceCodes"> | string
    SubjectId?: StringNullableWithAggregatesFilter<"DeviceCodes"> | string | null
    ClientId?: StringWithAggregatesFilter<"DeviceCodes"> | string
    CreationTime?: DateTimeWithAggregatesFilter<"DeviceCodes"> | Date | string
    Expiration?: DateTimeWithAggregatesFilter<"DeviceCodes"> | Date | string
    Data?: StringWithAggregatesFilter<"DeviceCodes"> | string
  }

  export type EwPayActivatedCardsWhereInput = {
    AND?: EwPayActivatedCardsWhereInput | EwPayActivatedCardsWhereInput[]
    OR?: EwPayActivatedCardsWhereInput[]
    NOT?: EwPayActivatedCardsWhereInput | EwPayActivatedCardsWhereInput[]
    Id?: IntFilter<"EwPayActivatedCards"> | number
    UCRN?: StringNullableFilter<"EwPayActivatedCards"> | string | null
    DateActivated?: DateTimeFilter<"EwPayActivatedCards"> | Date | string
  }

  export type EwPayActivatedCardsOrderByWithRelationInput = {
    Id?: SortOrder
    UCRN?: SortOrderInput | SortOrder
    DateActivated?: SortOrder
  }

  export type EwPayActivatedCardsWhereUniqueInput = Prisma.AtLeast<{
    Id?: number
    AND?: EwPayActivatedCardsWhereInput | EwPayActivatedCardsWhereInput[]
    OR?: EwPayActivatedCardsWhereInput[]
    NOT?: EwPayActivatedCardsWhereInput | EwPayActivatedCardsWhereInput[]
    UCRN?: StringNullableFilter<"EwPayActivatedCards"> | string | null
    DateActivated?: DateTimeFilter<"EwPayActivatedCards"> | Date | string
  }, "Id">

  export type EwPayActivatedCardsOrderByWithAggregationInput = {
    Id?: SortOrder
    UCRN?: SortOrderInput | SortOrder
    DateActivated?: SortOrder
    _count?: EwPayActivatedCardsCountOrderByAggregateInput
    _avg?: EwPayActivatedCardsAvgOrderByAggregateInput
    _max?: EwPayActivatedCardsMaxOrderByAggregateInput
    _min?: EwPayActivatedCardsMinOrderByAggregateInput
    _sum?: EwPayActivatedCardsSumOrderByAggregateInput
  }

  export type EwPayActivatedCardsScalarWhereWithAggregatesInput = {
    AND?: EwPayActivatedCardsScalarWhereWithAggregatesInput | EwPayActivatedCardsScalarWhereWithAggregatesInput[]
    OR?: EwPayActivatedCardsScalarWhereWithAggregatesInput[]
    NOT?: EwPayActivatedCardsScalarWhereWithAggregatesInput | EwPayActivatedCardsScalarWhereWithAggregatesInput[]
    Id?: IntWithAggregatesFilter<"EwPayActivatedCards"> | number
    UCRN?: StringNullableWithAggregatesFilter<"EwPayActivatedCards"> | string | null
    DateActivated?: DateTimeWithAggregatesFilter<"EwPayActivatedCards"> | Date | string
  }

  export type EwPayIneligibleCardsWhereInput = {
    AND?: EwPayIneligibleCardsWhereInput | EwPayIneligibleCardsWhereInput[]
    OR?: EwPayIneligibleCardsWhereInput[]
    NOT?: EwPayIneligibleCardsWhereInput | EwPayIneligibleCardsWhereInput[]
    Id?: IntFilter<"EwPayIneligibleCards"> | number
    UCRN?: StringNullableFilter<"EwPayIneligibleCards"> | string | null
    IsReported?: BoolFilter<"EwPayIneligibleCards"> | boolean
    IsActivated?: BoolFilter<"EwPayIneligibleCards"> | boolean
    DateReported?: DateTimeFilter<"EwPayIneligibleCards"> | Date | string
  }

  export type EwPayIneligibleCardsOrderByWithRelationInput = {
    Id?: SortOrder
    UCRN?: SortOrderInput | SortOrder
    IsReported?: SortOrder
    IsActivated?: SortOrder
    DateReported?: SortOrder
  }

  export type EwPayIneligibleCardsWhereUniqueInput = Prisma.AtLeast<{
    Id?: number
    AND?: EwPayIneligibleCardsWhereInput | EwPayIneligibleCardsWhereInput[]
    OR?: EwPayIneligibleCardsWhereInput[]
    NOT?: EwPayIneligibleCardsWhereInput | EwPayIneligibleCardsWhereInput[]
    UCRN?: StringNullableFilter<"EwPayIneligibleCards"> | string | null
    IsReported?: BoolFilter<"EwPayIneligibleCards"> | boolean
    IsActivated?: BoolFilter<"EwPayIneligibleCards"> | boolean
    DateReported?: DateTimeFilter<"EwPayIneligibleCards"> | Date | string
  }, "Id">

  export type EwPayIneligibleCardsOrderByWithAggregationInput = {
    Id?: SortOrder
    UCRN?: SortOrderInput | SortOrder
    IsReported?: SortOrder
    IsActivated?: SortOrder
    DateReported?: SortOrder
    _count?: EwPayIneligibleCardsCountOrderByAggregateInput
    _avg?: EwPayIneligibleCardsAvgOrderByAggregateInput
    _max?: EwPayIneligibleCardsMaxOrderByAggregateInput
    _min?: EwPayIneligibleCardsMinOrderByAggregateInput
    _sum?: EwPayIneligibleCardsSumOrderByAggregateInput
  }

  export type EwPayIneligibleCardsScalarWhereWithAggregatesInput = {
    AND?: EwPayIneligibleCardsScalarWhereWithAggregatesInput | EwPayIneligibleCardsScalarWhereWithAggregatesInput[]
    OR?: EwPayIneligibleCardsScalarWhereWithAggregatesInput[]
    NOT?: EwPayIneligibleCardsScalarWhereWithAggregatesInput | EwPayIneligibleCardsScalarWhereWithAggregatesInput[]
    Id?: IntWithAggregatesFilter<"EwPayIneligibleCards"> | number
    UCRN?: StringNullableWithAggregatesFilter<"EwPayIneligibleCards"> | string | null
    IsReported?: BoolWithAggregatesFilter<"EwPayIneligibleCards"> | boolean
    IsActivated?: BoolWithAggregatesFilter<"EwPayIneligibleCards"> | boolean
    DateReported?: DateTimeWithAggregatesFilter<"EwPayIneligibleCards"> | Date | string
  }

  export type InvalidDeviceAccessWhereInput = {
    AND?: InvalidDeviceAccessWhereInput | InvalidDeviceAccessWhereInput[]
    OR?: InvalidDeviceAccessWhereInput[]
    NOT?: InvalidDeviceAccessWhereInput | InvalidDeviceAccessWhereInput[]
    Id?: IntFilter<"InvalidDeviceAccess"> | number
    AccessDateTime?: DateTimeFilter<"InvalidDeviceAccess"> | Date | string
    DeviceId?: StringNullableFilter<"InvalidDeviceAccess"> | string | null
    MobileNumber?: StringNullableFilter<"InvalidDeviceAccess"> | string | null
    Reason?: StringNullableFilter<"InvalidDeviceAccess"> | string | null
  }

  export type InvalidDeviceAccessOrderByWithRelationInput = {
    Id?: SortOrder
    AccessDateTime?: SortOrder
    DeviceId?: SortOrderInput | SortOrder
    MobileNumber?: SortOrderInput | SortOrder
    Reason?: SortOrderInput | SortOrder
  }

  export type InvalidDeviceAccessWhereUniqueInput = Prisma.AtLeast<{
    Id?: number
    AND?: InvalidDeviceAccessWhereInput | InvalidDeviceAccessWhereInput[]
    OR?: InvalidDeviceAccessWhereInput[]
    NOT?: InvalidDeviceAccessWhereInput | InvalidDeviceAccessWhereInput[]
    AccessDateTime?: DateTimeFilter<"InvalidDeviceAccess"> | Date | string
    DeviceId?: StringNullableFilter<"InvalidDeviceAccess"> | string | null
    MobileNumber?: StringNullableFilter<"InvalidDeviceAccess"> | string | null
    Reason?: StringNullableFilter<"InvalidDeviceAccess"> | string | null
  }, "Id">

  export type InvalidDeviceAccessOrderByWithAggregationInput = {
    Id?: SortOrder
    AccessDateTime?: SortOrder
    DeviceId?: SortOrderInput | SortOrder
    MobileNumber?: SortOrderInput | SortOrder
    Reason?: SortOrderInput | SortOrder
    _count?: InvalidDeviceAccessCountOrderByAggregateInput
    _avg?: InvalidDeviceAccessAvgOrderByAggregateInput
    _max?: InvalidDeviceAccessMaxOrderByAggregateInput
    _min?: InvalidDeviceAccessMinOrderByAggregateInput
    _sum?: InvalidDeviceAccessSumOrderByAggregateInput
  }

  export type InvalidDeviceAccessScalarWhereWithAggregatesInput = {
    AND?: InvalidDeviceAccessScalarWhereWithAggregatesInput | InvalidDeviceAccessScalarWhereWithAggregatesInput[]
    OR?: InvalidDeviceAccessScalarWhereWithAggregatesInput[]
    NOT?: InvalidDeviceAccessScalarWhereWithAggregatesInput | InvalidDeviceAccessScalarWhereWithAggregatesInput[]
    Id?: IntWithAggregatesFilter<"InvalidDeviceAccess"> | number
    AccessDateTime?: DateTimeWithAggregatesFilter<"InvalidDeviceAccess"> | Date | string
    DeviceId?: StringNullableWithAggregatesFilter<"InvalidDeviceAccess"> | string | null
    MobileNumber?: StringNullableWithAggregatesFilter<"InvalidDeviceAccess"> | string | null
    Reason?: StringNullableWithAggregatesFilter<"InvalidDeviceAccess"> | string | null
  }

  export type MastercardProvisionedTokensWhereInput = {
    AND?: MastercardProvisionedTokensWhereInput | MastercardProvisionedTokensWhereInput[]
    OR?: MastercardProvisionedTokensWhereInput[]
    NOT?: MastercardProvisionedTokensWhereInput | MastercardProvisionedTokensWhereInput[]
    TokenUniqueReferenceId?: StringFilter<"MastercardProvisionedTokens"> | string
    PhoneNumber?: StringFilter<"MastercardProvisionedTokens"> | string
    DeviceId?: StringNullableFilter<"MastercardProvisionedTokens"> | string | null
    PaymentAccountReference?: StringNullableFilter<"MastercardProvisionedTokens"> | string | null
  }

  export type MastercardProvisionedTokensOrderByWithRelationInput = {
    TokenUniqueReferenceId?: SortOrder
    PhoneNumber?: SortOrder
    DeviceId?: SortOrderInput | SortOrder
    PaymentAccountReference?: SortOrderInput | SortOrder
  }

  export type MastercardProvisionedTokensWhereUniqueInput = Prisma.AtLeast<{
    TokenUniqueReferenceId_PhoneNumber?: MastercardProvisionedTokensTokenUniqueReferenceIdPhoneNumberCompoundUniqueInput
    AND?: MastercardProvisionedTokensWhereInput | MastercardProvisionedTokensWhereInput[]
    OR?: MastercardProvisionedTokensWhereInput[]
    NOT?: MastercardProvisionedTokensWhereInput | MastercardProvisionedTokensWhereInput[]
    TokenUniqueReferenceId?: StringFilter<"MastercardProvisionedTokens"> | string
    PhoneNumber?: StringFilter<"MastercardProvisionedTokens"> | string
    DeviceId?: StringNullableFilter<"MastercardProvisionedTokens"> | string | null
    PaymentAccountReference?: StringNullableFilter<"MastercardProvisionedTokens"> | string | null
  }, "TokenUniqueReferenceId_PhoneNumber">

  export type MastercardProvisionedTokensOrderByWithAggregationInput = {
    TokenUniqueReferenceId?: SortOrder
    PhoneNumber?: SortOrder
    DeviceId?: SortOrderInput | SortOrder
    PaymentAccountReference?: SortOrderInput | SortOrder
    _count?: MastercardProvisionedTokensCountOrderByAggregateInput
    _max?: MastercardProvisionedTokensMaxOrderByAggregateInput
    _min?: MastercardProvisionedTokensMinOrderByAggregateInput
  }

  export type MastercardProvisionedTokensScalarWhereWithAggregatesInput = {
    AND?: MastercardProvisionedTokensScalarWhereWithAggregatesInput | MastercardProvisionedTokensScalarWhereWithAggregatesInput[]
    OR?: MastercardProvisionedTokensScalarWhereWithAggregatesInput[]
    NOT?: MastercardProvisionedTokensScalarWhereWithAggregatesInput | MastercardProvisionedTokensScalarWhereWithAggregatesInput[]
    TokenUniqueReferenceId?: StringWithAggregatesFilter<"MastercardProvisionedTokens"> | string
    PhoneNumber?: StringWithAggregatesFilter<"MastercardProvisionedTokens"> | string
    DeviceId?: StringNullableWithAggregatesFilter<"MastercardProvisionedTokens"> | string | null
    PaymentAccountReference?: StringNullableWithAggregatesFilter<"MastercardProvisionedTokens"> | string | null
  }

  export type PersistedGrantsWhereInput = {
    AND?: PersistedGrantsWhereInput | PersistedGrantsWhereInput[]
    OR?: PersistedGrantsWhereInput[]
    NOT?: PersistedGrantsWhereInput | PersistedGrantsWhereInput[]
    Key?: StringFilter<"PersistedGrants"> | string
    Type?: StringFilter<"PersistedGrants"> | string
    SubjectId?: StringNullableFilter<"PersistedGrants"> | string | null
    ClientId?: StringFilter<"PersistedGrants"> | string
    CreationTime?: DateTimeFilter<"PersistedGrants"> | Date | string
    Expiration?: DateTimeNullableFilter<"PersistedGrants"> | Date | string | null
    Data?: StringFilter<"PersistedGrants"> | string
  }

  export type PersistedGrantsOrderByWithRelationInput = {
    Key?: SortOrder
    Type?: SortOrder
    SubjectId?: SortOrderInput | SortOrder
    ClientId?: SortOrder
    CreationTime?: SortOrder
    Expiration?: SortOrderInput | SortOrder
    Data?: SortOrder
  }

  export type PersistedGrantsWhereUniqueInput = Prisma.AtLeast<{
    Key?: string
    AND?: PersistedGrantsWhereInput | PersistedGrantsWhereInput[]
    OR?: PersistedGrantsWhereInput[]
    NOT?: PersistedGrantsWhereInput | PersistedGrantsWhereInput[]
    Type?: StringFilter<"PersistedGrants"> | string
    SubjectId?: StringNullableFilter<"PersistedGrants"> | string | null
    ClientId?: StringFilter<"PersistedGrants"> | string
    CreationTime?: DateTimeFilter<"PersistedGrants"> | Date | string
    Expiration?: DateTimeNullableFilter<"PersistedGrants"> | Date | string | null
    Data?: StringFilter<"PersistedGrants"> | string
  }, "Key">

  export type PersistedGrantsOrderByWithAggregationInput = {
    Key?: SortOrder
    Type?: SortOrder
    SubjectId?: SortOrderInput | SortOrder
    ClientId?: SortOrder
    CreationTime?: SortOrder
    Expiration?: SortOrderInput | SortOrder
    Data?: SortOrder
    _count?: PersistedGrantsCountOrderByAggregateInput
    _max?: PersistedGrantsMaxOrderByAggregateInput
    _min?: PersistedGrantsMinOrderByAggregateInput
  }

  export type PersistedGrantsScalarWhereWithAggregatesInput = {
    AND?: PersistedGrantsScalarWhereWithAggregatesInput | PersistedGrantsScalarWhereWithAggregatesInput[]
    OR?: PersistedGrantsScalarWhereWithAggregatesInput[]
    NOT?: PersistedGrantsScalarWhereWithAggregatesInput | PersistedGrantsScalarWhereWithAggregatesInput[]
    Key?: StringWithAggregatesFilter<"PersistedGrants"> | string
    Type?: StringWithAggregatesFilter<"PersistedGrants"> | string
    SubjectId?: StringNullableWithAggregatesFilter<"PersistedGrants"> | string | null
    ClientId?: StringWithAggregatesFilter<"PersistedGrants"> | string
    CreationTime?: DateTimeWithAggregatesFilter<"PersistedGrants"> | Date | string
    Expiration?: DateTimeNullableWithAggregatesFilter<"PersistedGrants"> | Date | string | null
    Data?: StringWithAggregatesFilter<"PersistedGrants"> | string
  }

  export type ProvisionedTokenIdsWhereInput = {
    AND?: ProvisionedTokenIdsWhereInput | ProvisionedTokenIdsWhereInput[]
    OR?: ProvisionedTokenIdsWhereInput[]
    NOT?: ProvisionedTokenIdsWhereInput | ProvisionedTokenIdsWhereInput[]
    Id?: IntFilter<"ProvisionedTokenIds"> | number
    ProvisionedTokenId?: StringNullableFilter<"ProvisionedTokenIds"> | string | null
    PanEnrollmentId?: StringNullableFilter<"ProvisionedTokenIds"> | string | null
    TokenReferenceId?: StringNullableFilter<"ProvisionedTokenIds"> | string | null
  }

  export type ProvisionedTokenIdsOrderByWithRelationInput = {
    Id?: SortOrder
    ProvisionedTokenId?: SortOrderInput | SortOrder
    PanEnrollmentId?: SortOrderInput | SortOrder
    TokenReferenceId?: SortOrderInput | SortOrder
  }

  export type ProvisionedTokenIdsWhereUniqueInput = Prisma.AtLeast<{
    Id?: number
    AND?: ProvisionedTokenIdsWhereInput | ProvisionedTokenIdsWhereInput[]
    OR?: ProvisionedTokenIdsWhereInput[]
    NOT?: ProvisionedTokenIdsWhereInput | ProvisionedTokenIdsWhereInput[]
    ProvisionedTokenId?: StringNullableFilter<"ProvisionedTokenIds"> | string | null
    PanEnrollmentId?: StringNullableFilter<"ProvisionedTokenIds"> | string | null
    TokenReferenceId?: StringNullableFilter<"ProvisionedTokenIds"> | string | null
  }, "Id">

  export type ProvisionedTokenIdsOrderByWithAggregationInput = {
    Id?: SortOrder
    ProvisionedTokenId?: SortOrderInput | SortOrder
    PanEnrollmentId?: SortOrderInput | SortOrder
    TokenReferenceId?: SortOrderInput | SortOrder
    _count?: ProvisionedTokenIdsCountOrderByAggregateInput
    _avg?: ProvisionedTokenIdsAvgOrderByAggregateInput
    _max?: ProvisionedTokenIdsMaxOrderByAggregateInput
    _min?: ProvisionedTokenIdsMinOrderByAggregateInput
    _sum?: ProvisionedTokenIdsSumOrderByAggregateInput
  }

  export type ProvisionedTokenIdsScalarWhereWithAggregatesInput = {
    AND?: ProvisionedTokenIdsScalarWhereWithAggregatesInput | ProvisionedTokenIdsScalarWhereWithAggregatesInput[]
    OR?: ProvisionedTokenIdsScalarWhereWithAggregatesInput[]
    NOT?: ProvisionedTokenIdsScalarWhereWithAggregatesInput | ProvisionedTokenIdsScalarWhereWithAggregatesInput[]
    Id?: IntWithAggregatesFilter<"ProvisionedTokenIds"> | number
    ProvisionedTokenId?: StringNullableWithAggregatesFilter<"ProvisionedTokenIds"> | string | null
    PanEnrollmentId?: StringNullableWithAggregatesFilter<"ProvisionedTokenIds"> | string | null
    TokenReferenceId?: StringNullableWithAggregatesFilter<"ProvisionedTokenIds"> | string | null
  }

  export type RegisterLogEntryWhereInput = {
    AND?: RegisterLogEntryWhereInput | RegisterLogEntryWhereInput[]
    OR?: RegisterLogEntryWhereInput[]
    NOT?: RegisterLogEntryWhereInput | RegisterLogEntryWhereInput[]
    Id?: IntFilter<"RegisterLogEntry"> | number
    DeviceId?: StringNullableFilter<"RegisterLogEntry"> | string | null
    MobileNumber?: StringNullableFilter<"RegisterLogEntry"> | string | null
    RegistrationDateTime?: DateTimeFilter<"RegisterLogEntry"> | Date | string
  }

  export type RegisterLogEntryOrderByWithRelationInput = {
    Id?: SortOrder
    DeviceId?: SortOrderInput | SortOrder
    MobileNumber?: SortOrderInput | SortOrder
    RegistrationDateTime?: SortOrder
  }

  export type RegisterLogEntryWhereUniqueInput = Prisma.AtLeast<{
    Id?: number
    AND?: RegisterLogEntryWhereInput | RegisterLogEntryWhereInput[]
    OR?: RegisterLogEntryWhereInput[]
    NOT?: RegisterLogEntryWhereInput | RegisterLogEntryWhereInput[]
    DeviceId?: StringNullableFilter<"RegisterLogEntry"> | string | null
    MobileNumber?: StringNullableFilter<"RegisterLogEntry"> | string | null
    RegistrationDateTime?: DateTimeFilter<"RegisterLogEntry"> | Date | string
  }, "Id">

  export type RegisterLogEntryOrderByWithAggregationInput = {
    Id?: SortOrder
    DeviceId?: SortOrderInput | SortOrder
    MobileNumber?: SortOrderInput | SortOrder
    RegistrationDateTime?: SortOrder
    _count?: RegisterLogEntryCountOrderByAggregateInput
    _avg?: RegisterLogEntryAvgOrderByAggregateInput
    _max?: RegisterLogEntryMaxOrderByAggregateInput
    _min?: RegisterLogEntryMinOrderByAggregateInput
    _sum?: RegisterLogEntrySumOrderByAggregateInput
  }

  export type RegisterLogEntryScalarWhereWithAggregatesInput = {
    AND?: RegisterLogEntryScalarWhereWithAggregatesInput | RegisterLogEntryScalarWhereWithAggregatesInput[]
    OR?: RegisterLogEntryScalarWhereWithAggregatesInput[]
    NOT?: RegisterLogEntryScalarWhereWithAggregatesInput | RegisterLogEntryScalarWhereWithAggregatesInput[]
    Id?: IntWithAggregatesFilter<"RegisterLogEntry"> | number
    DeviceId?: StringNullableWithAggregatesFilter<"RegisterLogEntry"> | string | null
    MobileNumber?: StringNullableWithAggregatesFilter<"RegisterLogEntry"> | string | null
    RegistrationDateTime?: DateTimeWithAggregatesFilter<"RegisterLogEntry"> | Date | string
  }

  export type sysdiagramsWhereInput = {
    AND?: sysdiagramsWhereInput | sysdiagramsWhereInput[]
    OR?: sysdiagramsWhereInput[]
    NOT?: sysdiagramsWhereInput | sysdiagramsWhereInput[]
    name?: StringFilter<"sysdiagrams"> | string
    principal_id?: IntFilter<"sysdiagrams"> | number
    diagram_id?: IntFilter<"sysdiagrams"> | number
    version?: IntNullableFilter<"sysdiagrams"> | number | null
    definition?: BytesNullableFilter<"sysdiagrams"> | Uint8Array | null
  }

  export type sysdiagramsOrderByWithRelationInput = {
    name?: SortOrder
    principal_id?: SortOrder
    diagram_id?: SortOrder
    version?: SortOrderInput | SortOrder
    definition?: SortOrderInput | SortOrder
  }

  export type sysdiagramsWhereUniqueInput = Prisma.AtLeast<{
    diagram_id?: number
    principal_id_name?: sysdiagramsPrincipal_idNameCompoundUniqueInput
    AND?: sysdiagramsWhereInput | sysdiagramsWhereInput[]
    OR?: sysdiagramsWhereInput[]
    NOT?: sysdiagramsWhereInput | sysdiagramsWhereInput[]
    name?: StringFilter<"sysdiagrams"> | string
    principal_id?: IntFilter<"sysdiagrams"> | number
    version?: IntNullableFilter<"sysdiagrams"> | number | null
    definition?: BytesNullableFilter<"sysdiagrams"> | Uint8Array | null
  }, "diagram_id" | "principal_id_name">

  export type sysdiagramsOrderByWithAggregationInput = {
    name?: SortOrder
    principal_id?: SortOrder
    diagram_id?: SortOrder
    version?: SortOrderInput | SortOrder
    definition?: SortOrderInput | SortOrder
    _count?: sysdiagramsCountOrderByAggregateInput
    _avg?: sysdiagramsAvgOrderByAggregateInput
    _max?: sysdiagramsMaxOrderByAggregateInput
    _min?: sysdiagramsMinOrderByAggregateInput
    _sum?: sysdiagramsSumOrderByAggregateInput
  }

  export type sysdiagramsScalarWhereWithAggregatesInput = {
    AND?: sysdiagramsScalarWhereWithAggregatesInput | sysdiagramsScalarWhereWithAggregatesInput[]
    OR?: sysdiagramsScalarWhereWithAggregatesInput[]
    NOT?: sysdiagramsScalarWhereWithAggregatesInput | sysdiagramsScalarWhereWithAggregatesInput[]
    name?: StringWithAggregatesFilter<"sysdiagrams"> | string
    principal_id?: IntWithAggregatesFilter<"sysdiagrams"> | number
    diagram_id?: IntWithAggregatesFilter<"sysdiagrams"> | number
    version?: IntNullableWithAggregatesFilter<"sysdiagrams"> | number | null
    definition?: BytesNullableWithAggregatesFilter<"sysdiagrams"> | Uint8Array | null
  }

  export type TapToPayTransactionLogWhereInput = {
    AND?: TapToPayTransactionLogWhereInput | TapToPayTransactionLogWhereInput[]
    OR?: TapToPayTransactionLogWhereInput[]
    NOT?: TapToPayTransactionLogWhereInput | TapToPayTransactionLogWhereInput[]
    Id?: IntFilter<"TapToPayTransactionLog"> | number
    DeviceId?: StringNullableFilter<"TapToPayTransactionLog"> | string | null
    PhoneNumber?: StringNullableFilter<"TapToPayTransactionLog"> | string | null
    TransactionDate?: DateTimeFilter<"TapToPayTransactionLog"> | Date | string
  }

  export type TapToPayTransactionLogOrderByWithRelationInput = {
    Id?: SortOrder
    DeviceId?: SortOrderInput | SortOrder
    PhoneNumber?: SortOrderInput | SortOrder
    TransactionDate?: SortOrder
  }

  export type TapToPayTransactionLogWhereUniqueInput = Prisma.AtLeast<{
    Id?: number
    AND?: TapToPayTransactionLogWhereInput | TapToPayTransactionLogWhereInput[]
    OR?: TapToPayTransactionLogWhereInput[]
    NOT?: TapToPayTransactionLogWhereInput | TapToPayTransactionLogWhereInput[]
    DeviceId?: StringNullableFilter<"TapToPayTransactionLog"> | string | null
    PhoneNumber?: StringNullableFilter<"TapToPayTransactionLog"> | string | null
    TransactionDate?: DateTimeFilter<"TapToPayTransactionLog"> | Date | string
  }, "Id">

  export type TapToPayTransactionLogOrderByWithAggregationInput = {
    Id?: SortOrder
    DeviceId?: SortOrderInput | SortOrder
    PhoneNumber?: SortOrderInput | SortOrder
    TransactionDate?: SortOrder
    _count?: TapToPayTransactionLogCountOrderByAggregateInput
    _avg?: TapToPayTransactionLogAvgOrderByAggregateInput
    _max?: TapToPayTransactionLogMaxOrderByAggregateInput
    _min?: TapToPayTransactionLogMinOrderByAggregateInput
    _sum?: TapToPayTransactionLogSumOrderByAggregateInput
  }

  export type TapToPayTransactionLogScalarWhereWithAggregatesInput = {
    AND?: TapToPayTransactionLogScalarWhereWithAggregatesInput | TapToPayTransactionLogScalarWhereWithAggregatesInput[]
    OR?: TapToPayTransactionLogScalarWhereWithAggregatesInput[]
    NOT?: TapToPayTransactionLogScalarWhereWithAggregatesInput | TapToPayTransactionLogScalarWhereWithAggregatesInput[]
    Id?: IntWithAggregatesFilter<"TapToPayTransactionLog"> | number
    DeviceId?: StringNullableWithAggregatesFilter<"TapToPayTransactionLog"> | string | null
    PhoneNumber?: StringNullableWithAggregatesFilter<"TapToPayTransactionLog"> | string | null
    TransactionDate?: DateTimeWithAggregatesFilter<"TapToPayTransactionLog"> | Date | string
  }

  export type TokenStatusesWhereInput = {
    AND?: TokenStatusesWhereInput | TokenStatusesWhereInput[]
    OR?: TokenStatusesWhereInput[]
    NOT?: TokenStatusesWhereInput | TokenStatusesWhereInput[]
    ID?: IntFilter<"TokenStatuses"> | number
    Name?: StringNullableFilter<"TokenStatuses"> | string | null
    CardProviderName?: StringNullableFilter<"TokenStatuses"> | string | null
    IsSuspended?: BoolFilter<"TokenStatuses"> | boolean
    IsDeleted?: BoolFilter<"TokenStatuses"> | boolean
    IsActive?: BoolFilter<"TokenStatuses"> | boolean
    IsInactive?: BoolFilter<"TokenStatuses"> | boolean
    VisaProvisionedTokens?: VisaProvisionedTokensListRelationFilter
  }

  export type TokenStatusesOrderByWithRelationInput = {
    ID?: SortOrder
    Name?: SortOrderInput | SortOrder
    CardProviderName?: SortOrderInput | SortOrder
    IsSuspended?: SortOrder
    IsDeleted?: SortOrder
    IsActive?: SortOrder
    IsInactive?: SortOrder
    VisaProvisionedTokens?: VisaProvisionedTokensOrderByRelationAggregateInput
  }

  export type TokenStatusesWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    AND?: TokenStatusesWhereInput | TokenStatusesWhereInput[]
    OR?: TokenStatusesWhereInput[]
    NOT?: TokenStatusesWhereInput | TokenStatusesWhereInput[]
    Name?: StringNullableFilter<"TokenStatuses"> | string | null
    CardProviderName?: StringNullableFilter<"TokenStatuses"> | string | null
    IsSuspended?: BoolFilter<"TokenStatuses"> | boolean
    IsDeleted?: BoolFilter<"TokenStatuses"> | boolean
    IsActive?: BoolFilter<"TokenStatuses"> | boolean
    IsInactive?: BoolFilter<"TokenStatuses"> | boolean
    VisaProvisionedTokens?: VisaProvisionedTokensListRelationFilter
  }, "ID">

  export type TokenStatusesOrderByWithAggregationInput = {
    ID?: SortOrder
    Name?: SortOrderInput | SortOrder
    CardProviderName?: SortOrderInput | SortOrder
    IsSuspended?: SortOrder
    IsDeleted?: SortOrder
    IsActive?: SortOrder
    IsInactive?: SortOrder
    _count?: TokenStatusesCountOrderByAggregateInput
    _avg?: TokenStatusesAvgOrderByAggregateInput
    _max?: TokenStatusesMaxOrderByAggregateInput
    _min?: TokenStatusesMinOrderByAggregateInput
    _sum?: TokenStatusesSumOrderByAggregateInput
  }

  export type TokenStatusesScalarWhereWithAggregatesInput = {
    AND?: TokenStatusesScalarWhereWithAggregatesInput | TokenStatusesScalarWhereWithAggregatesInput[]
    OR?: TokenStatusesScalarWhereWithAggregatesInput[]
    NOT?: TokenStatusesScalarWhereWithAggregatesInput | TokenStatusesScalarWhereWithAggregatesInput[]
    ID?: IntWithAggregatesFilter<"TokenStatuses"> | number
    Name?: StringNullableWithAggregatesFilter<"TokenStatuses"> | string | null
    CardProviderName?: StringNullableWithAggregatesFilter<"TokenStatuses"> | string | null
    IsSuspended?: BoolWithAggregatesFilter<"TokenStatuses"> | boolean
    IsDeleted?: BoolWithAggregatesFilter<"TokenStatuses"> | boolean
    IsActive?: BoolWithAggregatesFilter<"TokenStatuses"> | boolean
    IsInactive?: BoolWithAggregatesFilter<"TokenStatuses"> | boolean
  }

  export type VisaProvisionedTokensWhereInput = {
    AND?: VisaProvisionedTokensWhereInput | VisaProvisionedTokensWhereInput[]
    OR?: VisaProvisionedTokensWhereInput[]
    NOT?: VisaProvisionedTokensWhereInput | VisaProvisionedTokensWhereInput[]
    ProvisionedTokenId?: StringFilter<"VisaProvisionedTokens"> | string
    PhoneNumber?: StringFilter<"VisaProvisionedTokens"> | string
    DeviceId?: StringNullableFilter<"VisaProvisionedTokens"> | string | null
    StatusId?: IntNullableFilter<"VisaProvisionedTokens"> | number | null
    PanEnrollmentId?: StringNullableFilter<"VisaProvisionedTokens"> | string | null
    TokenStatuses?: XOR<TokenStatusesNullableScalarRelationFilter, TokenStatusesWhereInput> | null
  }

  export type VisaProvisionedTokensOrderByWithRelationInput = {
    ProvisionedTokenId?: SortOrder
    PhoneNumber?: SortOrder
    DeviceId?: SortOrderInput | SortOrder
    StatusId?: SortOrderInput | SortOrder
    PanEnrollmentId?: SortOrderInput | SortOrder
    TokenStatuses?: TokenStatusesOrderByWithRelationInput
  }

  export type VisaProvisionedTokensWhereUniqueInput = Prisma.AtLeast<{
    ProvisionedTokenId_PhoneNumber?: VisaProvisionedTokensProvisionedTokenIdPhoneNumberCompoundUniqueInput
    AND?: VisaProvisionedTokensWhereInput | VisaProvisionedTokensWhereInput[]
    OR?: VisaProvisionedTokensWhereInput[]
    NOT?: VisaProvisionedTokensWhereInput | VisaProvisionedTokensWhereInput[]
    ProvisionedTokenId?: StringFilter<"VisaProvisionedTokens"> | string
    PhoneNumber?: StringFilter<"VisaProvisionedTokens"> | string
    DeviceId?: StringNullableFilter<"VisaProvisionedTokens"> | string | null
    StatusId?: IntNullableFilter<"VisaProvisionedTokens"> | number | null
    PanEnrollmentId?: StringNullableFilter<"VisaProvisionedTokens"> | string | null
    TokenStatuses?: XOR<TokenStatusesNullableScalarRelationFilter, TokenStatusesWhereInput> | null
  }, "ProvisionedTokenId_PhoneNumber">

  export type VisaProvisionedTokensOrderByWithAggregationInput = {
    ProvisionedTokenId?: SortOrder
    PhoneNumber?: SortOrder
    DeviceId?: SortOrderInput | SortOrder
    StatusId?: SortOrderInput | SortOrder
    PanEnrollmentId?: SortOrderInput | SortOrder
    _count?: VisaProvisionedTokensCountOrderByAggregateInput
    _avg?: VisaProvisionedTokensAvgOrderByAggregateInput
    _max?: VisaProvisionedTokensMaxOrderByAggregateInput
    _min?: VisaProvisionedTokensMinOrderByAggregateInput
    _sum?: VisaProvisionedTokensSumOrderByAggregateInput
  }

  export type VisaProvisionedTokensScalarWhereWithAggregatesInput = {
    AND?: VisaProvisionedTokensScalarWhereWithAggregatesInput | VisaProvisionedTokensScalarWhereWithAggregatesInput[]
    OR?: VisaProvisionedTokensScalarWhereWithAggregatesInput[]
    NOT?: VisaProvisionedTokensScalarWhereWithAggregatesInput | VisaProvisionedTokensScalarWhereWithAggregatesInput[]
    ProvisionedTokenId?: StringWithAggregatesFilter<"VisaProvisionedTokens"> | string
    PhoneNumber?: StringWithAggregatesFilter<"VisaProvisionedTokens"> | string
    DeviceId?: StringNullableWithAggregatesFilter<"VisaProvisionedTokens"> | string | null
    StatusId?: IntNullableWithAggregatesFilter<"VisaProvisionedTokens"> | number | null
    PanEnrollmentId?: StringNullableWithAggregatesFilter<"VisaProvisionedTokens"> | string | null
  }

  export type VisaRequestsWhereInput = {
    AND?: VisaRequestsWhereInput | VisaRequestsWhereInput[]
    OR?: VisaRequestsWhereInput[]
    NOT?: VisaRequestsWhereInput | VisaRequestsWhereInput[]
    Id?: StringFilter<"VisaRequests"> | string
    CreatedDate?: DateTimeFilter<"VisaRequests"> | Date | string
    UpdatedDate?: DateTimeFilter<"VisaRequests"> | Date | string
    RequestUrl?: StringNullableFilter<"VisaRequests"> | string | null
    RequestMethod?: StringNullableFilter<"VisaRequests"> | string | null
    RequestHeaders?: StringNullableFilter<"VisaRequests"> | string | null
    RequestBody?: StringNullableFilter<"VisaRequests"> | string | null
    ResponseHeaders?: StringNullableFilter<"VisaRequests"> | string | null
    ResponseBody?: StringNullableFilter<"VisaRequests"> | string | null
    ResponseCode?: StringNullableFilter<"VisaRequests"> | string | null
    RequestIp?: StringNullableFilter<"VisaRequests"> | string | null
    RequestQuery?: StringNullableFilter<"VisaRequests"> | string | null
  }

  export type VisaRequestsOrderByWithRelationInput = {
    Id?: SortOrder
    CreatedDate?: SortOrder
    UpdatedDate?: SortOrder
    RequestUrl?: SortOrderInput | SortOrder
    RequestMethod?: SortOrderInput | SortOrder
    RequestHeaders?: SortOrderInput | SortOrder
    RequestBody?: SortOrderInput | SortOrder
    ResponseHeaders?: SortOrderInput | SortOrder
    ResponseBody?: SortOrderInput | SortOrder
    ResponseCode?: SortOrderInput | SortOrder
    RequestIp?: SortOrderInput | SortOrder
    RequestQuery?: SortOrderInput | SortOrder
  }

  export type VisaRequestsWhereUniqueInput = Prisma.AtLeast<{
    Id?: string
    AND?: VisaRequestsWhereInput | VisaRequestsWhereInput[]
    OR?: VisaRequestsWhereInput[]
    NOT?: VisaRequestsWhereInput | VisaRequestsWhereInput[]
    CreatedDate?: DateTimeFilter<"VisaRequests"> | Date | string
    UpdatedDate?: DateTimeFilter<"VisaRequests"> | Date | string
    RequestUrl?: StringNullableFilter<"VisaRequests"> | string | null
    RequestMethod?: StringNullableFilter<"VisaRequests"> | string | null
    RequestHeaders?: StringNullableFilter<"VisaRequests"> | string | null
    RequestBody?: StringNullableFilter<"VisaRequests"> | string | null
    ResponseHeaders?: StringNullableFilter<"VisaRequests"> | string | null
    ResponseBody?: StringNullableFilter<"VisaRequests"> | string | null
    ResponseCode?: StringNullableFilter<"VisaRequests"> | string | null
    RequestIp?: StringNullableFilter<"VisaRequests"> | string | null
    RequestQuery?: StringNullableFilter<"VisaRequests"> | string | null
  }, "Id">

  export type VisaRequestsOrderByWithAggregationInput = {
    Id?: SortOrder
    CreatedDate?: SortOrder
    UpdatedDate?: SortOrder
    RequestUrl?: SortOrderInput | SortOrder
    RequestMethod?: SortOrderInput | SortOrder
    RequestHeaders?: SortOrderInput | SortOrder
    RequestBody?: SortOrderInput | SortOrder
    ResponseHeaders?: SortOrderInput | SortOrder
    ResponseBody?: SortOrderInput | SortOrder
    ResponseCode?: SortOrderInput | SortOrder
    RequestIp?: SortOrderInput | SortOrder
    RequestQuery?: SortOrderInput | SortOrder
    _count?: VisaRequestsCountOrderByAggregateInput
    _max?: VisaRequestsMaxOrderByAggregateInput
    _min?: VisaRequestsMinOrderByAggregateInput
  }

  export type VisaRequestsScalarWhereWithAggregatesInput = {
    AND?: VisaRequestsScalarWhereWithAggregatesInput | VisaRequestsScalarWhereWithAggregatesInput[]
    OR?: VisaRequestsScalarWhereWithAggregatesInput[]
    NOT?: VisaRequestsScalarWhereWithAggregatesInput | VisaRequestsScalarWhereWithAggregatesInput[]
    Id?: StringWithAggregatesFilter<"VisaRequests"> | string
    CreatedDate?: DateTimeWithAggregatesFilter<"VisaRequests"> | Date | string
    UpdatedDate?: DateTimeWithAggregatesFilter<"VisaRequests"> | Date | string
    RequestUrl?: StringNullableWithAggregatesFilter<"VisaRequests"> | string | null
    RequestMethod?: StringNullableWithAggregatesFilter<"VisaRequests"> | string | null
    RequestHeaders?: StringNullableWithAggregatesFilter<"VisaRequests"> | string | null
    RequestBody?: StringNullableWithAggregatesFilter<"VisaRequests"> | string | null
    ResponseHeaders?: StringNullableWithAggregatesFilter<"VisaRequests"> | string | null
    ResponseBody?: StringNullableWithAggregatesFilter<"VisaRequests"> | string | null
    ResponseCode?: StringNullableWithAggregatesFilter<"VisaRequests"> | string | null
    RequestIp?: StringNullableWithAggregatesFilter<"VisaRequests"> | string | null
    RequestQuery?: StringNullableWithAggregatesFilter<"VisaRequests"> | string | null
  }

  export type EFMigrationsHistoryCreateInput = {
    MigrationId: string
    ProductVersion: string
  }

  export type EFMigrationsHistoryUncheckedCreateInput = {
    MigrationId: string
    ProductVersion: string
  }

  export type EFMigrationsHistoryUpdateInput = {
    MigrationId?: StringFieldUpdateOperationsInput | string
    ProductVersion?: StringFieldUpdateOperationsInput | string
  }

  export type EFMigrationsHistoryUncheckedUpdateInput = {
    MigrationId?: StringFieldUpdateOperationsInput | string
    ProductVersion?: StringFieldUpdateOperationsInput | string
  }

  export type EFMigrationsHistoryCreateManyInput = {
    MigrationId: string
    ProductVersion: string
  }

  export type EFMigrationsHistoryUpdateManyMutationInput = {
    MigrationId?: StringFieldUpdateOperationsInput | string
    ProductVersion?: StringFieldUpdateOperationsInput | string
  }

  export type EFMigrationsHistoryUncheckedUpdateManyInput = {
    MigrationId?: StringFieldUpdateOperationsInput | string
    ProductVersion?: StringFieldUpdateOperationsInput | string
  }

  export type AccessLogCreateInput = {
    CreatedDate: Date | string
    UpdatedDate: Date | string
    RequestUrl?: string | null
    RequestMethod?: string | null
    RequestHeaders?: string | null
    RequestBody?: string | null
    ResponseHeaders?: string | null
    ResponseBody?: string | null
    ResponseCode?: string | null
    RequestIp?: string | null
    RequestQuery?: string | null
  }

  export type AccessLogUncheckedCreateInput = {
    Id?: number
    CreatedDate: Date | string
    UpdatedDate: Date | string
    RequestUrl?: string | null
    RequestMethod?: string | null
    RequestHeaders?: string | null
    RequestBody?: string | null
    ResponseHeaders?: string | null
    ResponseBody?: string | null
    ResponseCode?: string | null
    RequestIp?: string | null
    RequestQuery?: string | null
  }

  export type AccessLogUpdateInput = {
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    RequestUrl?: NullableStringFieldUpdateOperationsInput | string | null
    RequestMethod?: NullableStringFieldUpdateOperationsInput | string | null
    RequestHeaders?: NullableStringFieldUpdateOperationsInput | string | null
    RequestBody?: NullableStringFieldUpdateOperationsInput | string | null
    ResponseHeaders?: NullableStringFieldUpdateOperationsInput | string | null
    ResponseBody?: NullableStringFieldUpdateOperationsInput | string | null
    ResponseCode?: NullableStringFieldUpdateOperationsInput | string | null
    RequestIp?: NullableStringFieldUpdateOperationsInput | string | null
    RequestQuery?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccessLogUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    RequestUrl?: NullableStringFieldUpdateOperationsInput | string | null
    RequestMethod?: NullableStringFieldUpdateOperationsInput | string | null
    RequestHeaders?: NullableStringFieldUpdateOperationsInput | string | null
    RequestBody?: NullableStringFieldUpdateOperationsInput | string | null
    ResponseHeaders?: NullableStringFieldUpdateOperationsInput | string | null
    ResponseBody?: NullableStringFieldUpdateOperationsInput | string | null
    ResponseCode?: NullableStringFieldUpdateOperationsInput | string | null
    RequestIp?: NullableStringFieldUpdateOperationsInput | string | null
    RequestQuery?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccessLogCreateManyInput = {
    CreatedDate: Date | string
    UpdatedDate: Date | string
    RequestUrl?: string | null
    RequestMethod?: string | null
    RequestHeaders?: string | null
    RequestBody?: string | null
    ResponseHeaders?: string | null
    ResponseBody?: string | null
    ResponseCode?: string | null
    RequestIp?: string | null
    RequestQuery?: string | null
  }

  export type AccessLogUpdateManyMutationInput = {
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    RequestUrl?: NullableStringFieldUpdateOperationsInput | string | null
    RequestMethod?: NullableStringFieldUpdateOperationsInput | string | null
    RequestHeaders?: NullableStringFieldUpdateOperationsInput | string | null
    RequestBody?: NullableStringFieldUpdateOperationsInput | string | null
    ResponseHeaders?: NullableStringFieldUpdateOperationsInput | string | null
    ResponseBody?: NullableStringFieldUpdateOperationsInput | string | null
    ResponseCode?: NullableStringFieldUpdateOperationsInput | string | null
    RequestIp?: NullableStringFieldUpdateOperationsInput | string | null
    RequestQuery?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccessLogUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    RequestUrl?: NullableStringFieldUpdateOperationsInput | string | null
    RequestMethod?: NullableStringFieldUpdateOperationsInput | string | null
    RequestHeaders?: NullableStringFieldUpdateOperationsInput | string | null
    RequestBody?: NullableStringFieldUpdateOperationsInput | string | null
    ResponseHeaders?: NullableStringFieldUpdateOperationsInput | string | null
    ResponseBody?: NullableStringFieldUpdateOperationsInput | string | null
    ResponseCode?: NullableStringFieldUpdateOperationsInput | string | null
    RequestIp?: NullableStringFieldUpdateOperationsInput | string | null
    RequestQuery?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AppSurveyCreateInput = {
    Rating: number
    PhoneNumber?: string | null
    AccomplishedDate: Date | string
  }

  export type AppSurveyUncheckedCreateInput = {
    Id?: number
    Rating: number
    PhoneNumber?: string | null
    AccomplishedDate: Date | string
  }

  export type AppSurveyUpdateInput = {
    Rating?: IntFieldUpdateOperationsInput | number
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    AccomplishedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppSurveyUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Rating?: IntFieldUpdateOperationsInput | number
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    AccomplishedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppSurveyCreateManyInput = {
    Rating: number
    PhoneNumber?: string | null
    AccomplishedDate: Date | string
  }

  export type AppSurveyUpdateManyMutationInput = {
    Rating?: IntFieldUpdateOperationsInput | number
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    AccomplishedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppSurveyUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Rating?: IntFieldUpdateOperationsInput | number
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    AccomplishedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AspNetRoleClaimsCreateInput = {
    ClaimType?: string | null
    ClaimValue?: string | null
    AspNetRoles: AspNetRolesCreateNestedOneWithoutAspNetRoleClaimsInput
  }

  export type AspNetRoleClaimsUncheckedCreateInput = {
    Id?: number
    RoleId: string
    ClaimType?: string | null
    ClaimValue?: string | null
  }

  export type AspNetRoleClaimsUpdateInput = {
    ClaimType?: NullableStringFieldUpdateOperationsInput | string | null
    ClaimValue?: NullableStringFieldUpdateOperationsInput | string | null
    AspNetRoles?: AspNetRolesUpdateOneRequiredWithoutAspNetRoleClaimsNestedInput
  }

  export type AspNetRoleClaimsUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    RoleId?: StringFieldUpdateOperationsInput | string
    ClaimType?: NullableStringFieldUpdateOperationsInput | string | null
    ClaimValue?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AspNetRoleClaimsCreateManyInput = {
    RoleId: string
    ClaimType?: string | null
    ClaimValue?: string | null
  }

  export type AspNetRoleClaimsUpdateManyMutationInput = {
    ClaimType?: NullableStringFieldUpdateOperationsInput | string | null
    ClaimValue?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AspNetRoleClaimsUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    RoleId?: StringFieldUpdateOperationsInput | string
    ClaimType?: NullableStringFieldUpdateOperationsInput | string | null
    ClaimValue?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AspNetRolesCreateInput = {
    Id: string
    Name?: string | null
    NormalizedName?: string | null
    ConcurrencyStamp?: string | null
    AspNetRoleClaims?: AspNetRoleClaimsCreateNestedManyWithoutAspNetRolesInput
    AspNetUserRoles?: AspNetUserRolesCreateNestedManyWithoutAspNetRolesInput
  }

  export type AspNetRolesUncheckedCreateInput = {
    Id: string
    Name?: string | null
    NormalizedName?: string | null
    ConcurrencyStamp?: string | null
    AspNetRoleClaims?: AspNetRoleClaimsUncheckedCreateNestedManyWithoutAspNetRolesInput
    AspNetUserRoles?: AspNetUserRolesUncheckedCreateNestedManyWithoutAspNetRolesInput
  }

  export type AspNetRolesUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedName?: NullableStringFieldUpdateOperationsInput | string | null
    ConcurrencyStamp?: NullableStringFieldUpdateOperationsInput | string | null
    AspNetRoleClaims?: AspNetRoleClaimsUpdateManyWithoutAspNetRolesNestedInput
    AspNetUserRoles?: AspNetUserRolesUpdateManyWithoutAspNetRolesNestedInput
  }

  export type AspNetRolesUncheckedUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedName?: NullableStringFieldUpdateOperationsInput | string | null
    ConcurrencyStamp?: NullableStringFieldUpdateOperationsInput | string | null
    AspNetRoleClaims?: AspNetRoleClaimsUncheckedUpdateManyWithoutAspNetRolesNestedInput
    AspNetUserRoles?: AspNetUserRolesUncheckedUpdateManyWithoutAspNetRolesNestedInput
  }

  export type AspNetRolesCreateManyInput = {
    Id: string
    Name?: string | null
    NormalizedName?: string | null
    ConcurrencyStamp?: string | null
  }

  export type AspNetRolesUpdateManyMutationInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedName?: NullableStringFieldUpdateOperationsInput | string | null
    ConcurrencyStamp?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AspNetRolesUncheckedUpdateManyInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedName?: NullableStringFieldUpdateOperationsInput | string | null
    ConcurrencyStamp?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AspNetUserClaimsCreateInput = {
    ClaimType?: string | null
    ClaimValue?: string | null
    AspNetUsers: AspNetUsersCreateNestedOneWithoutAspNetUserClaimsInput
  }

  export type AspNetUserClaimsUncheckedCreateInput = {
    Id?: number
    UserId: string
    ClaimType?: string | null
    ClaimValue?: string | null
  }

  export type AspNetUserClaimsUpdateInput = {
    ClaimType?: NullableStringFieldUpdateOperationsInput | string | null
    ClaimValue?: NullableStringFieldUpdateOperationsInput | string | null
    AspNetUsers?: AspNetUsersUpdateOneRequiredWithoutAspNetUserClaimsNestedInput
  }

  export type AspNetUserClaimsUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    UserId?: StringFieldUpdateOperationsInput | string
    ClaimType?: NullableStringFieldUpdateOperationsInput | string | null
    ClaimValue?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AspNetUserClaimsCreateManyInput = {
    UserId: string
    ClaimType?: string | null
    ClaimValue?: string | null
  }

  export type AspNetUserClaimsUpdateManyMutationInput = {
    ClaimType?: NullableStringFieldUpdateOperationsInput | string | null
    ClaimValue?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AspNetUserClaimsUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    UserId?: StringFieldUpdateOperationsInput | string
    ClaimType?: NullableStringFieldUpdateOperationsInput | string | null
    ClaimValue?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AspNetUserLoginsCreateInput = {
    LoginProvider: string
    ProviderKey: string
    ProviderDisplayName?: string | null
    AspNetUsers: AspNetUsersCreateNestedOneWithoutAspNetUserLoginsInput
  }

  export type AspNetUserLoginsUncheckedCreateInput = {
    LoginProvider: string
    ProviderKey: string
    ProviderDisplayName?: string | null
    UserId: string
  }

  export type AspNetUserLoginsUpdateInput = {
    LoginProvider?: StringFieldUpdateOperationsInput | string
    ProviderKey?: StringFieldUpdateOperationsInput | string
    ProviderDisplayName?: NullableStringFieldUpdateOperationsInput | string | null
    AspNetUsers?: AspNetUsersUpdateOneRequiredWithoutAspNetUserLoginsNestedInput
  }

  export type AspNetUserLoginsUncheckedUpdateInput = {
    LoginProvider?: StringFieldUpdateOperationsInput | string
    ProviderKey?: StringFieldUpdateOperationsInput | string
    ProviderDisplayName?: NullableStringFieldUpdateOperationsInput | string | null
    UserId?: StringFieldUpdateOperationsInput | string
  }

  export type AspNetUserLoginsCreateManyInput = {
    LoginProvider: string
    ProviderKey: string
    ProviderDisplayName?: string | null
    UserId: string
  }

  export type AspNetUserLoginsUpdateManyMutationInput = {
    LoginProvider?: StringFieldUpdateOperationsInput | string
    ProviderKey?: StringFieldUpdateOperationsInput | string
    ProviderDisplayName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AspNetUserLoginsUncheckedUpdateManyInput = {
    LoginProvider?: StringFieldUpdateOperationsInput | string
    ProviderKey?: StringFieldUpdateOperationsInput | string
    ProviderDisplayName?: NullableStringFieldUpdateOperationsInput | string | null
    UserId?: StringFieldUpdateOperationsInput | string
  }

  export type AspNetUserRolesCreateInput = {
    AspNetRoles: AspNetRolesCreateNestedOneWithoutAspNetUserRolesInput
    AspNetUsers: AspNetUsersCreateNestedOneWithoutAspNetUserRolesInput
  }

  export type AspNetUserRolesUncheckedCreateInput = {
    UserId: string
    RoleId: string
  }

  export type AspNetUserRolesUpdateInput = {
    AspNetRoles?: AspNetRolesUpdateOneRequiredWithoutAspNetUserRolesNestedInput
    AspNetUsers?: AspNetUsersUpdateOneRequiredWithoutAspNetUserRolesNestedInput
  }

  export type AspNetUserRolesUncheckedUpdateInput = {
    UserId?: StringFieldUpdateOperationsInput | string
    RoleId?: StringFieldUpdateOperationsInput | string
  }

  export type AspNetUserRolesCreateManyInput = {
    UserId: string
    RoleId: string
  }

  export type AspNetUserRolesUpdateManyMutationInput = {

  }

  export type AspNetUserRolesUncheckedUpdateManyInput = {
    UserId?: StringFieldUpdateOperationsInput | string
    RoleId?: StringFieldUpdateOperationsInput | string
  }

  export type AspNetUsersCreateInput = {
    Id: string
    UserName?: string | null
    NormalizedUserName?: string | null
    Email?: string | null
    NormalizedEmail?: string | null
    EmailConfirmed: boolean
    PasswordHash?: string | null
    SecurityStamp?: string | null
    ConcurrencyStamp?: string | null
    PhoneNumber?: string | null
    PhoneNumberConfirmed: boolean
    TwoFactorEnabled: boolean
    LockoutEnd?: Date | string | null
    LockoutEnabled: boolean
    AccessFailedCount: number
    PasswordValidUntil: Date | string
    DeviceId?: string | null
    FcmToken?: string | null
    FullName?: string | null
    AspNetUserClaims?: AspNetUserClaimsCreateNestedManyWithoutAspNetUsersInput
    AspNetUserLogins?: AspNetUserLoginsCreateNestedManyWithoutAspNetUsersInput
    AspNetUserRoles?: AspNetUserRolesCreateNestedManyWithoutAspNetUsersInput
    AspNetUserTokens?: AspNetUserTokensCreateNestedManyWithoutAspNetUsersInput
  }

  export type AspNetUsersUncheckedCreateInput = {
    Id: string
    UserName?: string | null
    NormalizedUserName?: string | null
    Email?: string | null
    NormalizedEmail?: string | null
    EmailConfirmed: boolean
    PasswordHash?: string | null
    SecurityStamp?: string | null
    ConcurrencyStamp?: string | null
    PhoneNumber?: string | null
    PhoneNumberConfirmed: boolean
    TwoFactorEnabled: boolean
    LockoutEnd?: Date | string | null
    LockoutEnabled: boolean
    AccessFailedCount: number
    PasswordValidUntil: Date | string
    DeviceId?: string | null
    FcmToken?: string | null
    FullName?: string | null
    AspNetUserClaims?: AspNetUserClaimsUncheckedCreateNestedManyWithoutAspNetUsersInput
    AspNetUserLogins?: AspNetUserLoginsUncheckedCreateNestedManyWithoutAspNetUsersInput
    AspNetUserRoles?: AspNetUserRolesUncheckedCreateNestedManyWithoutAspNetUsersInput
    AspNetUserTokens?: AspNetUserTokensUncheckedCreateNestedManyWithoutAspNetUsersInput
  }

  export type AspNetUsersUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    UserName?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedUserName?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    EmailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    PasswordHash?: NullableStringFieldUpdateOperationsInput | string | null
    SecurityStamp?: NullableStringFieldUpdateOperationsInput | string | null
    ConcurrencyStamp?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumberConfirmed?: BoolFieldUpdateOperationsInput | boolean
    TwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    LockoutEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LockoutEnabled?: BoolFieldUpdateOperationsInput | boolean
    AccessFailedCount?: IntFieldUpdateOperationsInput | number
    PasswordValidUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    DeviceId?: NullableStringFieldUpdateOperationsInput | string | null
    FcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    FullName?: NullableStringFieldUpdateOperationsInput | string | null
    AspNetUserClaims?: AspNetUserClaimsUpdateManyWithoutAspNetUsersNestedInput
    AspNetUserLogins?: AspNetUserLoginsUpdateManyWithoutAspNetUsersNestedInput
    AspNetUserRoles?: AspNetUserRolesUpdateManyWithoutAspNetUsersNestedInput
    AspNetUserTokens?: AspNetUserTokensUpdateManyWithoutAspNetUsersNestedInput
  }

  export type AspNetUsersUncheckedUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    UserName?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedUserName?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    EmailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    PasswordHash?: NullableStringFieldUpdateOperationsInput | string | null
    SecurityStamp?: NullableStringFieldUpdateOperationsInput | string | null
    ConcurrencyStamp?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumberConfirmed?: BoolFieldUpdateOperationsInput | boolean
    TwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    LockoutEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LockoutEnabled?: BoolFieldUpdateOperationsInput | boolean
    AccessFailedCount?: IntFieldUpdateOperationsInput | number
    PasswordValidUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    DeviceId?: NullableStringFieldUpdateOperationsInput | string | null
    FcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    FullName?: NullableStringFieldUpdateOperationsInput | string | null
    AspNetUserClaims?: AspNetUserClaimsUncheckedUpdateManyWithoutAspNetUsersNestedInput
    AspNetUserLogins?: AspNetUserLoginsUncheckedUpdateManyWithoutAspNetUsersNestedInput
    AspNetUserRoles?: AspNetUserRolesUncheckedUpdateManyWithoutAspNetUsersNestedInput
    AspNetUserTokens?: AspNetUserTokensUncheckedUpdateManyWithoutAspNetUsersNestedInput
  }

  export type AspNetUsersCreateManyInput = {
    Id: string
    UserName?: string | null
    NormalizedUserName?: string | null
    Email?: string | null
    NormalizedEmail?: string | null
    EmailConfirmed: boolean
    PasswordHash?: string | null
    SecurityStamp?: string | null
    ConcurrencyStamp?: string | null
    PhoneNumber?: string | null
    PhoneNumberConfirmed: boolean
    TwoFactorEnabled: boolean
    LockoutEnd?: Date | string | null
    LockoutEnabled: boolean
    AccessFailedCount: number
    PasswordValidUntil: Date | string
    DeviceId?: string | null
    FcmToken?: string | null
    FullName?: string | null
  }

  export type AspNetUsersUpdateManyMutationInput = {
    Id?: StringFieldUpdateOperationsInput | string
    UserName?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedUserName?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    EmailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    PasswordHash?: NullableStringFieldUpdateOperationsInput | string | null
    SecurityStamp?: NullableStringFieldUpdateOperationsInput | string | null
    ConcurrencyStamp?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumberConfirmed?: BoolFieldUpdateOperationsInput | boolean
    TwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    LockoutEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LockoutEnabled?: BoolFieldUpdateOperationsInput | boolean
    AccessFailedCount?: IntFieldUpdateOperationsInput | number
    PasswordValidUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    DeviceId?: NullableStringFieldUpdateOperationsInput | string | null
    FcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    FullName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AspNetUsersUncheckedUpdateManyInput = {
    Id?: StringFieldUpdateOperationsInput | string
    UserName?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedUserName?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    EmailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    PasswordHash?: NullableStringFieldUpdateOperationsInput | string | null
    SecurityStamp?: NullableStringFieldUpdateOperationsInput | string | null
    ConcurrencyStamp?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumberConfirmed?: BoolFieldUpdateOperationsInput | boolean
    TwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    LockoutEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LockoutEnabled?: BoolFieldUpdateOperationsInput | boolean
    AccessFailedCount?: IntFieldUpdateOperationsInput | number
    PasswordValidUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    DeviceId?: NullableStringFieldUpdateOperationsInput | string | null
    FcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    FullName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AspNetUserTokensCreateInput = {
    LoginProvider: string
    Name: string
    Value?: string | null
    AspNetUsers: AspNetUsersCreateNestedOneWithoutAspNetUserTokensInput
  }

  export type AspNetUserTokensUncheckedCreateInput = {
    UserId: string
    LoginProvider: string
    Name: string
    Value?: string | null
  }

  export type AspNetUserTokensUpdateInput = {
    LoginProvider?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Value?: NullableStringFieldUpdateOperationsInput | string | null
    AspNetUsers?: AspNetUsersUpdateOneRequiredWithoutAspNetUserTokensNestedInput
  }

  export type AspNetUserTokensUncheckedUpdateInput = {
    UserId?: StringFieldUpdateOperationsInput | string
    LoginProvider?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AspNetUserTokensCreateManyInput = {
    UserId: string
    LoginProvider: string
    Name: string
    Value?: string | null
  }

  export type AspNetUserTokensUpdateManyMutationInput = {
    LoginProvider?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AspNetUserTokensUncheckedUpdateManyInput = {
    UserId?: StringFieldUpdateOperationsInput | string
    LoginProvider?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CardReplacementRequestsCreateInput = {
    RequestID: string
    CreatedDate: Date | string
    UpdatedDate: Date | string
    PhoneNumber?: string | null
    OldFourDigits?: string | null
    NewFourDigits?: string | null
    IsCompleted: boolean
    DeviceId?: string | null
  }

  export type CardReplacementRequestsUncheckedCreateInput = {
    RequestID: string
    CreatedDate: Date | string
    UpdatedDate: Date | string
    PhoneNumber?: string | null
    OldFourDigits?: string | null
    NewFourDigits?: string | null
    IsCompleted: boolean
    DeviceId?: string | null
  }

  export type CardReplacementRequestsUpdateInput = {
    RequestID?: StringFieldUpdateOperationsInput | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    OldFourDigits?: NullableStringFieldUpdateOperationsInput | string | null
    NewFourDigits?: NullableStringFieldUpdateOperationsInput | string | null
    IsCompleted?: BoolFieldUpdateOperationsInput | boolean
    DeviceId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CardReplacementRequestsUncheckedUpdateInput = {
    RequestID?: StringFieldUpdateOperationsInput | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    OldFourDigits?: NullableStringFieldUpdateOperationsInput | string | null
    NewFourDigits?: NullableStringFieldUpdateOperationsInput | string | null
    IsCompleted?: BoolFieldUpdateOperationsInput | boolean
    DeviceId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CardReplacementRequestsCreateManyInput = {
    RequestID: string
    CreatedDate: Date | string
    UpdatedDate: Date | string
    PhoneNumber?: string | null
    OldFourDigits?: string | null
    NewFourDigits?: string | null
    IsCompleted: boolean
    DeviceId?: string | null
  }

  export type CardReplacementRequestsUpdateManyMutationInput = {
    RequestID?: StringFieldUpdateOperationsInput | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    OldFourDigits?: NullableStringFieldUpdateOperationsInput | string | null
    NewFourDigits?: NullableStringFieldUpdateOperationsInput | string | null
    IsCompleted?: BoolFieldUpdateOperationsInput | boolean
    DeviceId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CardReplacementRequestsUncheckedUpdateManyInput = {
    RequestID?: StringFieldUpdateOperationsInput | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    OldFourDigits?: NullableStringFieldUpdateOperationsInput | string | null
    NewFourDigits?: NullableStringFieldUpdateOperationsInput | string | null
    IsCompleted?: BoolFieldUpdateOperationsInput | boolean
    DeviceId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DetractorsFeedbackCreateInput = {
    Rating: number
    PhoneNumber?: string | null
    Feedback?: string | null
    AccomplishedDate: Date | string
  }

  export type DetractorsFeedbackUncheckedCreateInput = {
    Id?: number
    Rating: number
    PhoneNumber?: string | null
    Feedback?: string | null
    AccomplishedDate: Date | string
  }

  export type DetractorsFeedbackUpdateInput = {
    Rating?: IntFieldUpdateOperationsInput | number
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    Feedback?: NullableStringFieldUpdateOperationsInput | string | null
    AccomplishedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DetractorsFeedbackUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Rating?: IntFieldUpdateOperationsInput | number
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    Feedback?: NullableStringFieldUpdateOperationsInput | string | null
    AccomplishedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DetractorsFeedbackCreateManyInput = {
    Rating: number
    PhoneNumber?: string | null
    Feedback?: string | null
    AccomplishedDate: Date | string
  }

  export type DetractorsFeedbackUpdateManyMutationInput = {
    Rating?: IntFieldUpdateOperationsInput | number
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    Feedback?: NullableStringFieldUpdateOperationsInput | string | null
    AccomplishedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DetractorsFeedbackUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Rating?: IntFieldUpdateOperationsInput | number
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    Feedback?: NullableStringFieldUpdateOperationsInput | string | null
    AccomplishedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceAccessLogCreateInput = {
    AccessDateTime: Date | string
    DeviceId?: string | null
    MobileNumber?: string | null
    FullName?: string | null
  }

  export type DeviceAccessLogUncheckedCreateInput = {
    Id?: number
    AccessDateTime: Date | string
    DeviceId?: string | null
    MobileNumber?: string | null
    FullName?: string | null
  }

  export type DeviceAccessLogUpdateInput = {
    AccessDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    DeviceId?: NullableStringFieldUpdateOperationsInput | string | null
    MobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    FullName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DeviceAccessLogUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    AccessDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    DeviceId?: NullableStringFieldUpdateOperationsInput | string | null
    MobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    FullName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DeviceAccessLogCreateManyInput = {
    AccessDateTime: Date | string
    DeviceId?: string | null
    MobileNumber?: string | null
    FullName?: string | null
  }

  export type DeviceAccessLogUpdateManyMutationInput = {
    AccessDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    DeviceId?: NullableStringFieldUpdateOperationsInput | string | null
    MobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    FullName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DeviceAccessLogUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    AccessDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    DeviceId?: NullableStringFieldUpdateOperationsInput | string | null
    MobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    FullName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DeviceCodesCreateInput = {
    UserCode: string
    DeviceCode: string
    SubjectId?: string | null
    ClientId: string
    CreationTime: Date | string
    Expiration: Date | string
    Data: string
  }

  export type DeviceCodesUncheckedCreateInput = {
    UserCode: string
    DeviceCode: string
    SubjectId?: string | null
    ClientId: string
    CreationTime: Date | string
    Expiration: Date | string
    Data: string
  }

  export type DeviceCodesUpdateInput = {
    UserCode?: StringFieldUpdateOperationsInput | string
    DeviceCode?: StringFieldUpdateOperationsInput | string
    SubjectId?: NullableStringFieldUpdateOperationsInput | string | null
    ClientId?: StringFieldUpdateOperationsInput | string
    CreationTime?: DateTimeFieldUpdateOperationsInput | Date | string
    Expiration?: DateTimeFieldUpdateOperationsInput | Date | string
    Data?: StringFieldUpdateOperationsInput | string
  }

  export type DeviceCodesUncheckedUpdateInput = {
    UserCode?: StringFieldUpdateOperationsInput | string
    DeviceCode?: StringFieldUpdateOperationsInput | string
    SubjectId?: NullableStringFieldUpdateOperationsInput | string | null
    ClientId?: StringFieldUpdateOperationsInput | string
    CreationTime?: DateTimeFieldUpdateOperationsInput | Date | string
    Expiration?: DateTimeFieldUpdateOperationsInput | Date | string
    Data?: StringFieldUpdateOperationsInput | string
  }

  export type DeviceCodesCreateManyInput = {
    UserCode: string
    DeviceCode: string
    SubjectId?: string | null
    ClientId: string
    CreationTime: Date | string
    Expiration: Date | string
    Data: string
  }

  export type DeviceCodesUpdateManyMutationInput = {
    UserCode?: StringFieldUpdateOperationsInput | string
    DeviceCode?: StringFieldUpdateOperationsInput | string
    SubjectId?: NullableStringFieldUpdateOperationsInput | string | null
    ClientId?: StringFieldUpdateOperationsInput | string
    CreationTime?: DateTimeFieldUpdateOperationsInput | Date | string
    Expiration?: DateTimeFieldUpdateOperationsInput | Date | string
    Data?: StringFieldUpdateOperationsInput | string
  }

  export type DeviceCodesUncheckedUpdateManyInput = {
    UserCode?: StringFieldUpdateOperationsInput | string
    DeviceCode?: StringFieldUpdateOperationsInput | string
    SubjectId?: NullableStringFieldUpdateOperationsInput | string | null
    ClientId?: StringFieldUpdateOperationsInput | string
    CreationTime?: DateTimeFieldUpdateOperationsInput | Date | string
    Expiration?: DateTimeFieldUpdateOperationsInput | Date | string
    Data?: StringFieldUpdateOperationsInput | string
  }

  export type EwPayActivatedCardsCreateInput = {
    UCRN?: string | null
    DateActivated: Date | string
  }

  export type EwPayActivatedCardsUncheckedCreateInput = {
    Id?: number
    UCRN?: string | null
    DateActivated: Date | string
  }

  export type EwPayActivatedCardsUpdateInput = {
    UCRN?: NullableStringFieldUpdateOperationsInput | string | null
    DateActivated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EwPayActivatedCardsUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    UCRN?: NullableStringFieldUpdateOperationsInput | string | null
    DateActivated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EwPayActivatedCardsCreateManyInput = {
    UCRN?: string | null
    DateActivated: Date | string
  }

  export type EwPayActivatedCardsUpdateManyMutationInput = {
    UCRN?: NullableStringFieldUpdateOperationsInput | string | null
    DateActivated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EwPayActivatedCardsUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    UCRN?: NullableStringFieldUpdateOperationsInput | string | null
    DateActivated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EwPayIneligibleCardsCreateInput = {
    UCRN?: string | null
    IsReported: boolean
    IsActivated: boolean
    DateReported: Date | string
  }

  export type EwPayIneligibleCardsUncheckedCreateInput = {
    Id?: number
    UCRN?: string | null
    IsReported: boolean
    IsActivated: boolean
    DateReported: Date | string
  }

  export type EwPayIneligibleCardsUpdateInput = {
    UCRN?: NullableStringFieldUpdateOperationsInput | string | null
    IsReported?: BoolFieldUpdateOperationsInput | boolean
    IsActivated?: BoolFieldUpdateOperationsInput | boolean
    DateReported?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EwPayIneligibleCardsUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    UCRN?: NullableStringFieldUpdateOperationsInput | string | null
    IsReported?: BoolFieldUpdateOperationsInput | boolean
    IsActivated?: BoolFieldUpdateOperationsInput | boolean
    DateReported?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EwPayIneligibleCardsCreateManyInput = {
    UCRN?: string | null
    IsReported: boolean
    IsActivated: boolean
    DateReported: Date | string
  }

  export type EwPayIneligibleCardsUpdateManyMutationInput = {
    UCRN?: NullableStringFieldUpdateOperationsInput | string | null
    IsReported?: BoolFieldUpdateOperationsInput | boolean
    IsActivated?: BoolFieldUpdateOperationsInput | boolean
    DateReported?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EwPayIneligibleCardsUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    UCRN?: NullableStringFieldUpdateOperationsInput | string | null
    IsReported?: BoolFieldUpdateOperationsInput | boolean
    IsActivated?: BoolFieldUpdateOperationsInput | boolean
    DateReported?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvalidDeviceAccessCreateInput = {
    AccessDateTime: Date | string
    DeviceId?: string | null
    MobileNumber?: string | null
    Reason?: string | null
  }

  export type InvalidDeviceAccessUncheckedCreateInput = {
    Id?: number
    AccessDateTime: Date | string
    DeviceId?: string | null
    MobileNumber?: string | null
    Reason?: string | null
  }

  export type InvalidDeviceAccessUpdateInput = {
    AccessDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    DeviceId?: NullableStringFieldUpdateOperationsInput | string | null
    MobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    Reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InvalidDeviceAccessUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    AccessDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    DeviceId?: NullableStringFieldUpdateOperationsInput | string | null
    MobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    Reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InvalidDeviceAccessCreateManyInput = {
    AccessDateTime: Date | string
    DeviceId?: string | null
    MobileNumber?: string | null
    Reason?: string | null
  }

  export type InvalidDeviceAccessUpdateManyMutationInput = {
    AccessDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    DeviceId?: NullableStringFieldUpdateOperationsInput | string | null
    MobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    Reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InvalidDeviceAccessUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    AccessDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    DeviceId?: NullableStringFieldUpdateOperationsInput | string | null
    MobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    Reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MastercardProvisionedTokensCreateInput = {
    TokenUniqueReferenceId: string
    PhoneNumber: string
    DeviceId?: string | null
    PaymentAccountReference?: string | null
  }

  export type MastercardProvisionedTokensUncheckedCreateInput = {
    TokenUniqueReferenceId: string
    PhoneNumber: string
    DeviceId?: string | null
    PaymentAccountReference?: string | null
  }

  export type MastercardProvisionedTokensUpdateInput = {
    TokenUniqueReferenceId?: StringFieldUpdateOperationsInput | string
    PhoneNumber?: StringFieldUpdateOperationsInput | string
    DeviceId?: NullableStringFieldUpdateOperationsInput | string | null
    PaymentAccountReference?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MastercardProvisionedTokensUncheckedUpdateInput = {
    TokenUniqueReferenceId?: StringFieldUpdateOperationsInput | string
    PhoneNumber?: StringFieldUpdateOperationsInput | string
    DeviceId?: NullableStringFieldUpdateOperationsInput | string | null
    PaymentAccountReference?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MastercardProvisionedTokensCreateManyInput = {
    TokenUniqueReferenceId: string
    PhoneNumber: string
    DeviceId?: string | null
    PaymentAccountReference?: string | null
  }

  export type MastercardProvisionedTokensUpdateManyMutationInput = {
    TokenUniqueReferenceId?: StringFieldUpdateOperationsInput | string
    PhoneNumber?: StringFieldUpdateOperationsInput | string
    DeviceId?: NullableStringFieldUpdateOperationsInput | string | null
    PaymentAccountReference?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MastercardProvisionedTokensUncheckedUpdateManyInput = {
    TokenUniqueReferenceId?: StringFieldUpdateOperationsInput | string
    PhoneNumber?: StringFieldUpdateOperationsInput | string
    DeviceId?: NullableStringFieldUpdateOperationsInput | string | null
    PaymentAccountReference?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PersistedGrantsCreateInput = {
    Key: string
    Type: string
    SubjectId?: string | null
    ClientId: string
    CreationTime: Date | string
    Expiration?: Date | string | null
    Data: string
  }

  export type PersistedGrantsUncheckedCreateInput = {
    Key: string
    Type: string
    SubjectId?: string | null
    ClientId: string
    CreationTime: Date | string
    Expiration?: Date | string | null
    Data: string
  }

  export type PersistedGrantsUpdateInput = {
    Key?: StringFieldUpdateOperationsInput | string
    Type?: StringFieldUpdateOperationsInput | string
    SubjectId?: NullableStringFieldUpdateOperationsInput | string | null
    ClientId?: StringFieldUpdateOperationsInput | string
    CreationTime?: DateTimeFieldUpdateOperationsInput | Date | string
    Expiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Data?: StringFieldUpdateOperationsInput | string
  }

  export type PersistedGrantsUncheckedUpdateInput = {
    Key?: StringFieldUpdateOperationsInput | string
    Type?: StringFieldUpdateOperationsInput | string
    SubjectId?: NullableStringFieldUpdateOperationsInput | string | null
    ClientId?: StringFieldUpdateOperationsInput | string
    CreationTime?: DateTimeFieldUpdateOperationsInput | Date | string
    Expiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Data?: StringFieldUpdateOperationsInput | string
  }

  export type PersistedGrantsCreateManyInput = {
    Key: string
    Type: string
    SubjectId?: string | null
    ClientId: string
    CreationTime: Date | string
    Expiration?: Date | string | null
    Data: string
  }

  export type PersistedGrantsUpdateManyMutationInput = {
    Key?: StringFieldUpdateOperationsInput | string
    Type?: StringFieldUpdateOperationsInput | string
    SubjectId?: NullableStringFieldUpdateOperationsInput | string | null
    ClientId?: StringFieldUpdateOperationsInput | string
    CreationTime?: DateTimeFieldUpdateOperationsInput | Date | string
    Expiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Data?: StringFieldUpdateOperationsInput | string
  }

  export type PersistedGrantsUncheckedUpdateManyInput = {
    Key?: StringFieldUpdateOperationsInput | string
    Type?: StringFieldUpdateOperationsInput | string
    SubjectId?: NullableStringFieldUpdateOperationsInput | string | null
    ClientId?: StringFieldUpdateOperationsInput | string
    CreationTime?: DateTimeFieldUpdateOperationsInput | Date | string
    Expiration?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Data?: StringFieldUpdateOperationsInput | string
  }

  export type ProvisionedTokenIdsCreateInput = {
    ProvisionedTokenId?: string | null
    PanEnrollmentId?: string | null
    TokenReferenceId?: string | null
  }

  export type ProvisionedTokenIdsUncheckedCreateInput = {
    Id?: number
    ProvisionedTokenId?: string | null
    PanEnrollmentId?: string | null
    TokenReferenceId?: string | null
  }

  export type ProvisionedTokenIdsUpdateInput = {
    ProvisionedTokenId?: NullableStringFieldUpdateOperationsInput | string | null
    PanEnrollmentId?: NullableStringFieldUpdateOperationsInput | string | null
    TokenReferenceId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProvisionedTokenIdsUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    ProvisionedTokenId?: NullableStringFieldUpdateOperationsInput | string | null
    PanEnrollmentId?: NullableStringFieldUpdateOperationsInput | string | null
    TokenReferenceId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProvisionedTokenIdsCreateManyInput = {
    ProvisionedTokenId?: string | null
    PanEnrollmentId?: string | null
    TokenReferenceId?: string | null
  }

  export type ProvisionedTokenIdsUpdateManyMutationInput = {
    ProvisionedTokenId?: NullableStringFieldUpdateOperationsInput | string | null
    PanEnrollmentId?: NullableStringFieldUpdateOperationsInput | string | null
    TokenReferenceId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProvisionedTokenIdsUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    ProvisionedTokenId?: NullableStringFieldUpdateOperationsInput | string | null
    PanEnrollmentId?: NullableStringFieldUpdateOperationsInput | string | null
    TokenReferenceId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RegisterLogEntryCreateInput = {
    DeviceId?: string | null
    MobileNumber?: string | null
    RegistrationDateTime: Date | string
  }

  export type RegisterLogEntryUncheckedCreateInput = {
    Id?: number
    DeviceId?: string | null
    MobileNumber?: string | null
    RegistrationDateTime: Date | string
  }

  export type RegisterLogEntryUpdateInput = {
    DeviceId?: NullableStringFieldUpdateOperationsInput | string | null
    MobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    RegistrationDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegisterLogEntryUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    DeviceId?: NullableStringFieldUpdateOperationsInput | string | null
    MobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    RegistrationDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegisterLogEntryCreateManyInput = {
    DeviceId?: string | null
    MobileNumber?: string | null
    RegistrationDateTime: Date | string
  }

  export type RegisterLogEntryUpdateManyMutationInput = {
    DeviceId?: NullableStringFieldUpdateOperationsInput | string | null
    MobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    RegistrationDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegisterLogEntryUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    DeviceId?: NullableStringFieldUpdateOperationsInput | string | null
    MobileNumber?: NullableStringFieldUpdateOperationsInput | string | null
    RegistrationDateTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type sysdiagramsCreateInput = {
    name: string
    principal_id: number
    version?: number | null
    definition?: Uint8Array | null
  }

  export type sysdiagramsUncheckedCreateInput = {
    name: string
    principal_id: number
    diagram_id?: number
    version?: number | null
    definition?: Uint8Array | null
  }

  export type sysdiagramsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    principal_id?: IntFieldUpdateOperationsInput | number
    version?: NullableIntFieldUpdateOperationsInput | number | null
    definition?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type sysdiagramsUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    principal_id?: IntFieldUpdateOperationsInput | number
    diagram_id?: IntFieldUpdateOperationsInput | number
    version?: NullableIntFieldUpdateOperationsInput | number | null
    definition?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type sysdiagramsCreateManyInput = {
    name: string
    principal_id: number
    version?: number | null
    definition?: Uint8Array | null
  }

  export type sysdiagramsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    principal_id?: IntFieldUpdateOperationsInput | number
    version?: NullableIntFieldUpdateOperationsInput | number | null
    definition?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type sysdiagramsUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    principal_id?: IntFieldUpdateOperationsInput | number
    diagram_id?: IntFieldUpdateOperationsInput | number
    version?: NullableIntFieldUpdateOperationsInput | number | null
    definition?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type TapToPayTransactionLogCreateInput = {
    DeviceId?: string | null
    PhoneNumber?: string | null
    TransactionDate: Date | string
  }

  export type TapToPayTransactionLogUncheckedCreateInput = {
    Id?: number
    DeviceId?: string | null
    PhoneNumber?: string | null
    TransactionDate: Date | string
  }

  export type TapToPayTransactionLogUpdateInput = {
    DeviceId?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    TransactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TapToPayTransactionLogUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    DeviceId?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    TransactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TapToPayTransactionLogCreateManyInput = {
    DeviceId?: string | null
    PhoneNumber?: string | null
    TransactionDate: Date | string
  }

  export type TapToPayTransactionLogUpdateManyMutationInput = {
    DeviceId?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    TransactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TapToPayTransactionLogUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    DeviceId?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    TransactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TokenStatusesCreateInput = {
    Name?: string | null
    CardProviderName?: string | null
    IsSuspended: boolean
    IsDeleted: boolean
    IsActive: boolean
    IsInactive: boolean
    VisaProvisionedTokens?: VisaProvisionedTokensCreateNestedManyWithoutTokenStatusesInput
  }

  export type TokenStatusesUncheckedCreateInput = {
    ID?: number
    Name?: string | null
    CardProviderName?: string | null
    IsSuspended: boolean
    IsDeleted: boolean
    IsActive: boolean
    IsInactive: boolean
    VisaProvisionedTokens?: VisaProvisionedTokensUncheckedCreateNestedManyWithoutTokenStatusesInput
  }

  export type TokenStatusesUpdateInput = {
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    CardProviderName?: NullableStringFieldUpdateOperationsInput | string | null
    IsSuspended?: BoolFieldUpdateOperationsInput | boolean
    IsDeleted?: BoolFieldUpdateOperationsInput | boolean
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    IsInactive?: BoolFieldUpdateOperationsInput | boolean
    VisaProvisionedTokens?: VisaProvisionedTokensUpdateManyWithoutTokenStatusesNestedInput
  }

  export type TokenStatusesUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    CardProviderName?: NullableStringFieldUpdateOperationsInput | string | null
    IsSuspended?: BoolFieldUpdateOperationsInput | boolean
    IsDeleted?: BoolFieldUpdateOperationsInput | boolean
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    IsInactive?: BoolFieldUpdateOperationsInput | boolean
    VisaProvisionedTokens?: VisaProvisionedTokensUncheckedUpdateManyWithoutTokenStatusesNestedInput
  }

  export type TokenStatusesCreateManyInput = {
    Name?: string | null
    CardProviderName?: string | null
    IsSuspended: boolean
    IsDeleted: boolean
    IsActive: boolean
    IsInactive: boolean
  }

  export type TokenStatusesUpdateManyMutationInput = {
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    CardProviderName?: NullableStringFieldUpdateOperationsInput | string | null
    IsSuspended?: BoolFieldUpdateOperationsInput | boolean
    IsDeleted?: BoolFieldUpdateOperationsInput | boolean
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    IsInactive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TokenStatusesUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    CardProviderName?: NullableStringFieldUpdateOperationsInput | string | null
    IsSuspended?: BoolFieldUpdateOperationsInput | boolean
    IsDeleted?: BoolFieldUpdateOperationsInput | boolean
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    IsInactive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type VisaProvisionedTokensCreateInput = {
    ProvisionedTokenId: string
    PhoneNumber: string
    DeviceId?: string | null
    PanEnrollmentId?: string | null
    TokenStatuses?: TokenStatusesCreateNestedOneWithoutVisaProvisionedTokensInput
  }

  export type VisaProvisionedTokensUncheckedCreateInput = {
    ProvisionedTokenId: string
    PhoneNumber: string
    DeviceId?: string | null
    StatusId?: number | null
    PanEnrollmentId?: string | null
  }

  export type VisaProvisionedTokensUpdateInput = {
    ProvisionedTokenId?: StringFieldUpdateOperationsInput | string
    PhoneNumber?: StringFieldUpdateOperationsInput | string
    DeviceId?: NullableStringFieldUpdateOperationsInput | string | null
    PanEnrollmentId?: NullableStringFieldUpdateOperationsInput | string | null
    TokenStatuses?: TokenStatusesUpdateOneWithoutVisaProvisionedTokensNestedInput
  }

  export type VisaProvisionedTokensUncheckedUpdateInput = {
    ProvisionedTokenId?: StringFieldUpdateOperationsInput | string
    PhoneNumber?: StringFieldUpdateOperationsInput | string
    DeviceId?: NullableStringFieldUpdateOperationsInput | string | null
    StatusId?: NullableIntFieldUpdateOperationsInput | number | null
    PanEnrollmentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VisaProvisionedTokensCreateManyInput = {
    ProvisionedTokenId: string
    PhoneNumber: string
    DeviceId?: string | null
    StatusId?: number | null
    PanEnrollmentId?: string | null
  }

  export type VisaProvisionedTokensUpdateManyMutationInput = {
    ProvisionedTokenId?: StringFieldUpdateOperationsInput | string
    PhoneNumber?: StringFieldUpdateOperationsInput | string
    DeviceId?: NullableStringFieldUpdateOperationsInput | string | null
    PanEnrollmentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VisaProvisionedTokensUncheckedUpdateManyInput = {
    ProvisionedTokenId?: StringFieldUpdateOperationsInput | string
    PhoneNumber?: StringFieldUpdateOperationsInput | string
    DeviceId?: NullableStringFieldUpdateOperationsInput | string | null
    StatusId?: NullableIntFieldUpdateOperationsInput | number | null
    PanEnrollmentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VisaRequestsCreateInput = {
    Id: string
    CreatedDate: Date | string
    UpdatedDate: Date | string
    RequestUrl?: string | null
    RequestMethod?: string | null
    RequestHeaders?: string | null
    RequestBody?: string | null
    ResponseHeaders?: string | null
    ResponseBody?: string | null
    ResponseCode?: string | null
    RequestIp?: string | null
    RequestQuery?: string | null
  }

  export type VisaRequestsUncheckedCreateInput = {
    Id: string
    CreatedDate: Date | string
    UpdatedDate: Date | string
    RequestUrl?: string | null
    RequestMethod?: string | null
    RequestHeaders?: string | null
    RequestBody?: string | null
    ResponseHeaders?: string | null
    ResponseBody?: string | null
    ResponseCode?: string | null
    RequestIp?: string | null
    RequestQuery?: string | null
  }

  export type VisaRequestsUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    RequestUrl?: NullableStringFieldUpdateOperationsInput | string | null
    RequestMethod?: NullableStringFieldUpdateOperationsInput | string | null
    RequestHeaders?: NullableStringFieldUpdateOperationsInput | string | null
    RequestBody?: NullableStringFieldUpdateOperationsInput | string | null
    ResponseHeaders?: NullableStringFieldUpdateOperationsInput | string | null
    ResponseBody?: NullableStringFieldUpdateOperationsInput | string | null
    ResponseCode?: NullableStringFieldUpdateOperationsInput | string | null
    RequestIp?: NullableStringFieldUpdateOperationsInput | string | null
    RequestQuery?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VisaRequestsUncheckedUpdateInput = {
    Id?: StringFieldUpdateOperationsInput | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    RequestUrl?: NullableStringFieldUpdateOperationsInput | string | null
    RequestMethod?: NullableStringFieldUpdateOperationsInput | string | null
    RequestHeaders?: NullableStringFieldUpdateOperationsInput | string | null
    RequestBody?: NullableStringFieldUpdateOperationsInput | string | null
    ResponseHeaders?: NullableStringFieldUpdateOperationsInput | string | null
    ResponseBody?: NullableStringFieldUpdateOperationsInput | string | null
    ResponseCode?: NullableStringFieldUpdateOperationsInput | string | null
    RequestIp?: NullableStringFieldUpdateOperationsInput | string | null
    RequestQuery?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VisaRequestsCreateManyInput = {
    Id: string
    CreatedDate: Date | string
    UpdatedDate: Date | string
    RequestUrl?: string | null
    RequestMethod?: string | null
    RequestHeaders?: string | null
    RequestBody?: string | null
    ResponseHeaders?: string | null
    ResponseBody?: string | null
    ResponseCode?: string | null
    RequestIp?: string | null
    RequestQuery?: string | null
  }

  export type VisaRequestsUpdateManyMutationInput = {
    Id?: StringFieldUpdateOperationsInput | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    RequestUrl?: NullableStringFieldUpdateOperationsInput | string | null
    RequestMethod?: NullableStringFieldUpdateOperationsInput | string | null
    RequestHeaders?: NullableStringFieldUpdateOperationsInput | string | null
    RequestBody?: NullableStringFieldUpdateOperationsInput | string | null
    ResponseHeaders?: NullableStringFieldUpdateOperationsInput | string | null
    ResponseBody?: NullableStringFieldUpdateOperationsInput | string | null
    ResponseCode?: NullableStringFieldUpdateOperationsInput | string | null
    RequestIp?: NullableStringFieldUpdateOperationsInput | string | null
    RequestQuery?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VisaRequestsUncheckedUpdateManyInput = {
    Id?: StringFieldUpdateOperationsInput | string
    CreatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    RequestUrl?: NullableStringFieldUpdateOperationsInput | string | null
    RequestMethod?: NullableStringFieldUpdateOperationsInput | string | null
    RequestHeaders?: NullableStringFieldUpdateOperationsInput | string | null
    RequestBody?: NullableStringFieldUpdateOperationsInput | string | null
    ResponseHeaders?: NullableStringFieldUpdateOperationsInput | string | null
    ResponseBody?: NullableStringFieldUpdateOperationsInput | string | null
    ResponseCode?: NullableStringFieldUpdateOperationsInput | string | null
    RequestIp?: NullableStringFieldUpdateOperationsInput | string | null
    RequestQuery?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EFMigrationsHistoryCountOrderByAggregateInput = {
    MigrationId?: SortOrder
    ProductVersion?: SortOrder
  }

  export type EFMigrationsHistoryMaxOrderByAggregateInput = {
    MigrationId?: SortOrder
    ProductVersion?: SortOrder
  }

  export type EFMigrationsHistoryMinOrderByAggregateInput = {
    MigrationId?: SortOrder
    ProductVersion?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AccessLogCountOrderByAggregateInput = {
    Id?: SortOrder
    CreatedDate?: SortOrder
    UpdatedDate?: SortOrder
    RequestUrl?: SortOrder
    RequestMethod?: SortOrder
    RequestHeaders?: SortOrder
    RequestBody?: SortOrder
    ResponseHeaders?: SortOrder
    ResponseBody?: SortOrder
    ResponseCode?: SortOrder
    RequestIp?: SortOrder
    RequestQuery?: SortOrder
  }

  export type AccessLogAvgOrderByAggregateInput = {
    Id?: SortOrder
  }

  export type AccessLogMaxOrderByAggregateInput = {
    Id?: SortOrder
    CreatedDate?: SortOrder
    UpdatedDate?: SortOrder
    RequestUrl?: SortOrder
    RequestMethod?: SortOrder
    RequestHeaders?: SortOrder
    RequestBody?: SortOrder
    ResponseHeaders?: SortOrder
    ResponseBody?: SortOrder
    ResponseCode?: SortOrder
    RequestIp?: SortOrder
    RequestQuery?: SortOrder
  }

  export type AccessLogMinOrderByAggregateInput = {
    Id?: SortOrder
    CreatedDate?: SortOrder
    UpdatedDate?: SortOrder
    RequestUrl?: SortOrder
    RequestMethod?: SortOrder
    RequestHeaders?: SortOrder
    RequestBody?: SortOrder
    ResponseHeaders?: SortOrder
    ResponseBody?: SortOrder
    ResponseCode?: SortOrder
    RequestIp?: SortOrder
    RequestQuery?: SortOrder
  }

  export type AccessLogSumOrderByAggregateInput = {
    Id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type AppSurveyCountOrderByAggregateInput = {
    Id?: SortOrder
    Rating?: SortOrder
    PhoneNumber?: SortOrder
    AccomplishedDate?: SortOrder
  }

  export type AppSurveyAvgOrderByAggregateInput = {
    Id?: SortOrder
    Rating?: SortOrder
  }

  export type AppSurveyMaxOrderByAggregateInput = {
    Id?: SortOrder
    Rating?: SortOrder
    PhoneNumber?: SortOrder
    AccomplishedDate?: SortOrder
  }

  export type AppSurveyMinOrderByAggregateInput = {
    Id?: SortOrder
    Rating?: SortOrder
    PhoneNumber?: SortOrder
    AccomplishedDate?: SortOrder
  }

  export type AppSurveySumOrderByAggregateInput = {
    Id?: SortOrder
    Rating?: SortOrder
  }

  export type AspNetRolesScalarRelationFilter = {
    is?: AspNetRolesWhereInput
    isNot?: AspNetRolesWhereInput
  }

  export type AspNetRoleClaimsCountOrderByAggregateInput = {
    Id?: SortOrder
    RoleId?: SortOrder
    ClaimType?: SortOrder
    ClaimValue?: SortOrder
  }

  export type AspNetRoleClaimsAvgOrderByAggregateInput = {
    Id?: SortOrder
  }

  export type AspNetRoleClaimsMaxOrderByAggregateInput = {
    Id?: SortOrder
    RoleId?: SortOrder
    ClaimType?: SortOrder
    ClaimValue?: SortOrder
  }

  export type AspNetRoleClaimsMinOrderByAggregateInput = {
    Id?: SortOrder
    RoleId?: SortOrder
    ClaimType?: SortOrder
    ClaimValue?: SortOrder
  }

  export type AspNetRoleClaimsSumOrderByAggregateInput = {
    Id?: SortOrder
  }

  export type AspNetRoleClaimsListRelationFilter = {
    every?: AspNetRoleClaimsWhereInput
    some?: AspNetRoleClaimsWhereInput
    none?: AspNetRoleClaimsWhereInput
  }

  export type AspNetUserRolesListRelationFilter = {
    every?: AspNetUserRolesWhereInput
    some?: AspNetUserRolesWhereInput
    none?: AspNetUserRolesWhereInput
  }

  export type AspNetRoleClaimsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AspNetUserRolesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AspNetRolesCountOrderByAggregateInput = {
    Id?: SortOrder
    Name?: SortOrder
    NormalizedName?: SortOrder
    ConcurrencyStamp?: SortOrder
  }

  export type AspNetRolesMaxOrderByAggregateInput = {
    Id?: SortOrder
    Name?: SortOrder
    NormalizedName?: SortOrder
    ConcurrencyStamp?: SortOrder
  }

  export type AspNetRolesMinOrderByAggregateInput = {
    Id?: SortOrder
    Name?: SortOrder
    NormalizedName?: SortOrder
    ConcurrencyStamp?: SortOrder
  }

  export type AspNetUsersScalarRelationFilter = {
    is?: AspNetUsersWhereInput
    isNot?: AspNetUsersWhereInput
  }

  export type AspNetUserClaimsCountOrderByAggregateInput = {
    Id?: SortOrder
    UserId?: SortOrder
    ClaimType?: SortOrder
    ClaimValue?: SortOrder
  }

  export type AspNetUserClaimsAvgOrderByAggregateInput = {
    Id?: SortOrder
  }

  export type AspNetUserClaimsMaxOrderByAggregateInput = {
    Id?: SortOrder
    UserId?: SortOrder
    ClaimType?: SortOrder
    ClaimValue?: SortOrder
  }

  export type AspNetUserClaimsMinOrderByAggregateInput = {
    Id?: SortOrder
    UserId?: SortOrder
    ClaimType?: SortOrder
    ClaimValue?: SortOrder
  }

  export type AspNetUserClaimsSumOrderByAggregateInput = {
    Id?: SortOrder
  }

  export type AspNetUserLoginsLoginProviderProviderKeyCompoundUniqueInput = {
    LoginProvider: string
    ProviderKey: string
  }

  export type AspNetUserLoginsCountOrderByAggregateInput = {
    LoginProvider?: SortOrder
    ProviderKey?: SortOrder
    ProviderDisplayName?: SortOrder
    UserId?: SortOrder
  }

  export type AspNetUserLoginsMaxOrderByAggregateInput = {
    LoginProvider?: SortOrder
    ProviderKey?: SortOrder
    ProviderDisplayName?: SortOrder
    UserId?: SortOrder
  }

  export type AspNetUserLoginsMinOrderByAggregateInput = {
    LoginProvider?: SortOrder
    ProviderKey?: SortOrder
    ProviderDisplayName?: SortOrder
    UserId?: SortOrder
  }

  export type AspNetUserRolesUserIdRoleIdCompoundUniqueInput = {
    UserId: string
    RoleId: string
  }

  export type AspNetUserRolesCountOrderByAggregateInput = {
    UserId?: SortOrder
    RoleId?: SortOrder
  }

  export type AspNetUserRolesMaxOrderByAggregateInput = {
    UserId?: SortOrder
    RoleId?: SortOrder
  }

  export type AspNetUserRolesMinOrderByAggregateInput = {
    UserId?: SortOrder
    RoleId?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type AspNetUserClaimsListRelationFilter = {
    every?: AspNetUserClaimsWhereInput
    some?: AspNetUserClaimsWhereInput
    none?: AspNetUserClaimsWhereInput
  }

  export type AspNetUserLoginsListRelationFilter = {
    every?: AspNetUserLoginsWhereInput
    some?: AspNetUserLoginsWhereInput
    none?: AspNetUserLoginsWhereInput
  }

  export type AspNetUserTokensListRelationFilter = {
    every?: AspNetUserTokensWhereInput
    some?: AspNetUserTokensWhereInput
    none?: AspNetUserTokensWhereInput
  }

  export type AspNetUserClaimsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AspNetUserLoginsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AspNetUserTokensOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AspNetUsersCountOrderByAggregateInput = {
    Id?: SortOrder
    UserName?: SortOrder
    NormalizedUserName?: SortOrder
    Email?: SortOrder
    NormalizedEmail?: SortOrder
    EmailConfirmed?: SortOrder
    PasswordHash?: SortOrder
    SecurityStamp?: SortOrder
    ConcurrencyStamp?: SortOrder
    PhoneNumber?: SortOrder
    PhoneNumberConfirmed?: SortOrder
    TwoFactorEnabled?: SortOrder
    LockoutEnd?: SortOrder
    LockoutEnabled?: SortOrder
    AccessFailedCount?: SortOrder
    PasswordValidUntil?: SortOrder
    DeviceId?: SortOrder
    FcmToken?: SortOrder
    FullName?: SortOrder
  }

  export type AspNetUsersAvgOrderByAggregateInput = {
    AccessFailedCount?: SortOrder
  }

  export type AspNetUsersMaxOrderByAggregateInput = {
    Id?: SortOrder
    UserName?: SortOrder
    NormalizedUserName?: SortOrder
    Email?: SortOrder
    NormalizedEmail?: SortOrder
    EmailConfirmed?: SortOrder
    PasswordHash?: SortOrder
    SecurityStamp?: SortOrder
    ConcurrencyStamp?: SortOrder
    PhoneNumber?: SortOrder
    PhoneNumberConfirmed?: SortOrder
    TwoFactorEnabled?: SortOrder
    LockoutEnd?: SortOrder
    LockoutEnabled?: SortOrder
    AccessFailedCount?: SortOrder
    PasswordValidUntil?: SortOrder
    DeviceId?: SortOrder
    FcmToken?: SortOrder
    FullName?: SortOrder
  }

  export type AspNetUsersMinOrderByAggregateInput = {
    Id?: SortOrder
    UserName?: SortOrder
    NormalizedUserName?: SortOrder
    Email?: SortOrder
    NormalizedEmail?: SortOrder
    EmailConfirmed?: SortOrder
    PasswordHash?: SortOrder
    SecurityStamp?: SortOrder
    ConcurrencyStamp?: SortOrder
    PhoneNumber?: SortOrder
    PhoneNumberConfirmed?: SortOrder
    TwoFactorEnabled?: SortOrder
    LockoutEnd?: SortOrder
    LockoutEnabled?: SortOrder
    AccessFailedCount?: SortOrder
    PasswordValidUntil?: SortOrder
    DeviceId?: SortOrder
    FcmToken?: SortOrder
    FullName?: SortOrder
  }

  export type AspNetUsersSumOrderByAggregateInput = {
    AccessFailedCount?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type AspNetUserTokensUserIdLoginProviderNameCompoundUniqueInput = {
    UserId: string
    LoginProvider: string
    Name: string
  }

  export type AspNetUserTokensCountOrderByAggregateInput = {
    UserId?: SortOrder
    LoginProvider?: SortOrder
    Name?: SortOrder
    Value?: SortOrder
  }

  export type AspNetUserTokensMaxOrderByAggregateInput = {
    UserId?: SortOrder
    LoginProvider?: SortOrder
    Name?: SortOrder
    Value?: SortOrder
  }

  export type AspNetUserTokensMinOrderByAggregateInput = {
    UserId?: SortOrder
    LoginProvider?: SortOrder
    Name?: SortOrder
    Value?: SortOrder
  }

  export type CardReplacementRequestsCountOrderByAggregateInput = {
    RequestID?: SortOrder
    CreatedDate?: SortOrder
    UpdatedDate?: SortOrder
    PhoneNumber?: SortOrder
    OldFourDigits?: SortOrder
    NewFourDigits?: SortOrder
    IsCompleted?: SortOrder
    DeviceId?: SortOrder
  }

  export type CardReplacementRequestsMaxOrderByAggregateInput = {
    RequestID?: SortOrder
    CreatedDate?: SortOrder
    UpdatedDate?: SortOrder
    PhoneNumber?: SortOrder
    OldFourDigits?: SortOrder
    NewFourDigits?: SortOrder
    IsCompleted?: SortOrder
    DeviceId?: SortOrder
  }

  export type CardReplacementRequestsMinOrderByAggregateInput = {
    RequestID?: SortOrder
    CreatedDate?: SortOrder
    UpdatedDate?: SortOrder
    PhoneNumber?: SortOrder
    OldFourDigits?: SortOrder
    NewFourDigits?: SortOrder
    IsCompleted?: SortOrder
    DeviceId?: SortOrder
  }

  export type DetractorsFeedbackCountOrderByAggregateInput = {
    Id?: SortOrder
    Rating?: SortOrder
    PhoneNumber?: SortOrder
    Feedback?: SortOrder
    AccomplishedDate?: SortOrder
  }

  export type DetractorsFeedbackAvgOrderByAggregateInput = {
    Id?: SortOrder
    Rating?: SortOrder
  }

  export type DetractorsFeedbackMaxOrderByAggregateInput = {
    Id?: SortOrder
    Rating?: SortOrder
    PhoneNumber?: SortOrder
    Feedback?: SortOrder
    AccomplishedDate?: SortOrder
  }

  export type DetractorsFeedbackMinOrderByAggregateInput = {
    Id?: SortOrder
    Rating?: SortOrder
    PhoneNumber?: SortOrder
    Feedback?: SortOrder
    AccomplishedDate?: SortOrder
  }

  export type DetractorsFeedbackSumOrderByAggregateInput = {
    Id?: SortOrder
    Rating?: SortOrder
  }

  export type DeviceAccessLogCountOrderByAggregateInput = {
    Id?: SortOrder
    AccessDateTime?: SortOrder
    DeviceId?: SortOrder
    MobileNumber?: SortOrder
    FullName?: SortOrder
  }

  export type DeviceAccessLogAvgOrderByAggregateInput = {
    Id?: SortOrder
  }

  export type DeviceAccessLogMaxOrderByAggregateInput = {
    Id?: SortOrder
    AccessDateTime?: SortOrder
    DeviceId?: SortOrder
    MobileNumber?: SortOrder
    FullName?: SortOrder
  }

  export type DeviceAccessLogMinOrderByAggregateInput = {
    Id?: SortOrder
    AccessDateTime?: SortOrder
    DeviceId?: SortOrder
    MobileNumber?: SortOrder
    FullName?: SortOrder
  }

  export type DeviceAccessLogSumOrderByAggregateInput = {
    Id?: SortOrder
  }

  export type DeviceCodesCountOrderByAggregateInput = {
    UserCode?: SortOrder
    DeviceCode?: SortOrder
    SubjectId?: SortOrder
    ClientId?: SortOrder
    CreationTime?: SortOrder
    Expiration?: SortOrder
    Data?: SortOrder
  }

  export type DeviceCodesMaxOrderByAggregateInput = {
    UserCode?: SortOrder
    DeviceCode?: SortOrder
    SubjectId?: SortOrder
    ClientId?: SortOrder
    CreationTime?: SortOrder
    Expiration?: SortOrder
    Data?: SortOrder
  }

  export type DeviceCodesMinOrderByAggregateInput = {
    UserCode?: SortOrder
    DeviceCode?: SortOrder
    SubjectId?: SortOrder
    ClientId?: SortOrder
    CreationTime?: SortOrder
    Expiration?: SortOrder
    Data?: SortOrder
  }

  export type EwPayActivatedCardsCountOrderByAggregateInput = {
    Id?: SortOrder
    UCRN?: SortOrder
    DateActivated?: SortOrder
  }

  export type EwPayActivatedCardsAvgOrderByAggregateInput = {
    Id?: SortOrder
  }

  export type EwPayActivatedCardsMaxOrderByAggregateInput = {
    Id?: SortOrder
    UCRN?: SortOrder
    DateActivated?: SortOrder
  }

  export type EwPayActivatedCardsMinOrderByAggregateInput = {
    Id?: SortOrder
    UCRN?: SortOrder
    DateActivated?: SortOrder
  }

  export type EwPayActivatedCardsSumOrderByAggregateInput = {
    Id?: SortOrder
  }

  export type EwPayIneligibleCardsCountOrderByAggregateInput = {
    Id?: SortOrder
    UCRN?: SortOrder
    IsReported?: SortOrder
    IsActivated?: SortOrder
    DateReported?: SortOrder
  }

  export type EwPayIneligibleCardsAvgOrderByAggregateInput = {
    Id?: SortOrder
  }

  export type EwPayIneligibleCardsMaxOrderByAggregateInput = {
    Id?: SortOrder
    UCRN?: SortOrder
    IsReported?: SortOrder
    IsActivated?: SortOrder
    DateReported?: SortOrder
  }

  export type EwPayIneligibleCardsMinOrderByAggregateInput = {
    Id?: SortOrder
    UCRN?: SortOrder
    IsReported?: SortOrder
    IsActivated?: SortOrder
    DateReported?: SortOrder
  }

  export type EwPayIneligibleCardsSumOrderByAggregateInput = {
    Id?: SortOrder
  }

  export type InvalidDeviceAccessCountOrderByAggregateInput = {
    Id?: SortOrder
    AccessDateTime?: SortOrder
    DeviceId?: SortOrder
    MobileNumber?: SortOrder
    Reason?: SortOrder
  }

  export type InvalidDeviceAccessAvgOrderByAggregateInput = {
    Id?: SortOrder
  }

  export type InvalidDeviceAccessMaxOrderByAggregateInput = {
    Id?: SortOrder
    AccessDateTime?: SortOrder
    DeviceId?: SortOrder
    MobileNumber?: SortOrder
    Reason?: SortOrder
  }

  export type InvalidDeviceAccessMinOrderByAggregateInput = {
    Id?: SortOrder
    AccessDateTime?: SortOrder
    DeviceId?: SortOrder
    MobileNumber?: SortOrder
    Reason?: SortOrder
  }

  export type InvalidDeviceAccessSumOrderByAggregateInput = {
    Id?: SortOrder
  }

  export type MastercardProvisionedTokensTokenUniqueReferenceIdPhoneNumberCompoundUniqueInput = {
    TokenUniqueReferenceId: string
    PhoneNumber: string
  }

  export type MastercardProvisionedTokensCountOrderByAggregateInput = {
    TokenUniqueReferenceId?: SortOrder
    PhoneNumber?: SortOrder
    DeviceId?: SortOrder
    PaymentAccountReference?: SortOrder
  }

  export type MastercardProvisionedTokensMaxOrderByAggregateInput = {
    TokenUniqueReferenceId?: SortOrder
    PhoneNumber?: SortOrder
    DeviceId?: SortOrder
    PaymentAccountReference?: SortOrder
  }

  export type MastercardProvisionedTokensMinOrderByAggregateInput = {
    TokenUniqueReferenceId?: SortOrder
    PhoneNumber?: SortOrder
    DeviceId?: SortOrder
    PaymentAccountReference?: SortOrder
  }

  export type PersistedGrantsCountOrderByAggregateInput = {
    Key?: SortOrder
    Type?: SortOrder
    SubjectId?: SortOrder
    ClientId?: SortOrder
    CreationTime?: SortOrder
    Expiration?: SortOrder
    Data?: SortOrder
  }

  export type PersistedGrantsMaxOrderByAggregateInput = {
    Key?: SortOrder
    Type?: SortOrder
    SubjectId?: SortOrder
    ClientId?: SortOrder
    CreationTime?: SortOrder
    Expiration?: SortOrder
    Data?: SortOrder
  }

  export type PersistedGrantsMinOrderByAggregateInput = {
    Key?: SortOrder
    Type?: SortOrder
    SubjectId?: SortOrder
    ClientId?: SortOrder
    CreationTime?: SortOrder
    Expiration?: SortOrder
    Data?: SortOrder
  }

  export type ProvisionedTokenIdsCountOrderByAggregateInput = {
    Id?: SortOrder
    ProvisionedTokenId?: SortOrder
    PanEnrollmentId?: SortOrder
    TokenReferenceId?: SortOrder
  }

  export type ProvisionedTokenIdsAvgOrderByAggregateInput = {
    Id?: SortOrder
  }

  export type ProvisionedTokenIdsMaxOrderByAggregateInput = {
    Id?: SortOrder
    ProvisionedTokenId?: SortOrder
    PanEnrollmentId?: SortOrder
    TokenReferenceId?: SortOrder
  }

  export type ProvisionedTokenIdsMinOrderByAggregateInput = {
    Id?: SortOrder
    ProvisionedTokenId?: SortOrder
    PanEnrollmentId?: SortOrder
    TokenReferenceId?: SortOrder
  }

  export type ProvisionedTokenIdsSumOrderByAggregateInput = {
    Id?: SortOrder
  }

  export type RegisterLogEntryCountOrderByAggregateInput = {
    Id?: SortOrder
    DeviceId?: SortOrder
    MobileNumber?: SortOrder
    RegistrationDateTime?: SortOrder
  }

  export type RegisterLogEntryAvgOrderByAggregateInput = {
    Id?: SortOrder
  }

  export type RegisterLogEntryMaxOrderByAggregateInput = {
    Id?: SortOrder
    DeviceId?: SortOrder
    MobileNumber?: SortOrder
    RegistrationDateTime?: SortOrder
  }

  export type RegisterLogEntryMinOrderByAggregateInput = {
    Id?: SortOrder
    DeviceId?: SortOrder
    MobileNumber?: SortOrder
    RegistrationDateTime?: SortOrder
  }

  export type RegisterLogEntrySumOrderByAggregateInput = {
    Id?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BytesNullableFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null
    in?: Uint8Array[] | null
    notIn?: Uint8Array[] | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Uint8Array | null
  }

  export type sysdiagramsPrincipal_idNameCompoundUniqueInput = {
    principal_id: number
    name: string
  }

  export type sysdiagramsCountOrderByAggregateInput = {
    name?: SortOrder
    principal_id?: SortOrder
    diagram_id?: SortOrder
    version?: SortOrder
    definition?: SortOrder
  }

  export type sysdiagramsAvgOrderByAggregateInput = {
    principal_id?: SortOrder
    diagram_id?: SortOrder
    version?: SortOrder
  }

  export type sysdiagramsMaxOrderByAggregateInput = {
    name?: SortOrder
    principal_id?: SortOrder
    diagram_id?: SortOrder
    version?: SortOrder
    definition?: SortOrder
  }

  export type sysdiagramsMinOrderByAggregateInput = {
    name?: SortOrder
    principal_id?: SortOrder
    diagram_id?: SortOrder
    version?: SortOrder
    definition?: SortOrder
  }

  export type sysdiagramsSumOrderByAggregateInput = {
    principal_id?: SortOrder
    diagram_id?: SortOrder
    version?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null
    in?: Uint8Array[] | null
    notIn?: Uint8Array[] | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Uint8Array | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }

  export type TapToPayTransactionLogCountOrderByAggregateInput = {
    Id?: SortOrder
    DeviceId?: SortOrder
    PhoneNumber?: SortOrder
    TransactionDate?: SortOrder
  }

  export type TapToPayTransactionLogAvgOrderByAggregateInput = {
    Id?: SortOrder
  }

  export type TapToPayTransactionLogMaxOrderByAggregateInput = {
    Id?: SortOrder
    DeviceId?: SortOrder
    PhoneNumber?: SortOrder
    TransactionDate?: SortOrder
  }

  export type TapToPayTransactionLogMinOrderByAggregateInput = {
    Id?: SortOrder
    DeviceId?: SortOrder
    PhoneNumber?: SortOrder
    TransactionDate?: SortOrder
  }

  export type TapToPayTransactionLogSumOrderByAggregateInput = {
    Id?: SortOrder
  }

  export type VisaProvisionedTokensListRelationFilter = {
    every?: VisaProvisionedTokensWhereInput
    some?: VisaProvisionedTokensWhereInput
    none?: VisaProvisionedTokensWhereInput
  }

  export type VisaProvisionedTokensOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TokenStatusesCountOrderByAggregateInput = {
    ID?: SortOrder
    Name?: SortOrder
    CardProviderName?: SortOrder
    IsSuspended?: SortOrder
    IsDeleted?: SortOrder
    IsActive?: SortOrder
    IsInactive?: SortOrder
  }

  export type TokenStatusesAvgOrderByAggregateInput = {
    ID?: SortOrder
  }

  export type TokenStatusesMaxOrderByAggregateInput = {
    ID?: SortOrder
    Name?: SortOrder
    CardProviderName?: SortOrder
    IsSuspended?: SortOrder
    IsDeleted?: SortOrder
    IsActive?: SortOrder
    IsInactive?: SortOrder
  }

  export type TokenStatusesMinOrderByAggregateInput = {
    ID?: SortOrder
    Name?: SortOrder
    CardProviderName?: SortOrder
    IsSuspended?: SortOrder
    IsDeleted?: SortOrder
    IsActive?: SortOrder
    IsInactive?: SortOrder
  }

  export type TokenStatusesSumOrderByAggregateInput = {
    ID?: SortOrder
  }

  export type TokenStatusesNullableScalarRelationFilter = {
    is?: TokenStatusesWhereInput | null
    isNot?: TokenStatusesWhereInput | null
  }

  export type VisaProvisionedTokensProvisionedTokenIdPhoneNumberCompoundUniqueInput = {
    ProvisionedTokenId: string
    PhoneNumber: string
  }

  export type VisaProvisionedTokensCountOrderByAggregateInput = {
    ProvisionedTokenId?: SortOrder
    PhoneNumber?: SortOrder
    DeviceId?: SortOrder
    StatusId?: SortOrder
    PanEnrollmentId?: SortOrder
  }

  export type VisaProvisionedTokensAvgOrderByAggregateInput = {
    StatusId?: SortOrder
  }

  export type VisaProvisionedTokensMaxOrderByAggregateInput = {
    ProvisionedTokenId?: SortOrder
    PhoneNumber?: SortOrder
    DeviceId?: SortOrder
    StatusId?: SortOrder
    PanEnrollmentId?: SortOrder
  }

  export type VisaProvisionedTokensMinOrderByAggregateInput = {
    ProvisionedTokenId?: SortOrder
    PhoneNumber?: SortOrder
    DeviceId?: SortOrder
    StatusId?: SortOrder
    PanEnrollmentId?: SortOrder
  }

  export type VisaProvisionedTokensSumOrderByAggregateInput = {
    StatusId?: SortOrder
  }

  export type VisaRequestsCountOrderByAggregateInput = {
    Id?: SortOrder
    CreatedDate?: SortOrder
    UpdatedDate?: SortOrder
    RequestUrl?: SortOrder
    RequestMethod?: SortOrder
    RequestHeaders?: SortOrder
    RequestBody?: SortOrder
    ResponseHeaders?: SortOrder
    ResponseBody?: SortOrder
    ResponseCode?: SortOrder
    RequestIp?: SortOrder
    RequestQuery?: SortOrder
  }

  export type VisaRequestsMaxOrderByAggregateInput = {
    Id?: SortOrder
    CreatedDate?: SortOrder
    UpdatedDate?: SortOrder
    RequestUrl?: SortOrder
    RequestMethod?: SortOrder
    RequestHeaders?: SortOrder
    RequestBody?: SortOrder
    ResponseHeaders?: SortOrder
    ResponseBody?: SortOrder
    ResponseCode?: SortOrder
    RequestIp?: SortOrder
    RequestQuery?: SortOrder
  }

  export type VisaRequestsMinOrderByAggregateInput = {
    Id?: SortOrder
    CreatedDate?: SortOrder
    UpdatedDate?: SortOrder
    RequestUrl?: SortOrder
    RequestMethod?: SortOrder
    RequestHeaders?: SortOrder
    RequestBody?: SortOrder
    ResponseHeaders?: SortOrder
    ResponseBody?: SortOrder
    ResponseCode?: SortOrder
    RequestIp?: SortOrder
    RequestQuery?: SortOrder
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AspNetRolesCreateNestedOneWithoutAspNetRoleClaimsInput = {
    create?: XOR<AspNetRolesCreateWithoutAspNetRoleClaimsInput, AspNetRolesUncheckedCreateWithoutAspNetRoleClaimsInput>
    connectOrCreate?: AspNetRolesCreateOrConnectWithoutAspNetRoleClaimsInput
    connect?: AspNetRolesWhereUniqueInput
  }

  export type AspNetRolesUpdateOneRequiredWithoutAspNetRoleClaimsNestedInput = {
    create?: XOR<AspNetRolesCreateWithoutAspNetRoleClaimsInput, AspNetRolesUncheckedCreateWithoutAspNetRoleClaimsInput>
    connectOrCreate?: AspNetRolesCreateOrConnectWithoutAspNetRoleClaimsInput
    upsert?: AspNetRolesUpsertWithoutAspNetRoleClaimsInput
    connect?: AspNetRolesWhereUniqueInput
    update?: XOR<XOR<AspNetRolesUpdateToOneWithWhereWithoutAspNetRoleClaimsInput, AspNetRolesUpdateWithoutAspNetRoleClaimsInput>, AspNetRolesUncheckedUpdateWithoutAspNetRoleClaimsInput>
  }

  export type AspNetRoleClaimsCreateNestedManyWithoutAspNetRolesInput = {
    create?: XOR<AspNetRoleClaimsCreateWithoutAspNetRolesInput, AspNetRoleClaimsUncheckedCreateWithoutAspNetRolesInput> | AspNetRoleClaimsCreateWithoutAspNetRolesInput[] | AspNetRoleClaimsUncheckedCreateWithoutAspNetRolesInput[]
    connectOrCreate?: AspNetRoleClaimsCreateOrConnectWithoutAspNetRolesInput | AspNetRoleClaimsCreateOrConnectWithoutAspNetRolesInput[]
    createMany?: AspNetRoleClaimsCreateManyAspNetRolesInputEnvelope
    connect?: AspNetRoleClaimsWhereUniqueInput | AspNetRoleClaimsWhereUniqueInput[]
  }

  export type AspNetUserRolesCreateNestedManyWithoutAspNetRolesInput = {
    create?: XOR<AspNetUserRolesCreateWithoutAspNetRolesInput, AspNetUserRolesUncheckedCreateWithoutAspNetRolesInput> | AspNetUserRolesCreateWithoutAspNetRolesInput[] | AspNetUserRolesUncheckedCreateWithoutAspNetRolesInput[]
    connectOrCreate?: AspNetUserRolesCreateOrConnectWithoutAspNetRolesInput | AspNetUserRolesCreateOrConnectWithoutAspNetRolesInput[]
    createMany?: AspNetUserRolesCreateManyAspNetRolesInputEnvelope
    connect?: AspNetUserRolesWhereUniqueInput | AspNetUserRolesWhereUniqueInput[]
  }

  export type AspNetRoleClaimsUncheckedCreateNestedManyWithoutAspNetRolesInput = {
    create?: XOR<AspNetRoleClaimsCreateWithoutAspNetRolesInput, AspNetRoleClaimsUncheckedCreateWithoutAspNetRolesInput> | AspNetRoleClaimsCreateWithoutAspNetRolesInput[] | AspNetRoleClaimsUncheckedCreateWithoutAspNetRolesInput[]
    connectOrCreate?: AspNetRoleClaimsCreateOrConnectWithoutAspNetRolesInput | AspNetRoleClaimsCreateOrConnectWithoutAspNetRolesInput[]
    createMany?: AspNetRoleClaimsCreateManyAspNetRolesInputEnvelope
    connect?: AspNetRoleClaimsWhereUniqueInput | AspNetRoleClaimsWhereUniqueInput[]
  }

  export type AspNetUserRolesUncheckedCreateNestedManyWithoutAspNetRolesInput = {
    create?: XOR<AspNetUserRolesCreateWithoutAspNetRolesInput, AspNetUserRolesUncheckedCreateWithoutAspNetRolesInput> | AspNetUserRolesCreateWithoutAspNetRolesInput[] | AspNetUserRolesUncheckedCreateWithoutAspNetRolesInput[]
    connectOrCreate?: AspNetUserRolesCreateOrConnectWithoutAspNetRolesInput | AspNetUserRolesCreateOrConnectWithoutAspNetRolesInput[]
    createMany?: AspNetUserRolesCreateManyAspNetRolesInputEnvelope
    connect?: AspNetUserRolesWhereUniqueInput | AspNetUserRolesWhereUniqueInput[]
  }

  export type AspNetRoleClaimsUpdateManyWithoutAspNetRolesNestedInput = {
    create?: XOR<AspNetRoleClaimsCreateWithoutAspNetRolesInput, AspNetRoleClaimsUncheckedCreateWithoutAspNetRolesInput> | AspNetRoleClaimsCreateWithoutAspNetRolesInput[] | AspNetRoleClaimsUncheckedCreateWithoutAspNetRolesInput[]
    connectOrCreate?: AspNetRoleClaimsCreateOrConnectWithoutAspNetRolesInput | AspNetRoleClaimsCreateOrConnectWithoutAspNetRolesInput[]
    upsert?: AspNetRoleClaimsUpsertWithWhereUniqueWithoutAspNetRolesInput | AspNetRoleClaimsUpsertWithWhereUniqueWithoutAspNetRolesInput[]
    createMany?: AspNetRoleClaimsCreateManyAspNetRolesInputEnvelope
    set?: AspNetRoleClaimsWhereUniqueInput | AspNetRoleClaimsWhereUniqueInput[]
    disconnect?: AspNetRoleClaimsWhereUniqueInput | AspNetRoleClaimsWhereUniqueInput[]
    delete?: AspNetRoleClaimsWhereUniqueInput | AspNetRoleClaimsWhereUniqueInput[]
    connect?: AspNetRoleClaimsWhereUniqueInput | AspNetRoleClaimsWhereUniqueInput[]
    update?: AspNetRoleClaimsUpdateWithWhereUniqueWithoutAspNetRolesInput | AspNetRoleClaimsUpdateWithWhereUniqueWithoutAspNetRolesInput[]
    updateMany?: AspNetRoleClaimsUpdateManyWithWhereWithoutAspNetRolesInput | AspNetRoleClaimsUpdateManyWithWhereWithoutAspNetRolesInput[]
    deleteMany?: AspNetRoleClaimsScalarWhereInput | AspNetRoleClaimsScalarWhereInput[]
  }

  export type AspNetUserRolesUpdateManyWithoutAspNetRolesNestedInput = {
    create?: XOR<AspNetUserRolesCreateWithoutAspNetRolesInput, AspNetUserRolesUncheckedCreateWithoutAspNetRolesInput> | AspNetUserRolesCreateWithoutAspNetRolesInput[] | AspNetUserRolesUncheckedCreateWithoutAspNetRolesInput[]
    connectOrCreate?: AspNetUserRolesCreateOrConnectWithoutAspNetRolesInput | AspNetUserRolesCreateOrConnectWithoutAspNetRolesInput[]
    upsert?: AspNetUserRolesUpsertWithWhereUniqueWithoutAspNetRolesInput | AspNetUserRolesUpsertWithWhereUniqueWithoutAspNetRolesInput[]
    createMany?: AspNetUserRolesCreateManyAspNetRolesInputEnvelope
    set?: AspNetUserRolesWhereUniqueInput | AspNetUserRolesWhereUniqueInput[]
    disconnect?: AspNetUserRolesWhereUniqueInput | AspNetUserRolesWhereUniqueInput[]
    delete?: AspNetUserRolesWhereUniqueInput | AspNetUserRolesWhereUniqueInput[]
    connect?: AspNetUserRolesWhereUniqueInput | AspNetUserRolesWhereUniqueInput[]
    update?: AspNetUserRolesUpdateWithWhereUniqueWithoutAspNetRolesInput | AspNetUserRolesUpdateWithWhereUniqueWithoutAspNetRolesInput[]
    updateMany?: AspNetUserRolesUpdateManyWithWhereWithoutAspNetRolesInput | AspNetUserRolesUpdateManyWithWhereWithoutAspNetRolesInput[]
    deleteMany?: AspNetUserRolesScalarWhereInput | AspNetUserRolesScalarWhereInput[]
  }

  export type AspNetRoleClaimsUncheckedUpdateManyWithoutAspNetRolesNestedInput = {
    create?: XOR<AspNetRoleClaimsCreateWithoutAspNetRolesInput, AspNetRoleClaimsUncheckedCreateWithoutAspNetRolesInput> | AspNetRoleClaimsCreateWithoutAspNetRolesInput[] | AspNetRoleClaimsUncheckedCreateWithoutAspNetRolesInput[]
    connectOrCreate?: AspNetRoleClaimsCreateOrConnectWithoutAspNetRolesInput | AspNetRoleClaimsCreateOrConnectWithoutAspNetRolesInput[]
    upsert?: AspNetRoleClaimsUpsertWithWhereUniqueWithoutAspNetRolesInput | AspNetRoleClaimsUpsertWithWhereUniqueWithoutAspNetRolesInput[]
    createMany?: AspNetRoleClaimsCreateManyAspNetRolesInputEnvelope
    set?: AspNetRoleClaimsWhereUniqueInput | AspNetRoleClaimsWhereUniqueInput[]
    disconnect?: AspNetRoleClaimsWhereUniqueInput | AspNetRoleClaimsWhereUniqueInput[]
    delete?: AspNetRoleClaimsWhereUniqueInput | AspNetRoleClaimsWhereUniqueInput[]
    connect?: AspNetRoleClaimsWhereUniqueInput | AspNetRoleClaimsWhereUniqueInput[]
    update?: AspNetRoleClaimsUpdateWithWhereUniqueWithoutAspNetRolesInput | AspNetRoleClaimsUpdateWithWhereUniqueWithoutAspNetRolesInput[]
    updateMany?: AspNetRoleClaimsUpdateManyWithWhereWithoutAspNetRolesInput | AspNetRoleClaimsUpdateManyWithWhereWithoutAspNetRolesInput[]
    deleteMany?: AspNetRoleClaimsScalarWhereInput | AspNetRoleClaimsScalarWhereInput[]
  }

  export type AspNetUserRolesUncheckedUpdateManyWithoutAspNetRolesNestedInput = {
    create?: XOR<AspNetUserRolesCreateWithoutAspNetRolesInput, AspNetUserRolesUncheckedCreateWithoutAspNetRolesInput> | AspNetUserRolesCreateWithoutAspNetRolesInput[] | AspNetUserRolesUncheckedCreateWithoutAspNetRolesInput[]
    connectOrCreate?: AspNetUserRolesCreateOrConnectWithoutAspNetRolesInput | AspNetUserRolesCreateOrConnectWithoutAspNetRolesInput[]
    upsert?: AspNetUserRolesUpsertWithWhereUniqueWithoutAspNetRolesInput | AspNetUserRolesUpsertWithWhereUniqueWithoutAspNetRolesInput[]
    createMany?: AspNetUserRolesCreateManyAspNetRolesInputEnvelope
    set?: AspNetUserRolesWhereUniqueInput | AspNetUserRolesWhereUniqueInput[]
    disconnect?: AspNetUserRolesWhereUniqueInput | AspNetUserRolesWhereUniqueInput[]
    delete?: AspNetUserRolesWhereUniqueInput | AspNetUserRolesWhereUniqueInput[]
    connect?: AspNetUserRolesWhereUniqueInput | AspNetUserRolesWhereUniqueInput[]
    update?: AspNetUserRolesUpdateWithWhereUniqueWithoutAspNetRolesInput | AspNetUserRolesUpdateWithWhereUniqueWithoutAspNetRolesInput[]
    updateMany?: AspNetUserRolesUpdateManyWithWhereWithoutAspNetRolesInput | AspNetUserRolesUpdateManyWithWhereWithoutAspNetRolesInput[]
    deleteMany?: AspNetUserRolesScalarWhereInput | AspNetUserRolesScalarWhereInput[]
  }

  export type AspNetUsersCreateNestedOneWithoutAspNetUserClaimsInput = {
    create?: XOR<AspNetUsersCreateWithoutAspNetUserClaimsInput, AspNetUsersUncheckedCreateWithoutAspNetUserClaimsInput>
    connectOrCreate?: AspNetUsersCreateOrConnectWithoutAspNetUserClaimsInput
    connect?: AspNetUsersWhereUniqueInput
  }

  export type AspNetUsersUpdateOneRequiredWithoutAspNetUserClaimsNestedInput = {
    create?: XOR<AspNetUsersCreateWithoutAspNetUserClaimsInput, AspNetUsersUncheckedCreateWithoutAspNetUserClaimsInput>
    connectOrCreate?: AspNetUsersCreateOrConnectWithoutAspNetUserClaimsInput
    upsert?: AspNetUsersUpsertWithoutAspNetUserClaimsInput
    connect?: AspNetUsersWhereUniqueInput
    update?: XOR<XOR<AspNetUsersUpdateToOneWithWhereWithoutAspNetUserClaimsInput, AspNetUsersUpdateWithoutAspNetUserClaimsInput>, AspNetUsersUncheckedUpdateWithoutAspNetUserClaimsInput>
  }

  export type AspNetUsersCreateNestedOneWithoutAspNetUserLoginsInput = {
    create?: XOR<AspNetUsersCreateWithoutAspNetUserLoginsInput, AspNetUsersUncheckedCreateWithoutAspNetUserLoginsInput>
    connectOrCreate?: AspNetUsersCreateOrConnectWithoutAspNetUserLoginsInput
    connect?: AspNetUsersWhereUniqueInput
  }

  export type AspNetUsersUpdateOneRequiredWithoutAspNetUserLoginsNestedInput = {
    create?: XOR<AspNetUsersCreateWithoutAspNetUserLoginsInput, AspNetUsersUncheckedCreateWithoutAspNetUserLoginsInput>
    connectOrCreate?: AspNetUsersCreateOrConnectWithoutAspNetUserLoginsInput
    upsert?: AspNetUsersUpsertWithoutAspNetUserLoginsInput
    connect?: AspNetUsersWhereUniqueInput
    update?: XOR<XOR<AspNetUsersUpdateToOneWithWhereWithoutAspNetUserLoginsInput, AspNetUsersUpdateWithoutAspNetUserLoginsInput>, AspNetUsersUncheckedUpdateWithoutAspNetUserLoginsInput>
  }

  export type AspNetRolesCreateNestedOneWithoutAspNetUserRolesInput = {
    create?: XOR<AspNetRolesCreateWithoutAspNetUserRolesInput, AspNetRolesUncheckedCreateWithoutAspNetUserRolesInput>
    connectOrCreate?: AspNetRolesCreateOrConnectWithoutAspNetUserRolesInput
    connect?: AspNetRolesWhereUniqueInput
  }

  export type AspNetUsersCreateNestedOneWithoutAspNetUserRolesInput = {
    create?: XOR<AspNetUsersCreateWithoutAspNetUserRolesInput, AspNetUsersUncheckedCreateWithoutAspNetUserRolesInput>
    connectOrCreate?: AspNetUsersCreateOrConnectWithoutAspNetUserRolesInput
    connect?: AspNetUsersWhereUniqueInput
  }

  export type AspNetRolesUpdateOneRequiredWithoutAspNetUserRolesNestedInput = {
    create?: XOR<AspNetRolesCreateWithoutAspNetUserRolesInput, AspNetRolesUncheckedCreateWithoutAspNetUserRolesInput>
    connectOrCreate?: AspNetRolesCreateOrConnectWithoutAspNetUserRolesInput
    upsert?: AspNetRolesUpsertWithoutAspNetUserRolesInput
    connect?: AspNetRolesWhereUniqueInput
    update?: XOR<XOR<AspNetRolesUpdateToOneWithWhereWithoutAspNetUserRolesInput, AspNetRolesUpdateWithoutAspNetUserRolesInput>, AspNetRolesUncheckedUpdateWithoutAspNetUserRolesInput>
  }

  export type AspNetUsersUpdateOneRequiredWithoutAspNetUserRolesNestedInput = {
    create?: XOR<AspNetUsersCreateWithoutAspNetUserRolesInput, AspNetUsersUncheckedCreateWithoutAspNetUserRolesInput>
    connectOrCreate?: AspNetUsersCreateOrConnectWithoutAspNetUserRolesInput
    upsert?: AspNetUsersUpsertWithoutAspNetUserRolesInput
    connect?: AspNetUsersWhereUniqueInput
    update?: XOR<XOR<AspNetUsersUpdateToOneWithWhereWithoutAspNetUserRolesInput, AspNetUsersUpdateWithoutAspNetUserRolesInput>, AspNetUsersUncheckedUpdateWithoutAspNetUserRolesInput>
  }

  export type AspNetUserClaimsCreateNestedManyWithoutAspNetUsersInput = {
    create?: XOR<AspNetUserClaimsCreateWithoutAspNetUsersInput, AspNetUserClaimsUncheckedCreateWithoutAspNetUsersInput> | AspNetUserClaimsCreateWithoutAspNetUsersInput[] | AspNetUserClaimsUncheckedCreateWithoutAspNetUsersInput[]
    connectOrCreate?: AspNetUserClaimsCreateOrConnectWithoutAspNetUsersInput | AspNetUserClaimsCreateOrConnectWithoutAspNetUsersInput[]
    createMany?: AspNetUserClaimsCreateManyAspNetUsersInputEnvelope
    connect?: AspNetUserClaimsWhereUniqueInput | AspNetUserClaimsWhereUniqueInput[]
  }

  export type AspNetUserLoginsCreateNestedManyWithoutAspNetUsersInput = {
    create?: XOR<AspNetUserLoginsCreateWithoutAspNetUsersInput, AspNetUserLoginsUncheckedCreateWithoutAspNetUsersInput> | AspNetUserLoginsCreateWithoutAspNetUsersInput[] | AspNetUserLoginsUncheckedCreateWithoutAspNetUsersInput[]
    connectOrCreate?: AspNetUserLoginsCreateOrConnectWithoutAspNetUsersInput | AspNetUserLoginsCreateOrConnectWithoutAspNetUsersInput[]
    createMany?: AspNetUserLoginsCreateManyAspNetUsersInputEnvelope
    connect?: AspNetUserLoginsWhereUniqueInput | AspNetUserLoginsWhereUniqueInput[]
  }

  export type AspNetUserRolesCreateNestedManyWithoutAspNetUsersInput = {
    create?: XOR<AspNetUserRolesCreateWithoutAspNetUsersInput, AspNetUserRolesUncheckedCreateWithoutAspNetUsersInput> | AspNetUserRolesCreateWithoutAspNetUsersInput[] | AspNetUserRolesUncheckedCreateWithoutAspNetUsersInput[]
    connectOrCreate?: AspNetUserRolesCreateOrConnectWithoutAspNetUsersInput | AspNetUserRolesCreateOrConnectWithoutAspNetUsersInput[]
    createMany?: AspNetUserRolesCreateManyAspNetUsersInputEnvelope
    connect?: AspNetUserRolesWhereUniqueInput | AspNetUserRolesWhereUniqueInput[]
  }

  export type AspNetUserTokensCreateNestedManyWithoutAspNetUsersInput = {
    create?: XOR<AspNetUserTokensCreateWithoutAspNetUsersInput, AspNetUserTokensUncheckedCreateWithoutAspNetUsersInput> | AspNetUserTokensCreateWithoutAspNetUsersInput[] | AspNetUserTokensUncheckedCreateWithoutAspNetUsersInput[]
    connectOrCreate?: AspNetUserTokensCreateOrConnectWithoutAspNetUsersInput | AspNetUserTokensCreateOrConnectWithoutAspNetUsersInput[]
    createMany?: AspNetUserTokensCreateManyAspNetUsersInputEnvelope
    connect?: AspNetUserTokensWhereUniqueInput | AspNetUserTokensWhereUniqueInput[]
  }

  export type AspNetUserClaimsUncheckedCreateNestedManyWithoutAspNetUsersInput = {
    create?: XOR<AspNetUserClaimsCreateWithoutAspNetUsersInput, AspNetUserClaimsUncheckedCreateWithoutAspNetUsersInput> | AspNetUserClaimsCreateWithoutAspNetUsersInput[] | AspNetUserClaimsUncheckedCreateWithoutAspNetUsersInput[]
    connectOrCreate?: AspNetUserClaimsCreateOrConnectWithoutAspNetUsersInput | AspNetUserClaimsCreateOrConnectWithoutAspNetUsersInput[]
    createMany?: AspNetUserClaimsCreateManyAspNetUsersInputEnvelope
    connect?: AspNetUserClaimsWhereUniqueInput | AspNetUserClaimsWhereUniqueInput[]
  }

  export type AspNetUserLoginsUncheckedCreateNestedManyWithoutAspNetUsersInput = {
    create?: XOR<AspNetUserLoginsCreateWithoutAspNetUsersInput, AspNetUserLoginsUncheckedCreateWithoutAspNetUsersInput> | AspNetUserLoginsCreateWithoutAspNetUsersInput[] | AspNetUserLoginsUncheckedCreateWithoutAspNetUsersInput[]
    connectOrCreate?: AspNetUserLoginsCreateOrConnectWithoutAspNetUsersInput | AspNetUserLoginsCreateOrConnectWithoutAspNetUsersInput[]
    createMany?: AspNetUserLoginsCreateManyAspNetUsersInputEnvelope
    connect?: AspNetUserLoginsWhereUniqueInput | AspNetUserLoginsWhereUniqueInput[]
  }

  export type AspNetUserRolesUncheckedCreateNestedManyWithoutAspNetUsersInput = {
    create?: XOR<AspNetUserRolesCreateWithoutAspNetUsersInput, AspNetUserRolesUncheckedCreateWithoutAspNetUsersInput> | AspNetUserRolesCreateWithoutAspNetUsersInput[] | AspNetUserRolesUncheckedCreateWithoutAspNetUsersInput[]
    connectOrCreate?: AspNetUserRolesCreateOrConnectWithoutAspNetUsersInput | AspNetUserRolesCreateOrConnectWithoutAspNetUsersInput[]
    createMany?: AspNetUserRolesCreateManyAspNetUsersInputEnvelope
    connect?: AspNetUserRolesWhereUniqueInput | AspNetUserRolesWhereUniqueInput[]
  }

  export type AspNetUserTokensUncheckedCreateNestedManyWithoutAspNetUsersInput = {
    create?: XOR<AspNetUserTokensCreateWithoutAspNetUsersInput, AspNetUserTokensUncheckedCreateWithoutAspNetUsersInput> | AspNetUserTokensCreateWithoutAspNetUsersInput[] | AspNetUserTokensUncheckedCreateWithoutAspNetUsersInput[]
    connectOrCreate?: AspNetUserTokensCreateOrConnectWithoutAspNetUsersInput | AspNetUserTokensCreateOrConnectWithoutAspNetUsersInput[]
    createMany?: AspNetUserTokensCreateManyAspNetUsersInputEnvelope
    connect?: AspNetUserTokensWhereUniqueInput | AspNetUserTokensWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type AspNetUserClaimsUpdateManyWithoutAspNetUsersNestedInput = {
    create?: XOR<AspNetUserClaimsCreateWithoutAspNetUsersInput, AspNetUserClaimsUncheckedCreateWithoutAspNetUsersInput> | AspNetUserClaimsCreateWithoutAspNetUsersInput[] | AspNetUserClaimsUncheckedCreateWithoutAspNetUsersInput[]
    connectOrCreate?: AspNetUserClaimsCreateOrConnectWithoutAspNetUsersInput | AspNetUserClaimsCreateOrConnectWithoutAspNetUsersInput[]
    upsert?: AspNetUserClaimsUpsertWithWhereUniqueWithoutAspNetUsersInput | AspNetUserClaimsUpsertWithWhereUniqueWithoutAspNetUsersInput[]
    createMany?: AspNetUserClaimsCreateManyAspNetUsersInputEnvelope
    set?: AspNetUserClaimsWhereUniqueInput | AspNetUserClaimsWhereUniqueInput[]
    disconnect?: AspNetUserClaimsWhereUniqueInput | AspNetUserClaimsWhereUniqueInput[]
    delete?: AspNetUserClaimsWhereUniqueInput | AspNetUserClaimsWhereUniqueInput[]
    connect?: AspNetUserClaimsWhereUniqueInput | AspNetUserClaimsWhereUniqueInput[]
    update?: AspNetUserClaimsUpdateWithWhereUniqueWithoutAspNetUsersInput | AspNetUserClaimsUpdateWithWhereUniqueWithoutAspNetUsersInput[]
    updateMany?: AspNetUserClaimsUpdateManyWithWhereWithoutAspNetUsersInput | AspNetUserClaimsUpdateManyWithWhereWithoutAspNetUsersInput[]
    deleteMany?: AspNetUserClaimsScalarWhereInput | AspNetUserClaimsScalarWhereInput[]
  }

  export type AspNetUserLoginsUpdateManyWithoutAspNetUsersNestedInput = {
    create?: XOR<AspNetUserLoginsCreateWithoutAspNetUsersInput, AspNetUserLoginsUncheckedCreateWithoutAspNetUsersInput> | AspNetUserLoginsCreateWithoutAspNetUsersInput[] | AspNetUserLoginsUncheckedCreateWithoutAspNetUsersInput[]
    connectOrCreate?: AspNetUserLoginsCreateOrConnectWithoutAspNetUsersInput | AspNetUserLoginsCreateOrConnectWithoutAspNetUsersInput[]
    upsert?: AspNetUserLoginsUpsertWithWhereUniqueWithoutAspNetUsersInput | AspNetUserLoginsUpsertWithWhereUniqueWithoutAspNetUsersInput[]
    createMany?: AspNetUserLoginsCreateManyAspNetUsersInputEnvelope
    set?: AspNetUserLoginsWhereUniqueInput | AspNetUserLoginsWhereUniqueInput[]
    disconnect?: AspNetUserLoginsWhereUniqueInput | AspNetUserLoginsWhereUniqueInput[]
    delete?: AspNetUserLoginsWhereUniqueInput | AspNetUserLoginsWhereUniqueInput[]
    connect?: AspNetUserLoginsWhereUniqueInput | AspNetUserLoginsWhereUniqueInput[]
    update?: AspNetUserLoginsUpdateWithWhereUniqueWithoutAspNetUsersInput | AspNetUserLoginsUpdateWithWhereUniqueWithoutAspNetUsersInput[]
    updateMany?: AspNetUserLoginsUpdateManyWithWhereWithoutAspNetUsersInput | AspNetUserLoginsUpdateManyWithWhereWithoutAspNetUsersInput[]
    deleteMany?: AspNetUserLoginsScalarWhereInput | AspNetUserLoginsScalarWhereInput[]
  }

  export type AspNetUserRolesUpdateManyWithoutAspNetUsersNestedInput = {
    create?: XOR<AspNetUserRolesCreateWithoutAspNetUsersInput, AspNetUserRolesUncheckedCreateWithoutAspNetUsersInput> | AspNetUserRolesCreateWithoutAspNetUsersInput[] | AspNetUserRolesUncheckedCreateWithoutAspNetUsersInput[]
    connectOrCreate?: AspNetUserRolesCreateOrConnectWithoutAspNetUsersInput | AspNetUserRolesCreateOrConnectWithoutAspNetUsersInput[]
    upsert?: AspNetUserRolesUpsertWithWhereUniqueWithoutAspNetUsersInput | AspNetUserRolesUpsertWithWhereUniqueWithoutAspNetUsersInput[]
    createMany?: AspNetUserRolesCreateManyAspNetUsersInputEnvelope
    set?: AspNetUserRolesWhereUniqueInput | AspNetUserRolesWhereUniqueInput[]
    disconnect?: AspNetUserRolesWhereUniqueInput | AspNetUserRolesWhereUniqueInput[]
    delete?: AspNetUserRolesWhereUniqueInput | AspNetUserRolesWhereUniqueInput[]
    connect?: AspNetUserRolesWhereUniqueInput | AspNetUserRolesWhereUniqueInput[]
    update?: AspNetUserRolesUpdateWithWhereUniqueWithoutAspNetUsersInput | AspNetUserRolesUpdateWithWhereUniqueWithoutAspNetUsersInput[]
    updateMany?: AspNetUserRolesUpdateManyWithWhereWithoutAspNetUsersInput | AspNetUserRolesUpdateManyWithWhereWithoutAspNetUsersInput[]
    deleteMany?: AspNetUserRolesScalarWhereInput | AspNetUserRolesScalarWhereInput[]
  }

  export type AspNetUserTokensUpdateManyWithoutAspNetUsersNestedInput = {
    create?: XOR<AspNetUserTokensCreateWithoutAspNetUsersInput, AspNetUserTokensUncheckedCreateWithoutAspNetUsersInput> | AspNetUserTokensCreateWithoutAspNetUsersInput[] | AspNetUserTokensUncheckedCreateWithoutAspNetUsersInput[]
    connectOrCreate?: AspNetUserTokensCreateOrConnectWithoutAspNetUsersInput | AspNetUserTokensCreateOrConnectWithoutAspNetUsersInput[]
    upsert?: AspNetUserTokensUpsertWithWhereUniqueWithoutAspNetUsersInput | AspNetUserTokensUpsertWithWhereUniqueWithoutAspNetUsersInput[]
    createMany?: AspNetUserTokensCreateManyAspNetUsersInputEnvelope
    set?: AspNetUserTokensWhereUniqueInput | AspNetUserTokensWhereUniqueInput[]
    disconnect?: AspNetUserTokensWhereUniqueInput | AspNetUserTokensWhereUniqueInput[]
    delete?: AspNetUserTokensWhereUniqueInput | AspNetUserTokensWhereUniqueInput[]
    connect?: AspNetUserTokensWhereUniqueInput | AspNetUserTokensWhereUniqueInput[]
    update?: AspNetUserTokensUpdateWithWhereUniqueWithoutAspNetUsersInput | AspNetUserTokensUpdateWithWhereUniqueWithoutAspNetUsersInput[]
    updateMany?: AspNetUserTokensUpdateManyWithWhereWithoutAspNetUsersInput | AspNetUserTokensUpdateManyWithWhereWithoutAspNetUsersInput[]
    deleteMany?: AspNetUserTokensScalarWhereInput | AspNetUserTokensScalarWhereInput[]
  }

  export type AspNetUserClaimsUncheckedUpdateManyWithoutAspNetUsersNestedInput = {
    create?: XOR<AspNetUserClaimsCreateWithoutAspNetUsersInput, AspNetUserClaimsUncheckedCreateWithoutAspNetUsersInput> | AspNetUserClaimsCreateWithoutAspNetUsersInput[] | AspNetUserClaimsUncheckedCreateWithoutAspNetUsersInput[]
    connectOrCreate?: AspNetUserClaimsCreateOrConnectWithoutAspNetUsersInput | AspNetUserClaimsCreateOrConnectWithoutAspNetUsersInput[]
    upsert?: AspNetUserClaimsUpsertWithWhereUniqueWithoutAspNetUsersInput | AspNetUserClaimsUpsertWithWhereUniqueWithoutAspNetUsersInput[]
    createMany?: AspNetUserClaimsCreateManyAspNetUsersInputEnvelope
    set?: AspNetUserClaimsWhereUniqueInput | AspNetUserClaimsWhereUniqueInput[]
    disconnect?: AspNetUserClaimsWhereUniqueInput | AspNetUserClaimsWhereUniqueInput[]
    delete?: AspNetUserClaimsWhereUniqueInput | AspNetUserClaimsWhereUniqueInput[]
    connect?: AspNetUserClaimsWhereUniqueInput | AspNetUserClaimsWhereUniqueInput[]
    update?: AspNetUserClaimsUpdateWithWhereUniqueWithoutAspNetUsersInput | AspNetUserClaimsUpdateWithWhereUniqueWithoutAspNetUsersInput[]
    updateMany?: AspNetUserClaimsUpdateManyWithWhereWithoutAspNetUsersInput | AspNetUserClaimsUpdateManyWithWhereWithoutAspNetUsersInput[]
    deleteMany?: AspNetUserClaimsScalarWhereInput | AspNetUserClaimsScalarWhereInput[]
  }

  export type AspNetUserLoginsUncheckedUpdateManyWithoutAspNetUsersNestedInput = {
    create?: XOR<AspNetUserLoginsCreateWithoutAspNetUsersInput, AspNetUserLoginsUncheckedCreateWithoutAspNetUsersInput> | AspNetUserLoginsCreateWithoutAspNetUsersInput[] | AspNetUserLoginsUncheckedCreateWithoutAspNetUsersInput[]
    connectOrCreate?: AspNetUserLoginsCreateOrConnectWithoutAspNetUsersInput | AspNetUserLoginsCreateOrConnectWithoutAspNetUsersInput[]
    upsert?: AspNetUserLoginsUpsertWithWhereUniqueWithoutAspNetUsersInput | AspNetUserLoginsUpsertWithWhereUniqueWithoutAspNetUsersInput[]
    createMany?: AspNetUserLoginsCreateManyAspNetUsersInputEnvelope
    set?: AspNetUserLoginsWhereUniqueInput | AspNetUserLoginsWhereUniqueInput[]
    disconnect?: AspNetUserLoginsWhereUniqueInput | AspNetUserLoginsWhereUniqueInput[]
    delete?: AspNetUserLoginsWhereUniqueInput | AspNetUserLoginsWhereUniqueInput[]
    connect?: AspNetUserLoginsWhereUniqueInput | AspNetUserLoginsWhereUniqueInput[]
    update?: AspNetUserLoginsUpdateWithWhereUniqueWithoutAspNetUsersInput | AspNetUserLoginsUpdateWithWhereUniqueWithoutAspNetUsersInput[]
    updateMany?: AspNetUserLoginsUpdateManyWithWhereWithoutAspNetUsersInput | AspNetUserLoginsUpdateManyWithWhereWithoutAspNetUsersInput[]
    deleteMany?: AspNetUserLoginsScalarWhereInput | AspNetUserLoginsScalarWhereInput[]
  }

  export type AspNetUserRolesUncheckedUpdateManyWithoutAspNetUsersNestedInput = {
    create?: XOR<AspNetUserRolesCreateWithoutAspNetUsersInput, AspNetUserRolesUncheckedCreateWithoutAspNetUsersInput> | AspNetUserRolesCreateWithoutAspNetUsersInput[] | AspNetUserRolesUncheckedCreateWithoutAspNetUsersInput[]
    connectOrCreate?: AspNetUserRolesCreateOrConnectWithoutAspNetUsersInput | AspNetUserRolesCreateOrConnectWithoutAspNetUsersInput[]
    upsert?: AspNetUserRolesUpsertWithWhereUniqueWithoutAspNetUsersInput | AspNetUserRolesUpsertWithWhereUniqueWithoutAspNetUsersInput[]
    createMany?: AspNetUserRolesCreateManyAspNetUsersInputEnvelope
    set?: AspNetUserRolesWhereUniqueInput | AspNetUserRolesWhereUniqueInput[]
    disconnect?: AspNetUserRolesWhereUniqueInput | AspNetUserRolesWhereUniqueInput[]
    delete?: AspNetUserRolesWhereUniqueInput | AspNetUserRolesWhereUniqueInput[]
    connect?: AspNetUserRolesWhereUniqueInput | AspNetUserRolesWhereUniqueInput[]
    update?: AspNetUserRolesUpdateWithWhereUniqueWithoutAspNetUsersInput | AspNetUserRolesUpdateWithWhereUniqueWithoutAspNetUsersInput[]
    updateMany?: AspNetUserRolesUpdateManyWithWhereWithoutAspNetUsersInput | AspNetUserRolesUpdateManyWithWhereWithoutAspNetUsersInput[]
    deleteMany?: AspNetUserRolesScalarWhereInput | AspNetUserRolesScalarWhereInput[]
  }

  export type AspNetUserTokensUncheckedUpdateManyWithoutAspNetUsersNestedInput = {
    create?: XOR<AspNetUserTokensCreateWithoutAspNetUsersInput, AspNetUserTokensUncheckedCreateWithoutAspNetUsersInput> | AspNetUserTokensCreateWithoutAspNetUsersInput[] | AspNetUserTokensUncheckedCreateWithoutAspNetUsersInput[]
    connectOrCreate?: AspNetUserTokensCreateOrConnectWithoutAspNetUsersInput | AspNetUserTokensCreateOrConnectWithoutAspNetUsersInput[]
    upsert?: AspNetUserTokensUpsertWithWhereUniqueWithoutAspNetUsersInput | AspNetUserTokensUpsertWithWhereUniqueWithoutAspNetUsersInput[]
    createMany?: AspNetUserTokensCreateManyAspNetUsersInputEnvelope
    set?: AspNetUserTokensWhereUniqueInput | AspNetUserTokensWhereUniqueInput[]
    disconnect?: AspNetUserTokensWhereUniqueInput | AspNetUserTokensWhereUniqueInput[]
    delete?: AspNetUserTokensWhereUniqueInput | AspNetUserTokensWhereUniqueInput[]
    connect?: AspNetUserTokensWhereUniqueInput | AspNetUserTokensWhereUniqueInput[]
    update?: AspNetUserTokensUpdateWithWhereUniqueWithoutAspNetUsersInput | AspNetUserTokensUpdateWithWhereUniqueWithoutAspNetUsersInput[]
    updateMany?: AspNetUserTokensUpdateManyWithWhereWithoutAspNetUsersInput | AspNetUserTokensUpdateManyWithWhereWithoutAspNetUsersInput[]
    deleteMany?: AspNetUserTokensScalarWhereInput | AspNetUserTokensScalarWhereInput[]
  }

  export type AspNetUsersCreateNestedOneWithoutAspNetUserTokensInput = {
    create?: XOR<AspNetUsersCreateWithoutAspNetUserTokensInput, AspNetUsersUncheckedCreateWithoutAspNetUserTokensInput>
    connectOrCreate?: AspNetUsersCreateOrConnectWithoutAspNetUserTokensInput
    connect?: AspNetUsersWhereUniqueInput
  }

  export type AspNetUsersUpdateOneRequiredWithoutAspNetUserTokensNestedInput = {
    create?: XOR<AspNetUsersCreateWithoutAspNetUserTokensInput, AspNetUsersUncheckedCreateWithoutAspNetUserTokensInput>
    connectOrCreate?: AspNetUsersCreateOrConnectWithoutAspNetUserTokensInput
    upsert?: AspNetUsersUpsertWithoutAspNetUserTokensInput
    connect?: AspNetUsersWhereUniqueInput
    update?: XOR<XOR<AspNetUsersUpdateToOneWithWhereWithoutAspNetUserTokensInput, AspNetUsersUpdateWithoutAspNetUserTokensInput>, AspNetUsersUncheckedUpdateWithoutAspNetUserTokensInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableBytesFieldUpdateOperationsInput = {
    set?: Uint8Array | null
  }

  export type VisaProvisionedTokensCreateNestedManyWithoutTokenStatusesInput = {
    create?: XOR<VisaProvisionedTokensCreateWithoutTokenStatusesInput, VisaProvisionedTokensUncheckedCreateWithoutTokenStatusesInput> | VisaProvisionedTokensCreateWithoutTokenStatusesInput[] | VisaProvisionedTokensUncheckedCreateWithoutTokenStatusesInput[]
    connectOrCreate?: VisaProvisionedTokensCreateOrConnectWithoutTokenStatusesInput | VisaProvisionedTokensCreateOrConnectWithoutTokenStatusesInput[]
    createMany?: VisaProvisionedTokensCreateManyTokenStatusesInputEnvelope
    connect?: VisaProvisionedTokensWhereUniqueInput | VisaProvisionedTokensWhereUniqueInput[]
  }

  export type VisaProvisionedTokensUncheckedCreateNestedManyWithoutTokenStatusesInput = {
    create?: XOR<VisaProvisionedTokensCreateWithoutTokenStatusesInput, VisaProvisionedTokensUncheckedCreateWithoutTokenStatusesInput> | VisaProvisionedTokensCreateWithoutTokenStatusesInput[] | VisaProvisionedTokensUncheckedCreateWithoutTokenStatusesInput[]
    connectOrCreate?: VisaProvisionedTokensCreateOrConnectWithoutTokenStatusesInput | VisaProvisionedTokensCreateOrConnectWithoutTokenStatusesInput[]
    createMany?: VisaProvisionedTokensCreateManyTokenStatusesInputEnvelope
    connect?: VisaProvisionedTokensWhereUniqueInput | VisaProvisionedTokensWhereUniqueInput[]
  }

  export type VisaProvisionedTokensUpdateManyWithoutTokenStatusesNestedInput = {
    create?: XOR<VisaProvisionedTokensCreateWithoutTokenStatusesInput, VisaProvisionedTokensUncheckedCreateWithoutTokenStatusesInput> | VisaProvisionedTokensCreateWithoutTokenStatusesInput[] | VisaProvisionedTokensUncheckedCreateWithoutTokenStatusesInput[]
    connectOrCreate?: VisaProvisionedTokensCreateOrConnectWithoutTokenStatusesInput | VisaProvisionedTokensCreateOrConnectWithoutTokenStatusesInput[]
    upsert?: VisaProvisionedTokensUpsertWithWhereUniqueWithoutTokenStatusesInput | VisaProvisionedTokensUpsertWithWhereUniqueWithoutTokenStatusesInput[]
    createMany?: VisaProvisionedTokensCreateManyTokenStatusesInputEnvelope
    set?: VisaProvisionedTokensWhereUniqueInput | VisaProvisionedTokensWhereUniqueInput[]
    disconnect?: VisaProvisionedTokensWhereUniqueInput | VisaProvisionedTokensWhereUniqueInput[]
    delete?: VisaProvisionedTokensWhereUniqueInput | VisaProvisionedTokensWhereUniqueInput[]
    connect?: VisaProvisionedTokensWhereUniqueInput | VisaProvisionedTokensWhereUniqueInput[]
    update?: VisaProvisionedTokensUpdateWithWhereUniqueWithoutTokenStatusesInput | VisaProvisionedTokensUpdateWithWhereUniqueWithoutTokenStatusesInput[]
    updateMany?: VisaProvisionedTokensUpdateManyWithWhereWithoutTokenStatusesInput | VisaProvisionedTokensUpdateManyWithWhereWithoutTokenStatusesInput[]
    deleteMany?: VisaProvisionedTokensScalarWhereInput | VisaProvisionedTokensScalarWhereInput[]
  }

  export type VisaProvisionedTokensUncheckedUpdateManyWithoutTokenStatusesNestedInput = {
    create?: XOR<VisaProvisionedTokensCreateWithoutTokenStatusesInput, VisaProvisionedTokensUncheckedCreateWithoutTokenStatusesInput> | VisaProvisionedTokensCreateWithoutTokenStatusesInput[] | VisaProvisionedTokensUncheckedCreateWithoutTokenStatusesInput[]
    connectOrCreate?: VisaProvisionedTokensCreateOrConnectWithoutTokenStatusesInput | VisaProvisionedTokensCreateOrConnectWithoutTokenStatusesInput[]
    upsert?: VisaProvisionedTokensUpsertWithWhereUniqueWithoutTokenStatusesInput | VisaProvisionedTokensUpsertWithWhereUniqueWithoutTokenStatusesInput[]
    createMany?: VisaProvisionedTokensCreateManyTokenStatusesInputEnvelope
    set?: VisaProvisionedTokensWhereUniqueInput | VisaProvisionedTokensWhereUniqueInput[]
    disconnect?: VisaProvisionedTokensWhereUniqueInput | VisaProvisionedTokensWhereUniqueInput[]
    delete?: VisaProvisionedTokensWhereUniqueInput | VisaProvisionedTokensWhereUniqueInput[]
    connect?: VisaProvisionedTokensWhereUniqueInput | VisaProvisionedTokensWhereUniqueInput[]
    update?: VisaProvisionedTokensUpdateWithWhereUniqueWithoutTokenStatusesInput | VisaProvisionedTokensUpdateWithWhereUniqueWithoutTokenStatusesInput[]
    updateMany?: VisaProvisionedTokensUpdateManyWithWhereWithoutTokenStatusesInput | VisaProvisionedTokensUpdateManyWithWhereWithoutTokenStatusesInput[]
    deleteMany?: VisaProvisionedTokensScalarWhereInput | VisaProvisionedTokensScalarWhereInput[]
  }

  export type TokenStatusesCreateNestedOneWithoutVisaProvisionedTokensInput = {
    create?: XOR<TokenStatusesCreateWithoutVisaProvisionedTokensInput, TokenStatusesUncheckedCreateWithoutVisaProvisionedTokensInput>
    connectOrCreate?: TokenStatusesCreateOrConnectWithoutVisaProvisionedTokensInput
    connect?: TokenStatusesWhereUniqueInput
  }

  export type TokenStatusesUpdateOneWithoutVisaProvisionedTokensNestedInput = {
    create?: XOR<TokenStatusesCreateWithoutVisaProvisionedTokensInput, TokenStatusesUncheckedCreateWithoutVisaProvisionedTokensInput>
    connectOrCreate?: TokenStatusesCreateOrConnectWithoutVisaProvisionedTokensInput
    upsert?: TokenStatusesUpsertWithoutVisaProvisionedTokensInput
    disconnect?: TokenStatusesWhereInput | boolean
    delete?: TokenStatusesWhereInput | boolean
    connect?: TokenStatusesWhereUniqueInput
    update?: XOR<XOR<TokenStatusesUpdateToOneWithWhereWithoutVisaProvisionedTokensInput, TokenStatusesUpdateWithoutVisaProvisionedTokensInput>, TokenStatusesUncheckedUpdateWithoutVisaProvisionedTokensInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBytesNullableFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null
    in?: Uint8Array[] | null
    notIn?: Uint8Array[] | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Uint8Array | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null
    in?: Uint8Array[] | null
    notIn?: Uint8Array[] | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Uint8Array | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }

  export type AspNetRolesCreateWithoutAspNetRoleClaimsInput = {
    Id: string
    Name?: string | null
    NormalizedName?: string | null
    ConcurrencyStamp?: string | null
    AspNetUserRoles?: AspNetUserRolesCreateNestedManyWithoutAspNetRolesInput
  }

  export type AspNetRolesUncheckedCreateWithoutAspNetRoleClaimsInput = {
    Id: string
    Name?: string | null
    NormalizedName?: string | null
    ConcurrencyStamp?: string | null
    AspNetUserRoles?: AspNetUserRolesUncheckedCreateNestedManyWithoutAspNetRolesInput
  }

  export type AspNetRolesCreateOrConnectWithoutAspNetRoleClaimsInput = {
    where: AspNetRolesWhereUniqueInput
    create: XOR<AspNetRolesCreateWithoutAspNetRoleClaimsInput, AspNetRolesUncheckedCreateWithoutAspNetRoleClaimsInput>
  }

  export type AspNetRolesUpsertWithoutAspNetRoleClaimsInput = {
    update: XOR<AspNetRolesUpdateWithoutAspNetRoleClaimsInput, AspNetRolesUncheckedUpdateWithoutAspNetRoleClaimsInput>
    create: XOR<AspNetRolesCreateWithoutAspNetRoleClaimsInput, AspNetRolesUncheckedCreateWithoutAspNetRoleClaimsInput>
    where?: AspNetRolesWhereInput
  }

  export type AspNetRolesUpdateToOneWithWhereWithoutAspNetRoleClaimsInput = {
    where?: AspNetRolesWhereInput
    data: XOR<AspNetRolesUpdateWithoutAspNetRoleClaimsInput, AspNetRolesUncheckedUpdateWithoutAspNetRoleClaimsInput>
  }

  export type AspNetRolesUpdateWithoutAspNetRoleClaimsInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedName?: NullableStringFieldUpdateOperationsInput | string | null
    ConcurrencyStamp?: NullableStringFieldUpdateOperationsInput | string | null
    AspNetUserRoles?: AspNetUserRolesUpdateManyWithoutAspNetRolesNestedInput
  }

  export type AspNetRolesUncheckedUpdateWithoutAspNetRoleClaimsInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedName?: NullableStringFieldUpdateOperationsInput | string | null
    ConcurrencyStamp?: NullableStringFieldUpdateOperationsInput | string | null
    AspNetUserRoles?: AspNetUserRolesUncheckedUpdateManyWithoutAspNetRolesNestedInput
  }

  export type AspNetRoleClaimsCreateWithoutAspNetRolesInput = {
    ClaimType?: string | null
    ClaimValue?: string | null
  }

  export type AspNetRoleClaimsUncheckedCreateWithoutAspNetRolesInput = {
    Id?: number
    ClaimType?: string | null
    ClaimValue?: string | null
  }

  export type AspNetRoleClaimsCreateOrConnectWithoutAspNetRolesInput = {
    where: AspNetRoleClaimsWhereUniqueInput
    create: XOR<AspNetRoleClaimsCreateWithoutAspNetRolesInput, AspNetRoleClaimsUncheckedCreateWithoutAspNetRolesInput>
  }

  export type AspNetRoleClaimsCreateManyAspNetRolesInputEnvelope = {
    data: AspNetRoleClaimsCreateManyAspNetRolesInput | AspNetRoleClaimsCreateManyAspNetRolesInput[]
  }

  export type AspNetUserRolesCreateWithoutAspNetRolesInput = {
    AspNetUsers: AspNetUsersCreateNestedOneWithoutAspNetUserRolesInput
  }

  export type AspNetUserRolesUncheckedCreateWithoutAspNetRolesInput = {
    UserId: string
  }

  export type AspNetUserRolesCreateOrConnectWithoutAspNetRolesInput = {
    where: AspNetUserRolesWhereUniqueInput
    create: XOR<AspNetUserRolesCreateWithoutAspNetRolesInput, AspNetUserRolesUncheckedCreateWithoutAspNetRolesInput>
  }

  export type AspNetUserRolesCreateManyAspNetRolesInputEnvelope = {
    data: AspNetUserRolesCreateManyAspNetRolesInput | AspNetUserRolesCreateManyAspNetRolesInput[]
  }

  export type AspNetRoleClaimsUpsertWithWhereUniqueWithoutAspNetRolesInput = {
    where: AspNetRoleClaimsWhereUniqueInput
    update: XOR<AspNetRoleClaimsUpdateWithoutAspNetRolesInput, AspNetRoleClaimsUncheckedUpdateWithoutAspNetRolesInput>
    create: XOR<AspNetRoleClaimsCreateWithoutAspNetRolesInput, AspNetRoleClaimsUncheckedCreateWithoutAspNetRolesInput>
  }

  export type AspNetRoleClaimsUpdateWithWhereUniqueWithoutAspNetRolesInput = {
    where: AspNetRoleClaimsWhereUniqueInput
    data: XOR<AspNetRoleClaimsUpdateWithoutAspNetRolesInput, AspNetRoleClaimsUncheckedUpdateWithoutAspNetRolesInput>
  }

  export type AspNetRoleClaimsUpdateManyWithWhereWithoutAspNetRolesInput = {
    where: AspNetRoleClaimsScalarWhereInput
    data: XOR<AspNetRoleClaimsUpdateManyMutationInput, AspNetRoleClaimsUncheckedUpdateManyWithoutAspNetRolesInput>
  }

  export type AspNetRoleClaimsScalarWhereInput = {
    AND?: AspNetRoleClaimsScalarWhereInput | AspNetRoleClaimsScalarWhereInput[]
    OR?: AspNetRoleClaimsScalarWhereInput[]
    NOT?: AspNetRoleClaimsScalarWhereInput | AspNetRoleClaimsScalarWhereInput[]
    Id?: IntFilter<"AspNetRoleClaims"> | number
    RoleId?: StringFilter<"AspNetRoleClaims"> | string
    ClaimType?: StringNullableFilter<"AspNetRoleClaims"> | string | null
    ClaimValue?: StringNullableFilter<"AspNetRoleClaims"> | string | null
  }

  export type AspNetUserRolesUpsertWithWhereUniqueWithoutAspNetRolesInput = {
    where: AspNetUserRolesWhereUniqueInput
    update: XOR<AspNetUserRolesUpdateWithoutAspNetRolesInput, AspNetUserRolesUncheckedUpdateWithoutAspNetRolesInput>
    create: XOR<AspNetUserRolesCreateWithoutAspNetRolesInput, AspNetUserRolesUncheckedCreateWithoutAspNetRolesInput>
  }

  export type AspNetUserRolesUpdateWithWhereUniqueWithoutAspNetRolesInput = {
    where: AspNetUserRolesWhereUniqueInput
    data: XOR<AspNetUserRolesUpdateWithoutAspNetRolesInput, AspNetUserRolesUncheckedUpdateWithoutAspNetRolesInput>
  }

  export type AspNetUserRolesUpdateManyWithWhereWithoutAspNetRolesInput = {
    where: AspNetUserRolesScalarWhereInput
    data: XOR<AspNetUserRolesUpdateManyMutationInput, AspNetUserRolesUncheckedUpdateManyWithoutAspNetRolesInput>
  }

  export type AspNetUserRolesScalarWhereInput = {
    AND?: AspNetUserRolesScalarWhereInput | AspNetUserRolesScalarWhereInput[]
    OR?: AspNetUserRolesScalarWhereInput[]
    NOT?: AspNetUserRolesScalarWhereInput | AspNetUserRolesScalarWhereInput[]
    UserId?: StringFilter<"AspNetUserRoles"> | string
    RoleId?: StringFilter<"AspNetUserRoles"> | string
  }

  export type AspNetUsersCreateWithoutAspNetUserClaimsInput = {
    Id: string
    UserName?: string | null
    NormalizedUserName?: string | null
    Email?: string | null
    NormalizedEmail?: string | null
    EmailConfirmed: boolean
    PasswordHash?: string | null
    SecurityStamp?: string | null
    ConcurrencyStamp?: string | null
    PhoneNumber?: string | null
    PhoneNumberConfirmed: boolean
    TwoFactorEnabled: boolean
    LockoutEnd?: Date | string | null
    LockoutEnabled: boolean
    AccessFailedCount: number
    PasswordValidUntil: Date | string
    DeviceId?: string | null
    FcmToken?: string | null
    FullName?: string | null
    AspNetUserLogins?: AspNetUserLoginsCreateNestedManyWithoutAspNetUsersInput
    AspNetUserRoles?: AspNetUserRolesCreateNestedManyWithoutAspNetUsersInput
    AspNetUserTokens?: AspNetUserTokensCreateNestedManyWithoutAspNetUsersInput
  }

  export type AspNetUsersUncheckedCreateWithoutAspNetUserClaimsInput = {
    Id: string
    UserName?: string | null
    NormalizedUserName?: string | null
    Email?: string | null
    NormalizedEmail?: string | null
    EmailConfirmed: boolean
    PasswordHash?: string | null
    SecurityStamp?: string | null
    ConcurrencyStamp?: string | null
    PhoneNumber?: string | null
    PhoneNumberConfirmed: boolean
    TwoFactorEnabled: boolean
    LockoutEnd?: Date | string | null
    LockoutEnabled: boolean
    AccessFailedCount: number
    PasswordValidUntil: Date | string
    DeviceId?: string | null
    FcmToken?: string | null
    FullName?: string | null
    AspNetUserLogins?: AspNetUserLoginsUncheckedCreateNestedManyWithoutAspNetUsersInput
    AspNetUserRoles?: AspNetUserRolesUncheckedCreateNestedManyWithoutAspNetUsersInput
    AspNetUserTokens?: AspNetUserTokensUncheckedCreateNestedManyWithoutAspNetUsersInput
  }

  export type AspNetUsersCreateOrConnectWithoutAspNetUserClaimsInput = {
    where: AspNetUsersWhereUniqueInput
    create: XOR<AspNetUsersCreateWithoutAspNetUserClaimsInput, AspNetUsersUncheckedCreateWithoutAspNetUserClaimsInput>
  }

  export type AspNetUsersUpsertWithoutAspNetUserClaimsInput = {
    update: XOR<AspNetUsersUpdateWithoutAspNetUserClaimsInput, AspNetUsersUncheckedUpdateWithoutAspNetUserClaimsInput>
    create: XOR<AspNetUsersCreateWithoutAspNetUserClaimsInput, AspNetUsersUncheckedCreateWithoutAspNetUserClaimsInput>
    where?: AspNetUsersWhereInput
  }

  export type AspNetUsersUpdateToOneWithWhereWithoutAspNetUserClaimsInput = {
    where?: AspNetUsersWhereInput
    data: XOR<AspNetUsersUpdateWithoutAspNetUserClaimsInput, AspNetUsersUncheckedUpdateWithoutAspNetUserClaimsInput>
  }

  export type AspNetUsersUpdateWithoutAspNetUserClaimsInput = {
    Id?: StringFieldUpdateOperationsInput | string
    UserName?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedUserName?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    EmailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    PasswordHash?: NullableStringFieldUpdateOperationsInput | string | null
    SecurityStamp?: NullableStringFieldUpdateOperationsInput | string | null
    ConcurrencyStamp?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumberConfirmed?: BoolFieldUpdateOperationsInput | boolean
    TwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    LockoutEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LockoutEnabled?: BoolFieldUpdateOperationsInput | boolean
    AccessFailedCount?: IntFieldUpdateOperationsInput | number
    PasswordValidUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    DeviceId?: NullableStringFieldUpdateOperationsInput | string | null
    FcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    FullName?: NullableStringFieldUpdateOperationsInput | string | null
    AspNetUserLogins?: AspNetUserLoginsUpdateManyWithoutAspNetUsersNestedInput
    AspNetUserRoles?: AspNetUserRolesUpdateManyWithoutAspNetUsersNestedInput
    AspNetUserTokens?: AspNetUserTokensUpdateManyWithoutAspNetUsersNestedInput
  }

  export type AspNetUsersUncheckedUpdateWithoutAspNetUserClaimsInput = {
    Id?: StringFieldUpdateOperationsInput | string
    UserName?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedUserName?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    EmailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    PasswordHash?: NullableStringFieldUpdateOperationsInput | string | null
    SecurityStamp?: NullableStringFieldUpdateOperationsInput | string | null
    ConcurrencyStamp?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumberConfirmed?: BoolFieldUpdateOperationsInput | boolean
    TwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    LockoutEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LockoutEnabled?: BoolFieldUpdateOperationsInput | boolean
    AccessFailedCount?: IntFieldUpdateOperationsInput | number
    PasswordValidUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    DeviceId?: NullableStringFieldUpdateOperationsInput | string | null
    FcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    FullName?: NullableStringFieldUpdateOperationsInput | string | null
    AspNetUserLogins?: AspNetUserLoginsUncheckedUpdateManyWithoutAspNetUsersNestedInput
    AspNetUserRoles?: AspNetUserRolesUncheckedUpdateManyWithoutAspNetUsersNestedInput
    AspNetUserTokens?: AspNetUserTokensUncheckedUpdateManyWithoutAspNetUsersNestedInput
  }

  export type AspNetUsersCreateWithoutAspNetUserLoginsInput = {
    Id: string
    UserName?: string | null
    NormalizedUserName?: string | null
    Email?: string | null
    NormalizedEmail?: string | null
    EmailConfirmed: boolean
    PasswordHash?: string | null
    SecurityStamp?: string | null
    ConcurrencyStamp?: string | null
    PhoneNumber?: string | null
    PhoneNumberConfirmed: boolean
    TwoFactorEnabled: boolean
    LockoutEnd?: Date | string | null
    LockoutEnabled: boolean
    AccessFailedCount: number
    PasswordValidUntil: Date | string
    DeviceId?: string | null
    FcmToken?: string | null
    FullName?: string | null
    AspNetUserClaims?: AspNetUserClaimsCreateNestedManyWithoutAspNetUsersInput
    AspNetUserRoles?: AspNetUserRolesCreateNestedManyWithoutAspNetUsersInput
    AspNetUserTokens?: AspNetUserTokensCreateNestedManyWithoutAspNetUsersInput
  }

  export type AspNetUsersUncheckedCreateWithoutAspNetUserLoginsInput = {
    Id: string
    UserName?: string | null
    NormalizedUserName?: string | null
    Email?: string | null
    NormalizedEmail?: string | null
    EmailConfirmed: boolean
    PasswordHash?: string | null
    SecurityStamp?: string | null
    ConcurrencyStamp?: string | null
    PhoneNumber?: string | null
    PhoneNumberConfirmed: boolean
    TwoFactorEnabled: boolean
    LockoutEnd?: Date | string | null
    LockoutEnabled: boolean
    AccessFailedCount: number
    PasswordValidUntil: Date | string
    DeviceId?: string | null
    FcmToken?: string | null
    FullName?: string | null
    AspNetUserClaims?: AspNetUserClaimsUncheckedCreateNestedManyWithoutAspNetUsersInput
    AspNetUserRoles?: AspNetUserRolesUncheckedCreateNestedManyWithoutAspNetUsersInput
    AspNetUserTokens?: AspNetUserTokensUncheckedCreateNestedManyWithoutAspNetUsersInput
  }

  export type AspNetUsersCreateOrConnectWithoutAspNetUserLoginsInput = {
    where: AspNetUsersWhereUniqueInput
    create: XOR<AspNetUsersCreateWithoutAspNetUserLoginsInput, AspNetUsersUncheckedCreateWithoutAspNetUserLoginsInput>
  }

  export type AspNetUsersUpsertWithoutAspNetUserLoginsInput = {
    update: XOR<AspNetUsersUpdateWithoutAspNetUserLoginsInput, AspNetUsersUncheckedUpdateWithoutAspNetUserLoginsInput>
    create: XOR<AspNetUsersCreateWithoutAspNetUserLoginsInput, AspNetUsersUncheckedCreateWithoutAspNetUserLoginsInput>
    where?: AspNetUsersWhereInput
  }

  export type AspNetUsersUpdateToOneWithWhereWithoutAspNetUserLoginsInput = {
    where?: AspNetUsersWhereInput
    data: XOR<AspNetUsersUpdateWithoutAspNetUserLoginsInput, AspNetUsersUncheckedUpdateWithoutAspNetUserLoginsInput>
  }

  export type AspNetUsersUpdateWithoutAspNetUserLoginsInput = {
    Id?: StringFieldUpdateOperationsInput | string
    UserName?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedUserName?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    EmailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    PasswordHash?: NullableStringFieldUpdateOperationsInput | string | null
    SecurityStamp?: NullableStringFieldUpdateOperationsInput | string | null
    ConcurrencyStamp?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumberConfirmed?: BoolFieldUpdateOperationsInput | boolean
    TwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    LockoutEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LockoutEnabled?: BoolFieldUpdateOperationsInput | boolean
    AccessFailedCount?: IntFieldUpdateOperationsInput | number
    PasswordValidUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    DeviceId?: NullableStringFieldUpdateOperationsInput | string | null
    FcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    FullName?: NullableStringFieldUpdateOperationsInput | string | null
    AspNetUserClaims?: AspNetUserClaimsUpdateManyWithoutAspNetUsersNestedInput
    AspNetUserRoles?: AspNetUserRolesUpdateManyWithoutAspNetUsersNestedInput
    AspNetUserTokens?: AspNetUserTokensUpdateManyWithoutAspNetUsersNestedInput
  }

  export type AspNetUsersUncheckedUpdateWithoutAspNetUserLoginsInput = {
    Id?: StringFieldUpdateOperationsInput | string
    UserName?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedUserName?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    EmailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    PasswordHash?: NullableStringFieldUpdateOperationsInput | string | null
    SecurityStamp?: NullableStringFieldUpdateOperationsInput | string | null
    ConcurrencyStamp?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumberConfirmed?: BoolFieldUpdateOperationsInput | boolean
    TwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    LockoutEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LockoutEnabled?: BoolFieldUpdateOperationsInput | boolean
    AccessFailedCount?: IntFieldUpdateOperationsInput | number
    PasswordValidUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    DeviceId?: NullableStringFieldUpdateOperationsInput | string | null
    FcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    FullName?: NullableStringFieldUpdateOperationsInput | string | null
    AspNetUserClaims?: AspNetUserClaimsUncheckedUpdateManyWithoutAspNetUsersNestedInput
    AspNetUserRoles?: AspNetUserRolesUncheckedUpdateManyWithoutAspNetUsersNestedInput
    AspNetUserTokens?: AspNetUserTokensUncheckedUpdateManyWithoutAspNetUsersNestedInput
  }

  export type AspNetRolesCreateWithoutAspNetUserRolesInput = {
    Id: string
    Name?: string | null
    NormalizedName?: string | null
    ConcurrencyStamp?: string | null
    AspNetRoleClaims?: AspNetRoleClaimsCreateNestedManyWithoutAspNetRolesInput
  }

  export type AspNetRolesUncheckedCreateWithoutAspNetUserRolesInput = {
    Id: string
    Name?: string | null
    NormalizedName?: string | null
    ConcurrencyStamp?: string | null
    AspNetRoleClaims?: AspNetRoleClaimsUncheckedCreateNestedManyWithoutAspNetRolesInput
  }

  export type AspNetRolesCreateOrConnectWithoutAspNetUserRolesInput = {
    where: AspNetRolesWhereUniqueInput
    create: XOR<AspNetRolesCreateWithoutAspNetUserRolesInput, AspNetRolesUncheckedCreateWithoutAspNetUserRolesInput>
  }

  export type AspNetUsersCreateWithoutAspNetUserRolesInput = {
    Id: string
    UserName?: string | null
    NormalizedUserName?: string | null
    Email?: string | null
    NormalizedEmail?: string | null
    EmailConfirmed: boolean
    PasswordHash?: string | null
    SecurityStamp?: string | null
    ConcurrencyStamp?: string | null
    PhoneNumber?: string | null
    PhoneNumberConfirmed: boolean
    TwoFactorEnabled: boolean
    LockoutEnd?: Date | string | null
    LockoutEnabled: boolean
    AccessFailedCount: number
    PasswordValidUntil: Date | string
    DeviceId?: string | null
    FcmToken?: string | null
    FullName?: string | null
    AspNetUserClaims?: AspNetUserClaimsCreateNestedManyWithoutAspNetUsersInput
    AspNetUserLogins?: AspNetUserLoginsCreateNestedManyWithoutAspNetUsersInput
    AspNetUserTokens?: AspNetUserTokensCreateNestedManyWithoutAspNetUsersInput
  }

  export type AspNetUsersUncheckedCreateWithoutAspNetUserRolesInput = {
    Id: string
    UserName?: string | null
    NormalizedUserName?: string | null
    Email?: string | null
    NormalizedEmail?: string | null
    EmailConfirmed: boolean
    PasswordHash?: string | null
    SecurityStamp?: string | null
    ConcurrencyStamp?: string | null
    PhoneNumber?: string | null
    PhoneNumberConfirmed: boolean
    TwoFactorEnabled: boolean
    LockoutEnd?: Date | string | null
    LockoutEnabled: boolean
    AccessFailedCount: number
    PasswordValidUntil: Date | string
    DeviceId?: string | null
    FcmToken?: string | null
    FullName?: string | null
    AspNetUserClaims?: AspNetUserClaimsUncheckedCreateNestedManyWithoutAspNetUsersInput
    AspNetUserLogins?: AspNetUserLoginsUncheckedCreateNestedManyWithoutAspNetUsersInput
    AspNetUserTokens?: AspNetUserTokensUncheckedCreateNestedManyWithoutAspNetUsersInput
  }

  export type AspNetUsersCreateOrConnectWithoutAspNetUserRolesInput = {
    where: AspNetUsersWhereUniqueInput
    create: XOR<AspNetUsersCreateWithoutAspNetUserRolesInput, AspNetUsersUncheckedCreateWithoutAspNetUserRolesInput>
  }

  export type AspNetRolesUpsertWithoutAspNetUserRolesInput = {
    update: XOR<AspNetRolesUpdateWithoutAspNetUserRolesInput, AspNetRolesUncheckedUpdateWithoutAspNetUserRolesInput>
    create: XOR<AspNetRolesCreateWithoutAspNetUserRolesInput, AspNetRolesUncheckedCreateWithoutAspNetUserRolesInput>
    where?: AspNetRolesWhereInput
  }

  export type AspNetRolesUpdateToOneWithWhereWithoutAspNetUserRolesInput = {
    where?: AspNetRolesWhereInput
    data: XOR<AspNetRolesUpdateWithoutAspNetUserRolesInput, AspNetRolesUncheckedUpdateWithoutAspNetUserRolesInput>
  }

  export type AspNetRolesUpdateWithoutAspNetUserRolesInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedName?: NullableStringFieldUpdateOperationsInput | string | null
    ConcurrencyStamp?: NullableStringFieldUpdateOperationsInput | string | null
    AspNetRoleClaims?: AspNetRoleClaimsUpdateManyWithoutAspNetRolesNestedInput
  }

  export type AspNetRolesUncheckedUpdateWithoutAspNetUserRolesInput = {
    Id?: StringFieldUpdateOperationsInput | string
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedName?: NullableStringFieldUpdateOperationsInput | string | null
    ConcurrencyStamp?: NullableStringFieldUpdateOperationsInput | string | null
    AspNetRoleClaims?: AspNetRoleClaimsUncheckedUpdateManyWithoutAspNetRolesNestedInput
  }

  export type AspNetUsersUpsertWithoutAspNetUserRolesInput = {
    update: XOR<AspNetUsersUpdateWithoutAspNetUserRolesInput, AspNetUsersUncheckedUpdateWithoutAspNetUserRolesInput>
    create: XOR<AspNetUsersCreateWithoutAspNetUserRolesInput, AspNetUsersUncheckedCreateWithoutAspNetUserRolesInput>
    where?: AspNetUsersWhereInput
  }

  export type AspNetUsersUpdateToOneWithWhereWithoutAspNetUserRolesInput = {
    where?: AspNetUsersWhereInput
    data: XOR<AspNetUsersUpdateWithoutAspNetUserRolesInput, AspNetUsersUncheckedUpdateWithoutAspNetUserRolesInput>
  }

  export type AspNetUsersUpdateWithoutAspNetUserRolesInput = {
    Id?: StringFieldUpdateOperationsInput | string
    UserName?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedUserName?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    EmailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    PasswordHash?: NullableStringFieldUpdateOperationsInput | string | null
    SecurityStamp?: NullableStringFieldUpdateOperationsInput | string | null
    ConcurrencyStamp?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumberConfirmed?: BoolFieldUpdateOperationsInput | boolean
    TwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    LockoutEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LockoutEnabled?: BoolFieldUpdateOperationsInput | boolean
    AccessFailedCount?: IntFieldUpdateOperationsInput | number
    PasswordValidUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    DeviceId?: NullableStringFieldUpdateOperationsInput | string | null
    FcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    FullName?: NullableStringFieldUpdateOperationsInput | string | null
    AspNetUserClaims?: AspNetUserClaimsUpdateManyWithoutAspNetUsersNestedInput
    AspNetUserLogins?: AspNetUserLoginsUpdateManyWithoutAspNetUsersNestedInput
    AspNetUserTokens?: AspNetUserTokensUpdateManyWithoutAspNetUsersNestedInput
  }

  export type AspNetUsersUncheckedUpdateWithoutAspNetUserRolesInput = {
    Id?: StringFieldUpdateOperationsInput | string
    UserName?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedUserName?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    EmailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    PasswordHash?: NullableStringFieldUpdateOperationsInput | string | null
    SecurityStamp?: NullableStringFieldUpdateOperationsInput | string | null
    ConcurrencyStamp?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumberConfirmed?: BoolFieldUpdateOperationsInput | boolean
    TwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    LockoutEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LockoutEnabled?: BoolFieldUpdateOperationsInput | boolean
    AccessFailedCount?: IntFieldUpdateOperationsInput | number
    PasswordValidUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    DeviceId?: NullableStringFieldUpdateOperationsInput | string | null
    FcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    FullName?: NullableStringFieldUpdateOperationsInput | string | null
    AspNetUserClaims?: AspNetUserClaimsUncheckedUpdateManyWithoutAspNetUsersNestedInput
    AspNetUserLogins?: AspNetUserLoginsUncheckedUpdateManyWithoutAspNetUsersNestedInput
    AspNetUserTokens?: AspNetUserTokensUncheckedUpdateManyWithoutAspNetUsersNestedInput
  }

  export type AspNetUserClaimsCreateWithoutAspNetUsersInput = {
    ClaimType?: string | null
    ClaimValue?: string | null
  }

  export type AspNetUserClaimsUncheckedCreateWithoutAspNetUsersInput = {
    Id?: number
    ClaimType?: string | null
    ClaimValue?: string | null
  }

  export type AspNetUserClaimsCreateOrConnectWithoutAspNetUsersInput = {
    where: AspNetUserClaimsWhereUniqueInput
    create: XOR<AspNetUserClaimsCreateWithoutAspNetUsersInput, AspNetUserClaimsUncheckedCreateWithoutAspNetUsersInput>
  }

  export type AspNetUserClaimsCreateManyAspNetUsersInputEnvelope = {
    data: AspNetUserClaimsCreateManyAspNetUsersInput | AspNetUserClaimsCreateManyAspNetUsersInput[]
  }

  export type AspNetUserLoginsCreateWithoutAspNetUsersInput = {
    LoginProvider: string
    ProviderKey: string
    ProviderDisplayName?: string | null
  }

  export type AspNetUserLoginsUncheckedCreateWithoutAspNetUsersInput = {
    LoginProvider: string
    ProviderKey: string
    ProviderDisplayName?: string | null
  }

  export type AspNetUserLoginsCreateOrConnectWithoutAspNetUsersInput = {
    where: AspNetUserLoginsWhereUniqueInput
    create: XOR<AspNetUserLoginsCreateWithoutAspNetUsersInput, AspNetUserLoginsUncheckedCreateWithoutAspNetUsersInput>
  }

  export type AspNetUserLoginsCreateManyAspNetUsersInputEnvelope = {
    data: AspNetUserLoginsCreateManyAspNetUsersInput | AspNetUserLoginsCreateManyAspNetUsersInput[]
  }

  export type AspNetUserRolesCreateWithoutAspNetUsersInput = {
    AspNetRoles: AspNetRolesCreateNestedOneWithoutAspNetUserRolesInput
  }

  export type AspNetUserRolesUncheckedCreateWithoutAspNetUsersInput = {
    RoleId: string
  }

  export type AspNetUserRolesCreateOrConnectWithoutAspNetUsersInput = {
    where: AspNetUserRolesWhereUniqueInput
    create: XOR<AspNetUserRolesCreateWithoutAspNetUsersInput, AspNetUserRolesUncheckedCreateWithoutAspNetUsersInput>
  }

  export type AspNetUserRolesCreateManyAspNetUsersInputEnvelope = {
    data: AspNetUserRolesCreateManyAspNetUsersInput | AspNetUserRolesCreateManyAspNetUsersInput[]
  }

  export type AspNetUserTokensCreateWithoutAspNetUsersInput = {
    LoginProvider: string
    Name: string
    Value?: string | null
  }

  export type AspNetUserTokensUncheckedCreateWithoutAspNetUsersInput = {
    LoginProvider: string
    Name: string
    Value?: string | null
  }

  export type AspNetUserTokensCreateOrConnectWithoutAspNetUsersInput = {
    where: AspNetUserTokensWhereUniqueInput
    create: XOR<AspNetUserTokensCreateWithoutAspNetUsersInput, AspNetUserTokensUncheckedCreateWithoutAspNetUsersInput>
  }

  export type AspNetUserTokensCreateManyAspNetUsersInputEnvelope = {
    data: AspNetUserTokensCreateManyAspNetUsersInput | AspNetUserTokensCreateManyAspNetUsersInput[]
  }

  export type AspNetUserClaimsUpsertWithWhereUniqueWithoutAspNetUsersInput = {
    where: AspNetUserClaimsWhereUniqueInput
    update: XOR<AspNetUserClaimsUpdateWithoutAspNetUsersInput, AspNetUserClaimsUncheckedUpdateWithoutAspNetUsersInput>
    create: XOR<AspNetUserClaimsCreateWithoutAspNetUsersInput, AspNetUserClaimsUncheckedCreateWithoutAspNetUsersInput>
  }

  export type AspNetUserClaimsUpdateWithWhereUniqueWithoutAspNetUsersInput = {
    where: AspNetUserClaimsWhereUniqueInput
    data: XOR<AspNetUserClaimsUpdateWithoutAspNetUsersInput, AspNetUserClaimsUncheckedUpdateWithoutAspNetUsersInput>
  }

  export type AspNetUserClaimsUpdateManyWithWhereWithoutAspNetUsersInput = {
    where: AspNetUserClaimsScalarWhereInput
    data: XOR<AspNetUserClaimsUpdateManyMutationInput, AspNetUserClaimsUncheckedUpdateManyWithoutAspNetUsersInput>
  }

  export type AspNetUserClaimsScalarWhereInput = {
    AND?: AspNetUserClaimsScalarWhereInput | AspNetUserClaimsScalarWhereInput[]
    OR?: AspNetUserClaimsScalarWhereInput[]
    NOT?: AspNetUserClaimsScalarWhereInput | AspNetUserClaimsScalarWhereInput[]
    Id?: IntFilter<"AspNetUserClaims"> | number
    UserId?: StringFilter<"AspNetUserClaims"> | string
    ClaimType?: StringNullableFilter<"AspNetUserClaims"> | string | null
    ClaimValue?: StringNullableFilter<"AspNetUserClaims"> | string | null
  }

  export type AspNetUserLoginsUpsertWithWhereUniqueWithoutAspNetUsersInput = {
    where: AspNetUserLoginsWhereUniqueInput
    update: XOR<AspNetUserLoginsUpdateWithoutAspNetUsersInput, AspNetUserLoginsUncheckedUpdateWithoutAspNetUsersInput>
    create: XOR<AspNetUserLoginsCreateWithoutAspNetUsersInput, AspNetUserLoginsUncheckedCreateWithoutAspNetUsersInput>
  }

  export type AspNetUserLoginsUpdateWithWhereUniqueWithoutAspNetUsersInput = {
    where: AspNetUserLoginsWhereUniqueInput
    data: XOR<AspNetUserLoginsUpdateWithoutAspNetUsersInput, AspNetUserLoginsUncheckedUpdateWithoutAspNetUsersInput>
  }

  export type AspNetUserLoginsUpdateManyWithWhereWithoutAspNetUsersInput = {
    where: AspNetUserLoginsScalarWhereInput
    data: XOR<AspNetUserLoginsUpdateManyMutationInput, AspNetUserLoginsUncheckedUpdateManyWithoutAspNetUsersInput>
  }

  export type AspNetUserLoginsScalarWhereInput = {
    AND?: AspNetUserLoginsScalarWhereInput | AspNetUserLoginsScalarWhereInput[]
    OR?: AspNetUserLoginsScalarWhereInput[]
    NOT?: AspNetUserLoginsScalarWhereInput | AspNetUserLoginsScalarWhereInput[]
    LoginProvider?: StringFilter<"AspNetUserLogins"> | string
    ProviderKey?: StringFilter<"AspNetUserLogins"> | string
    ProviderDisplayName?: StringNullableFilter<"AspNetUserLogins"> | string | null
    UserId?: StringFilter<"AspNetUserLogins"> | string
  }

  export type AspNetUserRolesUpsertWithWhereUniqueWithoutAspNetUsersInput = {
    where: AspNetUserRolesWhereUniqueInput
    update: XOR<AspNetUserRolesUpdateWithoutAspNetUsersInput, AspNetUserRolesUncheckedUpdateWithoutAspNetUsersInput>
    create: XOR<AspNetUserRolesCreateWithoutAspNetUsersInput, AspNetUserRolesUncheckedCreateWithoutAspNetUsersInput>
  }

  export type AspNetUserRolesUpdateWithWhereUniqueWithoutAspNetUsersInput = {
    where: AspNetUserRolesWhereUniqueInput
    data: XOR<AspNetUserRolesUpdateWithoutAspNetUsersInput, AspNetUserRolesUncheckedUpdateWithoutAspNetUsersInput>
  }

  export type AspNetUserRolesUpdateManyWithWhereWithoutAspNetUsersInput = {
    where: AspNetUserRolesScalarWhereInput
    data: XOR<AspNetUserRolesUpdateManyMutationInput, AspNetUserRolesUncheckedUpdateManyWithoutAspNetUsersInput>
  }

  export type AspNetUserTokensUpsertWithWhereUniqueWithoutAspNetUsersInput = {
    where: AspNetUserTokensWhereUniqueInput
    update: XOR<AspNetUserTokensUpdateWithoutAspNetUsersInput, AspNetUserTokensUncheckedUpdateWithoutAspNetUsersInput>
    create: XOR<AspNetUserTokensCreateWithoutAspNetUsersInput, AspNetUserTokensUncheckedCreateWithoutAspNetUsersInput>
  }

  export type AspNetUserTokensUpdateWithWhereUniqueWithoutAspNetUsersInput = {
    where: AspNetUserTokensWhereUniqueInput
    data: XOR<AspNetUserTokensUpdateWithoutAspNetUsersInput, AspNetUserTokensUncheckedUpdateWithoutAspNetUsersInput>
  }

  export type AspNetUserTokensUpdateManyWithWhereWithoutAspNetUsersInput = {
    where: AspNetUserTokensScalarWhereInput
    data: XOR<AspNetUserTokensUpdateManyMutationInput, AspNetUserTokensUncheckedUpdateManyWithoutAspNetUsersInput>
  }

  export type AspNetUserTokensScalarWhereInput = {
    AND?: AspNetUserTokensScalarWhereInput | AspNetUserTokensScalarWhereInput[]
    OR?: AspNetUserTokensScalarWhereInput[]
    NOT?: AspNetUserTokensScalarWhereInput | AspNetUserTokensScalarWhereInput[]
    UserId?: StringFilter<"AspNetUserTokens"> | string
    LoginProvider?: StringFilter<"AspNetUserTokens"> | string
    Name?: StringFilter<"AspNetUserTokens"> | string
    Value?: StringNullableFilter<"AspNetUserTokens"> | string | null
  }

  export type AspNetUsersCreateWithoutAspNetUserTokensInput = {
    Id: string
    UserName?: string | null
    NormalizedUserName?: string | null
    Email?: string | null
    NormalizedEmail?: string | null
    EmailConfirmed: boolean
    PasswordHash?: string | null
    SecurityStamp?: string | null
    ConcurrencyStamp?: string | null
    PhoneNumber?: string | null
    PhoneNumberConfirmed: boolean
    TwoFactorEnabled: boolean
    LockoutEnd?: Date | string | null
    LockoutEnabled: boolean
    AccessFailedCount: number
    PasswordValidUntil: Date | string
    DeviceId?: string | null
    FcmToken?: string | null
    FullName?: string | null
    AspNetUserClaims?: AspNetUserClaimsCreateNestedManyWithoutAspNetUsersInput
    AspNetUserLogins?: AspNetUserLoginsCreateNestedManyWithoutAspNetUsersInput
    AspNetUserRoles?: AspNetUserRolesCreateNestedManyWithoutAspNetUsersInput
  }

  export type AspNetUsersUncheckedCreateWithoutAspNetUserTokensInput = {
    Id: string
    UserName?: string | null
    NormalizedUserName?: string | null
    Email?: string | null
    NormalizedEmail?: string | null
    EmailConfirmed: boolean
    PasswordHash?: string | null
    SecurityStamp?: string | null
    ConcurrencyStamp?: string | null
    PhoneNumber?: string | null
    PhoneNumberConfirmed: boolean
    TwoFactorEnabled: boolean
    LockoutEnd?: Date | string | null
    LockoutEnabled: boolean
    AccessFailedCount: number
    PasswordValidUntil: Date | string
    DeviceId?: string | null
    FcmToken?: string | null
    FullName?: string | null
    AspNetUserClaims?: AspNetUserClaimsUncheckedCreateNestedManyWithoutAspNetUsersInput
    AspNetUserLogins?: AspNetUserLoginsUncheckedCreateNestedManyWithoutAspNetUsersInput
    AspNetUserRoles?: AspNetUserRolesUncheckedCreateNestedManyWithoutAspNetUsersInput
  }

  export type AspNetUsersCreateOrConnectWithoutAspNetUserTokensInput = {
    where: AspNetUsersWhereUniqueInput
    create: XOR<AspNetUsersCreateWithoutAspNetUserTokensInput, AspNetUsersUncheckedCreateWithoutAspNetUserTokensInput>
  }

  export type AspNetUsersUpsertWithoutAspNetUserTokensInput = {
    update: XOR<AspNetUsersUpdateWithoutAspNetUserTokensInput, AspNetUsersUncheckedUpdateWithoutAspNetUserTokensInput>
    create: XOR<AspNetUsersCreateWithoutAspNetUserTokensInput, AspNetUsersUncheckedCreateWithoutAspNetUserTokensInput>
    where?: AspNetUsersWhereInput
  }

  export type AspNetUsersUpdateToOneWithWhereWithoutAspNetUserTokensInput = {
    where?: AspNetUsersWhereInput
    data: XOR<AspNetUsersUpdateWithoutAspNetUserTokensInput, AspNetUsersUncheckedUpdateWithoutAspNetUserTokensInput>
  }

  export type AspNetUsersUpdateWithoutAspNetUserTokensInput = {
    Id?: StringFieldUpdateOperationsInput | string
    UserName?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedUserName?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    EmailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    PasswordHash?: NullableStringFieldUpdateOperationsInput | string | null
    SecurityStamp?: NullableStringFieldUpdateOperationsInput | string | null
    ConcurrencyStamp?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumberConfirmed?: BoolFieldUpdateOperationsInput | boolean
    TwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    LockoutEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LockoutEnabled?: BoolFieldUpdateOperationsInput | boolean
    AccessFailedCount?: IntFieldUpdateOperationsInput | number
    PasswordValidUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    DeviceId?: NullableStringFieldUpdateOperationsInput | string | null
    FcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    FullName?: NullableStringFieldUpdateOperationsInput | string | null
    AspNetUserClaims?: AspNetUserClaimsUpdateManyWithoutAspNetUsersNestedInput
    AspNetUserLogins?: AspNetUserLoginsUpdateManyWithoutAspNetUsersNestedInput
    AspNetUserRoles?: AspNetUserRolesUpdateManyWithoutAspNetUsersNestedInput
  }

  export type AspNetUsersUncheckedUpdateWithoutAspNetUserTokensInput = {
    Id?: StringFieldUpdateOperationsInput | string
    UserName?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedUserName?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    NormalizedEmail?: NullableStringFieldUpdateOperationsInput | string | null
    EmailConfirmed?: BoolFieldUpdateOperationsInput | boolean
    PasswordHash?: NullableStringFieldUpdateOperationsInput | string | null
    SecurityStamp?: NullableStringFieldUpdateOperationsInput | string | null
    ConcurrencyStamp?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    PhoneNumberConfirmed?: BoolFieldUpdateOperationsInput | boolean
    TwoFactorEnabled?: BoolFieldUpdateOperationsInput | boolean
    LockoutEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LockoutEnabled?: BoolFieldUpdateOperationsInput | boolean
    AccessFailedCount?: IntFieldUpdateOperationsInput | number
    PasswordValidUntil?: DateTimeFieldUpdateOperationsInput | Date | string
    DeviceId?: NullableStringFieldUpdateOperationsInput | string | null
    FcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    FullName?: NullableStringFieldUpdateOperationsInput | string | null
    AspNetUserClaims?: AspNetUserClaimsUncheckedUpdateManyWithoutAspNetUsersNestedInput
    AspNetUserLogins?: AspNetUserLoginsUncheckedUpdateManyWithoutAspNetUsersNestedInput
    AspNetUserRoles?: AspNetUserRolesUncheckedUpdateManyWithoutAspNetUsersNestedInput
  }

  export type VisaProvisionedTokensCreateWithoutTokenStatusesInput = {
    ProvisionedTokenId: string
    PhoneNumber: string
    DeviceId?: string | null
    PanEnrollmentId?: string | null
  }

  export type VisaProvisionedTokensUncheckedCreateWithoutTokenStatusesInput = {
    ProvisionedTokenId: string
    PhoneNumber: string
    DeviceId?: string | null
    PanEnrollmentId?: string | null
  }

  export type VisaProvisionedTokensCreateOrConnectWithoutTokenStatusesInput = {
    where: VisaProvisionedTokensWhereUniqueInput
    create: XOR<VisaProvisionedTokensCreateWithoutTokenStatusesInput, VisaProvisionedTokensUncheckedCreateWithoutTokenStatusesInput>
  }

  export type VisaProvisionedTokensCreateManyTokenStatusesInputEnvelope = {
    data: VisaProvisionedTokensCreateManyTokenStatusesInput | VisaProvisionedTokensCreateManyTokenStatusesInput[]
  }

  export type VisaProvisionedTokensUpsertWithWhereUniqueWithoutTokenStatusesInput = {
    where: VisaProvisionedTokensWhereUniqueInput
    update: XOR<VisaProvisionedTokensUpdateWithoutTokenStatusesInput, VisaProvisionedTokensUncheckedUpdateWithoutTokenStatusesInput>
    create: XOR<VisaProvisionedTokensCreateWithoutTokenStatusesInput, VisaProvisionedTokensUncheckedCreateWithoutTokenStatusesInput>
  }

  export type VisaProvisionedTokensUpdateWithWhereUniqueWithoutTokenStatusesInput = {
    where: VisaProvisionedTokensWhereUniqueInput
    data: XOR<VisaProvisionedTokensUpdateWithoutTokenStatusesInput, VisaProvisionedTokensUncheckedUpdateWithoutTokenStatusesInput>
  }

  export type VisaProvisionedTokensUpdateManyWithWhereWithoutTokenStatusesInput = {
    where: VisaProvisionedTokensScalarWhereInput
    data: XOR<VisaProvisionedTokensUpdateManyMutationInput, VisaProvisionedTokensUncheckedUpdateManyWithoutTokenStatusesInput>
  }

  export type VisaProvisionedTokensScalarWhereInput = {
    AND?: VisaProvisionedTokensScalarWhereInput | VisaProvisionedTokensScalarWhereInput[]
    OR?: VisaProvisionedTokensScalarWhereInput[]
    NOT?: VisaProvisionedTokensScalarWhereInput | VisaProvisionedTokensScalarWhereInput[]
    ProvisionedTokenId?: StringFilter<"VisaProvisionedTokens"> | string
    PhoneNumber?: StringFilter<"VisaProvisionedTokens"> | string
    DeviceId?: StringNullableFilter<"VisaProvisionedTokens"> | string | null
    StatusId?: IntNullableFilter<"VisaProvisionedTokens"> | number | null
    PanEnrollmentId?: StringNullableFilter<"VisaProvisionedTokens"> | string | null
  }

  export type TokenStatusesCreateWithoutVisaProvisionedTokensInput = {
    Name?: string | null
    CardProviderName?: string | null
    IsSuspended: boolean
    IsDeleted: boolean
    IsActive: boolean
    IsInactive: boolean
  }

  export type TokenStatusesUncheckedCreateWithoutVisaProvisionedTokensInput = {
    ID?: number
    Name?: string | null
    CardProviderName?: string | null
    IsSuspended: boolean
    IsDeleted: boolean
    IsActive: boolean
    IsInactive: boolean
  }

  export type TokenStatusesCreateOrConnectWithoutVisaProvisionedTokensInput = {
    where: TokenStatusesWhereUniqueInput
    create: XOR<TokenStatusesCreateWithoutVisaProvisionedTokensInput, TokenStatusesUncheckedCreateWithoutVisaProvisionedTokensInput>
  }

  export type TokenStatusesUpsertWithoutVisaProvisionedTokensInput = {
    update: XOR<TokenStatusesUpdateWithoutVisaProvisionedTokensInput, TokenStatusesUncheckedUpdateWithoutVisaProvisionedTokensInput>
    create: XOR<TokenStatusesCreateWithoutVisaProvisionedTokensInput, TokenStatusesUncheckedCreateWithoutVisaProvisionedTokensInput>
    where?: TokenStatusesWhereInput
  }

  export type TokenStatusesUpdateToOneWithWhereWithoutVisaProvisionedTokensInput = {
    where?: TokenStatusesWhereInput
    data: XOR<TokenStatusesUpdateWithoutVisaProvisionedTokensInput, TokenStatusesUncheckedUpdateWithoutVisaProvisionedTokensInput>
  }

  export type TokenStatusesUpdateWithoutVisaProvisionedTokensInput = {
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    CardProviderName?: NullableStringFieldUpdateOperationsInput | string | null
    IsSuspended?: BoolFieldUpdateOperationsInput | boolean
    IsDeleted?: BoolFieldUpdateOperationsInput | boolean
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    IsInactive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TokenStatusesUncheckedUpdateWithoutVisaProvisionedTokensInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    CardProviderName?: NullableStringFieldUpdateOperationsInput | string | null
    IsSuspended?: BoolFieldUpdateOperationsInput | boolean
    IsDeleted?: BoolFieldUpdateOperationsInput | boolean
    IsActive?: BoolFieldUpdateOperationsInput | boolean
    IsInactive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AspNetRoleClaimsCreateManyAspNetRolesInput = {
    ClaimType?: string | null
    ClaimValue?: string | null
  }

  export type AspNetUserRolesCreateManyAspNetRolesInput = {
    UserId: string
  }

  export type AspNetRoleClaimsUpdateWithoutAspNetRolesInput = {
    ClaimType?: NullableStringFieldUpdateOperationsInput | string | null
    ClaimValue?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AspNetRoleClaimsUncheckedUpdateWithoutAspNetRolesInput = {
    Id?: IntFieldUpdateOperationsInput | number
    ClaimType?: NullableStringFieldUpdateOperationsInput | string | null
    ClaimValue?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AspNetRoleClaimsUncheckedUpdateManyWithoutAspNetRolesInput = {
    Id?: IntFieldUpdateOperationsInput | number
    ClaimType?: NullableStringFieldUpdateOperationsInput | string | null
    ClaimValue?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AspNetUserRolesUpdateWithoutAspNetRolesInput = {
    AspNetUsers?: AspNetUsersUpdateOneRequiredWithoutAspNetUserRolesNestedInput
  }

  export type AspNetUserRolesUncheckedUpdateWithoutAspNetRolesInput = {
    UserId?: StringFieldUpdateOperationsInput | string
  }

  export type AspNetUserRolesUncheckedUpdateManyWithoutAspNetRolesInput = {
    UserId?: StringFieldUpdateOperationsInput | string
  }

  export type AspNetUserClaimsCreateManyAspNetUsersInput = {
    ClaimType?: string | null
    ClaimValue?: string | null
  }

  export type AspNetUserLoginsCreateManyAspNetUsersInput = {
    LoginProvider: string
    ProviderKey: string
    ProviderDisplayName?: string | null
  }

  export type AspNetUserRolesCreateManyAspNetUsersInput = {
    RoleId: string
  }

  export type AspNetUserTokensCreateManyAspNetUsersInput = {
    LoginProvider: string
    Name: string
    Value?: string | null
  }

  export type AspNetUserClaimsUpdateWithoutAspNetUsersInput = {
    ClaimType?: NullableStringFieldUpdateOperationsInput | string | null
    ClaimValue?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AspNetUserClaimsUncheckedUpdateWithoutAspNetUsersInput = {
    Id?: IntFieldUpdateOperationsInput | number
    ClaimType?: NullableStringFieldUpdateOperationsInput | string | null
    ClaimValue?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AspNetUserClaimsUncheckedUpdateManyWithoutAspNetUsersInput = {
    Id?: IntFieldUpdateOperationsInput | number
    ClaimType?: NullableStringFieldUpdateOperationsInput | string | null
    ClaimValue?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AspNetUserLoginsUpdateWithoutAspNetUsersInput = {
    LoginProvider?: StringFieldUpdateOperationsInput | string
    ProviderKey?: StringFieldUpdateOperationsInput | string
    ProviderDisplayName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AspNetUserLoginsUncheckedUpdateWithoutAspNetUsersInput = {
    LoginProvider?: StringFieldUpdateOperationsInput | string
    ProviderKey?: StringFieldUpdateOperationsInput | string
    ProviderDisplayName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AspNetUserLoginsUncheckedUpdateManyWithoutAspNetUsersInput = {
    LoginProvider?: StringFieldUpdateOperationsInput | string
    ProviderKey?: StringFieldUpdateOperationsInput | string
    ProviderDisplayName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AspNetUserRolesUpdateWithoutAspNetUsersInput = {
    AspNetRoles?: AspNetRolesUpdateOneRequiredWithoutAspNetUserRolesNestedInput
  }

  export type AspNetUserRolesUncheckedUpdateWithoutAspNetUsersInput = {
    RoleId?: StringFieldUpdateOperationsInput | string
  }

  export type AspNetUserRolesUncheckedUpdateManyWithoutAspNetUsersInput = {
    RoleId?: StringFieldUpdateOperationsInput | string
  }

  export type AspNetUserTokensUpdateWithoutAspNetUsersInput = {
    LoginProvider?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AspNetUserTokensUncheckedUpdateWithoutAspNetUsersInput = {
    LoginProvider?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AspNetUserTokensUncheckedUpdateManyWithoutAspNetUsersInput = {
    LoginProvider?: StringFieldUpdateOperationsInput | string
    Name?: StringFieldUpdateOperationsInput | string
    Value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VisaProvisionedTokensCreateManyTokenStatusesInput = {
    ProvisionedTokenId: string
    PhoneNumber: string
    DeviceId?: string | null
    PanEnrollmentId?: string | null
  }

  export type VisaProvisionedTokensUpdateWithoutTokenStatusesInput = {
    ProvisionedTokenId?: StringFieldUpdateOperationsInput | string
    PhoneNumber?: StringFieldUpdateOperationsInput | string
    DeviceId?: NullableStringFieldUpdateOperationsInput | string | null
    PanEnrollmentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VisaProvisionedTokensUncheckedUpdateWithoutTokenStatusesInput = {
    ProvisionedTokenId?: StringFieldUpdateOperationsInput | string
    PhoneNumber?: StringFieldUpdateOperationsInput | string
    DeviceId?: NullableStringFieldUpdateOperationsInput | string | null
    PanEnrollmentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VisaProvisionedTokensUncheckedUpdateManyWithoutTokenStatusesInput = {
    ProvisionedTokenId?: StringFieldUpdateOperationsInput | string
    PhoneNumber?: StringFieldUpdateOperationsInput | string
    DeviceId?: NullableStringFieldUpdateOperationsInput | string | null
    PanEnrollmentId?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}